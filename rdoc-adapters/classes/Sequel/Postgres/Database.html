<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>Sequel::Postgres::Database</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='class' id='wrapper'>
      <div class='header'>
        <h1 class='name'>
          <span class='type'>class</span>
          Sequel::Postgres::Database
        </h1>
        <ol class='paths'>
          <li>
            <a target="docwin" href="../../../files/lib/sequel/adapters/postgres_rb.html">lib/sequel/adapters/postgres.rb</a>
          </li>
        </ol>
        <div class='parent'>
          Parent:
          <strong><a target="docwin" href="../Postgres.html">Postgres</a></strong>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <p><a href="Database.html">Database</a> class for PostgreSQL databases used
            with <a href="../../Sequel.html">Sequel</a> and the pg, postgres, or
            postgres-pr driver.</p>
          </div>
          <div id='method-list'>
            <h2>Methods</h2>
            <h3>Public Instance</h3>
            <ol>
              <li><a target="docwin" href="#method-i-bound_variable_arg">bound_variable_arg</a></li>
              <li><a target="docwin" href="#method-i-connect">connect</a></li>
              <li><a target="docwin" href="#attribute-i-convert_infinite_timestamps">convert_infinite_timestamps</a></li>
              <li><a target="docwin" href="#method-i-convert_infinite_timestamps-3D">convert_infinite_timestamps=</a></li>
              <li><a target="docwin" href="#method-i-copy_into">copy_into</a></li>
              <li><a target="docwin" href="#method-i-copy_table">copy_table</a></li>
              <li><a target="docwin" href="#method-i-disconnect_connection">disconnect_connection</a></li>
              <li><a target="docwin" href="#method-i-error_info">error_info</a></li>
              <li><a target="docwin" href="#method-i-execute">execute</a></li>
              <li><a target="docwin" href="#method-i-listen">listen</a></li>
              <li><a target="docwin" href="#method-i-to_application_timestamp">to_application_timestamp</a></li>
            </ol>
          </div>
          <div id='context'>
            <div id='includes'>
              <h2>Included modules</h2>
              <ol>
                <li><a target="docwin" href="DatabaseMethods.html">Sequel::Postgres::DatabaseMethods</a></li>
              </ol>
            </div>
          </div>
          <div id='section'>
            <div id='constants-list'>
              <h2>Constants</h2>
              <div class='name-list'>
                <table summary='Constants'>
                  <tr class='top-aligned-row context-row'>
                    <td class='context-item-name'>INFINITE_DATETIME_VALUES</td>
                    <td>=</td>
                    <td class='context-item-value'>([PLUS_INFINITY, MINUS_INFINITY] + INFINITE_TIMESTAMP_STRINGS).freeze</td>
                    <td>&nbsp;</td>
                    <td class='context-item-desc'></td>
                  </tr>
                  <tr class='top-aligned-row context-row'>
                    <td class='context-item-name'>INFINITE_TIMESTAMP_STRINGS</td>
                    <td>=</td>
                    <td class='context-item-value'>['infinity'.freeze, '-infinity'.freeze].freeze</td>
                    <td>&nbsp;</td>
                    <td class='context-item-desc'></td>
                  </tr>
                </table>
              </div>
            </div>
            <div id='attribute-list'>
              <h2 class='section-bar'>Attributes</h2>
              <div class='name-list'>
                <table>
                  <tr class='top-aligned-row context-row'>
                    <td class='context-item-name'>
                      <a name='attribute-i-convert_infinite_timestamps'>convert_infinite_timestamps</a>
                    </td>
                    <td class='context-item-value'>[R]</td>
                    <td class='context-item-desc'>
                      
                      <p>Whether infinite timestamps/dates should be converted on retrieval.  By
                      default, no conversion is done, so an error is raised if you attempt to
                      retrieve an infinite timestamp/date.  You can set this to :nil to convert
                      to nil, :string to leave as a string, or :float to convert to an infinite
                      float.</p>
                    </td>
                  </tr>
                </table>
              </div>
            </div>
            <div id='methods'>
              <h2>Public Instance methods</h2>
              <div class='method public-instance' id='method-method-i-bound_variable_arg'>
                <a name='method-i-bound_variable_arg'></a>
                <div class='synopsis'>
                  <span class='name'>bound_variable_arg</span>
                  <span class='arguments'>(arg, conn)</span>
                </div>
                <div class='description'>
                  
                  <p>Convert given argument so that it can be used directly by pg.  Currently,
                  pg doesn’t handle fractional seconds in Time/DateTime or blobs with “0”,
                  and it won’t ever handle Sequel::SQLTime values correctly.  Only public for
                  use by the adapter, shouldn’t be used by external code.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-bound_variable_arg-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-bound_variable_arg-source'><span class="ruby-comment"># File lib/sequel/adapters/postgres.rb, line 185</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">bound_variable_arg</span>(<span class="ruby-identifier">arg</span>, <span class="ruby-identifier">conn</span>)&#x000A;  <span class="ruby-keyword">case</span> <span class="ruby-identifier">arg</span>&#x000A;  <span class="ruby-keyword">when</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">Blob</span>&#x000A;    <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">escape_bytea</span>(<span class="ruby-identifier">arg</span>)&#x000A;  <span class="ruby-keyword">when</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">SQLTime</span>&#x000A;    <span class="ruby-identifier">literal</span>(<span class="ruby-identifier">arg</span>)&#x000A;  <span class="ruby-keyword">when</span> <span class="ruby-constant">DateTime</span>, <span class="ruby-constant">Time</span>&#x000A;    <span class="ruby-identifier">literal</span>(<span class="ruby-identifier">arg</span>)&#x000A;  <span class="ruby-keyword">else</span>&#x000A;    <span class="ruby-identifier">arg</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method public-instance' id='method-method-i-connect'>
                <a name='method-i-connect'></a>
                <div class='synopsis'>
                  <span class='name'>connect</span>
                  <span class='arguments'>(server)</span>
                </div>
                <div class='description'>
                  
                  <p>Connects to the database.  In addition to the standard database options,
                  using the :encoding or :charset option changes the client encoding for the
                  connection, :connect_timeout is a connection timeout in seconds, and
                  :sslmode sets whether postgres’s sslmode.  :connect_timeout and :ssl_mode
                  are only supported if the pg driver is used.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-connect-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-connect-source'><span class="ruby-comment"># File lib/sequel/adapters/postgres.rb, line 204</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">connect</span>(<span class="ruby-identifier">server</span>)&#x000A;  <span class="ruby-identifier">opts</span> = <span class="ruby-identifier">server_opts</span>(<span class="ruby-identifier">server</span>)&#x000A;  <span class="ruby-identifier">conn</span> = <span class="ruby-keyword">if</span> <span class="ruby-constant">SEQUEL_POSTGRES_USES_PG</span>&#x000A;    <span class="ruby-identifier">connection_params</span> = {&#x000A;      <span class="ruby-value">:host</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:host</span>],&#x000A;      <span class="ruby-value">:port</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:port</span>] <span class="ruby-operator">||</span> <span class="ruby-value">5432</span>,&#x000A;      <span class="ruby-value">:dbname</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:database</span>],&#x000A;      <span class="ruby-value">:user</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:user</span>],&#x000A;      <span class="ruby-value">:password</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:password</span>],&#x000A;      <span class="ruby-value">:connect_timeout</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:connect_timeout</span>] <span class="ruby-operator">||</span> <span class="ruby-value">20</span>,&#x000A;      <span class="ruby-value">:sslmode</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:sslmode</span>]&#x000A;    }.<span class="ruby-identifier">delete_if</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">blank_object?</span>(<span class="ruby-identifier">value</span>) }&#x000A;    <span class="ruby-constant">Adapter</span>.<span class="ruby-identifier">connect</span>(<span class="ruby-identifier">connection_params</span>)&#x000A;  <span class="ruby-keyword">else</span>&#x000A;    <span class="ruby-constant">Adapter</span>.<span class="ruby-identifier">connect</span>(&#x000A;      (<span class="ruby-identifier">opts</span>[<span class="ruby-value">:host</span>] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">blank_object?</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:host</span>])),&#x000A;      <span class="ruby-identifier">opts</span>[<span class="ruby-value">:port</span>] <span class="ruby-operator">||</span> <span class="ruby-value">5432</span>,&#x000A;      <span class="ruby-keyword">nil</span>, <span class="ruby-string">''</span>,&#x000A;      <span class="ruby-identifier">opts</span>[<span class="ruby-value">:database</span>],&#x000A;      <span class="ruby-identifier">opts</span>[<span class="ruby-value">:user</span>],&#x000A;      <span class="ruby-identifier">opts</span>[<span class="ruby-value">:password</span>]&#x000A;    )&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">if</span> <span class="ruby-identifier">encoding</span> = <span class="ruby-identifier">opts</span>[<span class="ruby-value">:encoding</span>] <span class="ruby-operator">||</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:charset</span>]&#x000A;    <span class="ruby-keyword">if</span> <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:set_client_encoding</span>)&#x000A;      <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">set_client_encoding</span>(<span class="ruby-identifier">encoding</span>)&#x000A;    <span class="ruby-keyword">else</span>&#x000A;      <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">async_exec</span>(<span class="ruby-node">&quot;set client_encoding to '#{encoding}'&quot;</span>)&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">instance_variable_set</span>(<span class="ruby-value">:@db</span>, <span class="ruby-keyword">self</span>)&#x000A;  <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">instance_variable_set</span>(<span class="ruby-value">:@prepared_statements</span>, {}) <span class="ruby-keyword">if</span> <span class="ruby-constant">SEQUEL_POSTGRES_USES_PG</span>&#x000A;  <span class="ruby-identifier">connection_configuration_sqls</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">sql</span><span class="ruby-operator">|</span> <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">execute</span>(<span class="ruby-identifier">sql</span>)}&#x000A;  <span class="ruby-identifier">conn</span>&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method public-instance' id='method-method-i-convert_infinite_timestamps-3D'>
                <a name='method-i-convert_infinite_timestamps-3D'></a>
                <div class='synopsis'>
                  <span class='name'>convert_infinite_timestamps=</span>
                  <span class='arguments'>(v)</span>
                </div>
                <div class='description'>
                  
                  <p>Set whether to allow infinite timestamps/dates.  Make sure the conversion
                  proc for date reflects that setting.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-convert_infinite_timestamps-3D-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-convert_infinite_timestamps-3D-source'><span class="ruby-comment"># File lib/sequel/adapters/postgres.rb, line 242</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">convert_infinite_timestamps=</span>(<span class="ruby-identifier">v</span>)&#x000A;  <span class="ruby-ivar">@convert_infinite_timestamps</span> = <span class="ruby-keyword">case</span> <span class="ruby-identifier">v</span>&#x000A;  <span class="ruby-keyword">when</span> <span class="ruby-constant">Symbol</span>&#x000A;    <span class="ruby-identifier">v</span>&#x000A;  <span class="ruby-keyword">when</span> <span class="ruby-string">'nil'</span>&#x000A;    <span class="ruby-value">:nil</span>&#x000A;  <span class="ruby-keyword">when</span> <span class="ruby-string">'string'</span>&#x000A;    <span class="ruby-value">:string</span>&#x000A;  <span class="ruby-keyword">when</span> <span class="ruby-string">'float'</span>&#x000A;    <span class="ruby-value">:float</span>&#x000A;  <span class="ruby-keyword">when</span> <span class="ruby-constant">String</span>&#x000A;    <span class="ruby-identifier">typecast_value_boolean</span>(<span class="ruby-identifier">v</span>)&#x000A;  <span class="ruby-keyword">else</span>&#x000A;    <span class="ruby-keyword">false</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-identifier">pr</span> = <span class="ruby-identifier">old_pr</span> = <span class="ruby-ivar">@use_iso_date_format</span> <span class="ruby-operator">?</span> <span class="ruby-constant">TYPE_TRANSLATOR</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:date</span>) <span class="ruby-operator">:</span> <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:string_to_date</span>)&#x000A;  <span class="ruby-keyword">if</span> <span class="ruby-identifier">v</span>&#x000A;    <span class="ruby-identifier">pr</span> = <span class="ruby-identifier">lambda</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">val</span><span class="ruby-operator">|</span>&#x000A;      <span class="ruby-keyword">case</span> <span class="ruby-identifier">val</span>&#x000A;      <span class="ruby-keyword">when</span> *<span class="ruby-constant">INFINITE_TIMESTAMP_STRINGS</span>&#x000A;        <span class="ruby-identifier">infinite_timestamp_value</span>(<span class="ruby-identifier">val</span>)&#x000A;      <span class="ruby-keyword">else</span>&#x000A;        <span class="ruby-identifier">old_pr</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">val</span>)&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-identifier">conversion_procs</span>[<span class="ruby-value">1082</span>] = <span class="ruby-identifier">pr</span>&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method public-instance' id='method-method-i-copy_into'>
                <a name='method-i-copy_into'></a>
                <div class='synopsis'>
                  <span class='name'>copy_into</span>
                  <span class='arguments'>(table, opts=OPTS)</span>
                </div>
                <div class='description'>
                  
                  <p><code>copy_into</code> uses PostgreSQL's +COPY FROM STDIN+ SQL statement to
                  do very fast inserts  into a table using input preformatting in either CSV
                  or PostgreSQL text format. This method is only supported if pg 0.14.0+ is
                  the underlying ruby driver. This method should only be called if you want
                  results returned to the client.  If you are using +COPY FROM+ with a
                  filename, you should just use <code>run</code> instead of this method.</p>
                  
                  <p>The following options are respected:</p>
                  <dl class="rdoc-list note-list"><dt>:columns 
                  <dd>
                  <p>The columns to insert into, with the same order as the columns in the input
                  data.  If this isn’t given, uses all columns in the table.</p>
                  </dd><dt>:data 
                  <dd>
                  <p>The data to copy to PostgreSQL, which should already be in CSV or
                  PostgreSQL text format.  This can be either a string, or any object that
                  responds to each and yields string.</p>
                  </dd><dt>:format 
                  <dd>
                  <p>The format to use.  text is the default, so this should be :csv or :binary.</p>
                  </dd><dt>:options 
                  <dd>
                  <p>An options SQL string to use, which should contain comma separated options.</p>
                  </dd><dt>:server 
                  <dd>
                  <p>The server on which to run the query.</p>
                  </dd></dl>
                  
                  <p>If a block is provided and :data option is not, this will yield to the
                  block repeatedly. The block should return a string, or nil to signal that
                  it is finished.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-copy_into-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-copy_into-source'><span class="ruby-comment"># File lib/sequel/adapters/postgres.rb, line 375</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">copy_into</span>(<span class="ruby-identifier">table</span>, <span class="ruby-identifier">opts</span>=<span class="ruby-constant">OPTS</span>)&#x000A;  <span class="ruby-identifier">data</span> = <span class="ruby-identifier">opts</span>[<span class="ruby-value">:data</span>]&#x000A;  <span class="ruby-identifier">data</span> = <span class="ruby-constant">Array</span>(<span class="ruby-identifier">data</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">data</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">String</span>)&#x000A;&#x000A;  <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">data</span>&#x000A;    <span class="ruby-identifier">raise</span> <span class="ruby-constant">Error</span>, <span class="ruby-string">&quot;Cannot provide both a :data option and a block to copy_into&quot;</span>&#x000A;  <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">block_given?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">data</span>&#x000A;    <span class="ruby-identifier">raise</span> <span class="ruby-constant">Error</span>, <span class="ruby-string">&quot;Must provide either a :data option or a block to copy_into&quot;</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-identifier">synchronize</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:server</span>]) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">conn</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">execute</span>(<span class="ruby-identifier">copy_into_sql</span>(<span class="ruby-identifier">table</span>, <span class="ruby-identifier">opts</span>))&#x000A;    <span class="ruby-keyword">begin</span>&#x000A;      <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>&#x000A;        <span class="ruby-keyword">while</span> <span class="ruby-identifier">buf</span> = <span class="ruby-keyword">yield</span>&#x000A;          <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">put_copy_data</span>(<span class="ruby-identifier">buf</span>)&#x000A;        <span class="ruby-keyword">end</span>&#x000A;      <span class="ruby-keyword">else</span>&#x000A;        <span class="ruby-identifier">data</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">buff</span><span class="ruby-operator">|</span> <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">put_copy_data</span>(<span class="ruby-identifier">buff</span>)}&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">rescue</span> <span class="ruby-constant">Exception</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">e</span>&#x000A;      <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">put_copy_end</span>(<span class="ruby-string">&quot;ruby exception occurred while copying data into PostgreSQL&quot;</span>)&#x000A;    <span class="ruby-keyword">ensure</span>&#x000A;      <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">put_copy_end</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">e</span>&#x000A;      <span class="ruby-keyword">while</span> <span class="ruby-identifier">res</span> = <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">get_result</span>&#x000A;        <span class="ruby-identifier">raise</span> <span class="ruby-identifier">e</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">e</span>&#x000A;        <span class="ruby-identifier">check_database_errors</span>{<span class="ruby-identifier">res</span>.<span class="ruby-identifier">check</span>}&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span> &#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method public-instance' id='method-method-i-copy_table'>
                <a name='method-i-copy_table'></a>
                <div class='synopsis'>
                  <span class='name'>copy_table</span>
                  <span class='arguments'>(table, opts=OPTS)</span>
                </div>
                <div class='description'>
                  
                  <p><code>copy_table</code> uses PostgreSQL's +COPY TO STDOUT+ SQL statement to
                  return formatted results directly to the caller.  This method is only
                  supported if pg is the underlying ruby driver.  This method should only be
                  called if you want results returned to the client.  If you are using +COPY
                  TO+ with a filename, you should just use <code>run</code> instead of this
                  method.</p>
                  
                  <p>The table argument supports the following types:</p>
                  <dl class="rdoc-list note-list"><dt>String 
                  <dd>
                  <p>Uses the first argument directly as literal SQL. If you are using a version
                  of PostgreSQL before 9.0, you will probably want to use a string if you are
                  using any options at all, as the syntax <a
                  href="../../Sequel.html">Sequel</a> uses for options is only compatible
                  with PostgreSQL 9.0+.</p>
                  </dd><dt><a href="Dataset.html">Dataset</a> 
                  <dd>
                  <p>Uses a query instead of a table name when copying.</p>
                  </dd><dt>other 
                  <dd>
                  <p>Uses a table name (usually a symbol) when copying.</p>
                  </dd></dl>
                  
                  <p>The following options are respected:</p>
                  <dl class="rdoc-list note-list"><dt>:format 
                  <dd>
                  <p>The format to use.  text is the default, so this should be :csv or :binary.</p>
                  </dd><dt>:options 
                  <dd>
                  <p>An options SQL string to use, which should contain comma separated options.</p>
                  </dd><dt>:server 
                  <dd>
                  <p>The server on which to run the query.</p>
                  </dd></dl>
                  
                  <p>If a block is provided, the method continually yields to the block, one
                  yield per row.  If a block is not provided, a single string is returned
                  with all of the data.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-copy_table-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-copy_table-source'><span class="ruby-comment"># File lib/sequel/adapters/postgres.rb, line 335</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">copy_table</span>(<span class="ruby-identifier">table</span>, <span class="ruby-identifier">opts</span>=<span class="ruby-constant">OPTS</span>)&#x000A;  <span class="ruby-identifier">synchronize</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:server</span>]) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">conn</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">execute</span>(<span class="ruby-identifier">copy_table_sql</span>(<span class="ruby-identifier">table</span>, <span class="ruby-identifier">opts</span>))&#x000A;    <span class="ruby-keyword">begin</span>&#x000A;      <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>&#x000A;        <span class="ruby-keyword">while</span> <span class="ruby-identifier">buf</span> = <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">get_copy_data</span>&#x000A;          <span class="ruby-keyword">yield</span> <span class="ruby-identifier">buf</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;        <span class="ruby-keyword">nil</span>&#x000A;      <span class="ruby-keyword">else</span>&#x000A;        <span class="ruby-identifier">b</span> = <span class="ruby-string">''</span>&#x000A;        <span class="ruby-identifier">b</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">buf</span> <span class="ruby-keyword">while</span> <span class="ruby-identifier">buf</span> = <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">get_copy_data</span>&#x000A;        <span class="ruby-identifier">b</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">ensure</span>&#x000A;      <span class="ruby-identifier">raise</span> <span class="ruby-constant">DatabaseDisconnectError</span>, <span class="ruby-string">&quot;disconnecting as a partial COPY may leave the connection in an unusable state&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">buf</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span> &#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method public-instance' id='method-method-i-disconnect_connection'>
                <a name='method-i-disconnect_connection'></a>
                <div class='synopsis'>
                  <span class='name'>disconnect_connection</span>
                  <span class='arguments'>(conn)</span>
                </div>
                <div class='description'>
                  
                  <p>Disconnect given connection</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-disconnect_connection-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-disconnect_connection-source'><span class="ruby-comment"># File lib/sequel/adapters/postgres.rb, line 273</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">disconnect_connection</span>(<span class="ruby-identifier">conn</span>)&#x000A;  <span class="ruby-keyword">begin</span>&#x000A;    <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">finish</span>&#x000A;  <span class="ruby-keyword">rescue</span> <span class="ruby-constant">PGError</span>, <span class="ruby-constant">IOError</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method public-instance' id='method-method-i-error_info'>
                <a name='method-i-error_info'></a>
                <div class='synopsis'>
                  <span class='name'>error_info</span>
                  <span class='arguments'>(e)</span>
                </div>
                <div class='description'>
                  
                  <p>Return a hash of information about the related PGError (or
                  Sequel::DatabaseError that wraps a PGError), with the following entries:</p>
                  <dl class="rdoc-list note-list"><dt>:schema 
                  <dd>
                  <p>The schema name related to the error</p>
                  </dd><dt>:table 
                  <dd>
                  <p>The table name related to the error</p>
                  </dd><dt>:column 
                  <dd>
                  <p>the column name related to the error</p>
                  </dd><dt>:constraint 
                  <dd>
                  <p>The constraint name related to the error</p>
                  </dd><dt>:type 
                  <dd>
                  <p>The datatype name related to the error</p>
                  </dd></dl>
                  
                  <p>This requires a PostgreSQL 9.3+ server and 9.3+ client library, and ruby-pg
                  0.16.0+ to be supported.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-error_info-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-error_info-source'><span class="ruby-comment"># File lib/sequel/adapters/postgres.rb, line 292</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">error_info</span>(<span class="ruby-identifier">e</span>)&#x000A;  <span class="ruby-identifier">e</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">wrapped_exception</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">DatabaseError</span>)&#x000A;  <span class="ruby-identifier">r</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">result</span>&#x000A;  <span class="ruby-identifier">h</span> = {}&#x000A;  <span class="ruby-identifier">h</span>[<span class="ruby-value">:schema</span>] = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">error_field</span>(<span class="ruby-operator">::</span><span class="ruby-constant">PG</span><span class="ruby-operator">::</span><span class="ruby-constant">PG_DIAG_SCHEMA_NAME</span>)&#x000A;  <span class="ruby-identifier">h</span>[<span class="ruby-value">:table</span>] = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">error_field</span>(<span class="ruby-operator">::</span><span class="ruby-constant">PG</span><span class="ruby-operator">::</span><span class="ruby-constant">PG_DIAG_TABLE_NAME</span>)&#x000A;  <span class="ruby-identifier">h</span>[<span class="ruby-value">:column</span>] = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">error_field</span>(<span class="ruby-operator">::</span><span class="ruby-constant">PG</span><span class="ruby-operator">::</span><span class="ruby-constant">PG_DIAG_COLUMN_NAME</span>)&#x000A;  <span class="ruby-identifier">h</span>[<span class="ruby-value">:constraint</span>] = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">error_field</span>(<span class="ruby-operator">::</span><span class="ruby-constant">PG</span><span class="ruby-operator">::</span><span class="ruby-constant">PG_DIAG_CONSTRAINT_NAME</span>)&#x000A;  <span class="ruby-identifier">h</span>[<span class="ruby-value">:type</span>] = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">error_field</span>(<span class="ruby-operator">::</span><span class="ruby-constant">PG</span><span class="ruby-operator">::</span><span class="ruby-constant">PG_DIAG_DATATYPE_NAME</span>)&#x000A;  <span class="ruby-identifier">h</span>&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method public-instance' id='method-method-i-execute'>
                <a name='method-i-execute'></a>
                <div class='synopsis'>
                  <span class='name'>execute</span>
                  <span class='arguments'>(sql, opts=OPTS, &block)</span>
                </div>
                <div class='description'>
                  
                  <p>Execute the given SQL with the given args on an available connection.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-execute-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-execute-source'><span class="ruby-comment"># File lib/sequel/adapters/postgres.rb, line 306</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">execute</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">opts</span>=<span class="ruby-constant">OPTS</span>, &amp;<span class="ruby-identifier">block</span>)&#x000A;  <span class="ruby-identifier">synchronize</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:server</span>]){<span class="ruby-operator">|</span><span class="ruby-identifier">conn</span><span class="ruby-operator">|</span> <span class="ruby-identifier">check_database_errors</span>{<span class="ruby-identifier">_execute</span>(<span class="ruby-identifier">conn</span>, <span class="ruby-identifier">sql</span>, <span class="ruby-identifier">opts</span>, &amp;<span class="ruby-identifier">block</span>)}}&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method public-instance' id='method-method-i-listen'>
                <a name='method-i-listen'></a>
                <div class='synopsis'>
                  <span class='name'>listen</span>
                  <span class='arguments'>(channels, opts=OPTS, &block)</span>
                </div>
                <div class='description'>
                  
                  <p>Listens on the given channel (or multiple channels if channel is an array),
                  waiting for notifications. After a notification is received, or the timeout
                  has passed, stops listening to the channel. Options:</p>
                  <dl class="rdoc-list note-list"><dt>:after_listen 
                  <dd>
                  <p>An object that responds to <code>call</code> that is called with the
                  underlying connection after the LISTEN statement is sent, but before the
                  connection starts waiting for notifications.</p>
                  </dd><dt>:loop 
                  <dd>
                  <p>Whether to continually wait for notifications, instead of just waiting for
                  a single notification. If this option is given, a block must be provided. 
                  If this object responds to call, it is called with the underlying
                  connection after each notification is received (after the block is called).
                  If a :timeout option is used, and a callable object is given, the object
                  will also be called if the timeout expires.  If :loop is used and you want
                  to stop listening, you can either break from inside the block given to <a
                  href="Database.html#method-i-listen">listen</a>, or you can throw :stop
                  from inside the :loop object’s call method or the block.</p>
                  </dd><dt>:server 
                  <dd>
                  <p>The server on which to listen, if the sharding support is being used.</p>
                  </dd><dt>:timeout 
                  <dd>
                  <p>How long to wait for a notification, in seconds (can provide a float value
                  for fractional seconds).  If not given or nil, waits indefinitely.</p>
                  </dd></dl>
                  
                  <p>This method is only supported if pg is used as the underlying ruby driver. 
                  It returns the channel the notification was sent to (as a string), unless
                  :loop was used, in which case it returns nil. If a block is given, it is
                  yielded 3 arguments:</p>
                  <ul><li>
                  <p>the channel the notification was sent to (as a string)</p>
                  </li><li>
                  <p>the backend pid of the notifier (as an integer),</p>
                  </li><li>
                  <p>and the payload of the notification (as a string or nil).</p>
                  </li></ul>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-listen-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-listen-source'><span class="ruby-comment"># File lib/sequel/adapters/postgres.rb, line 428</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">listen</span>(<span class="ruby-identifier">channels</span>, <span class="ruby-identifier">opts</span>=<span class="ruby-constant">OPTS</span>, &amp;<span class="ruby-identifier">block</span>)&#x000A;  <span class="ruby-identifier">check_database_errors</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">synchronize</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:server</span>]) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">conn</span><span class="ruby-operator">|</span>&#x000A;      <span class="ruby-keyword">begin</span>&#x000A;        <span class="ruby-identifier">channels</span> = <span class="ruby-constant">Array</span>(<span class="ruby-identifier">channels</span>)&#x000A;        <span class="ruby-identifier">channels</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">channel</span><span class="ruby-operator">|</span>&#x000A;          <span class="ruby-identifier">sql</span> = <span class="ruby-string">&quot;LISTEN &quot;</span>&#x000A;          <span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">send</span>(<span class="ruby-value">:identifier_append</span>, <span class="ruby-identifier">sql</span>, <span class="ruby-identifier">channel</span>)&#x000A;          <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">execute</span>(<span class="ruby-identifier">sql</span>)&#x000A;        <span class="ruby-keyword">end</span>&#x000A;        <span class="ruby-identifier">opts</span>[<span class="ruby-value">:after_listen</span>].<span class="ruby-identifier">call</span>(<span class="ruby-identifier">conn</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:after_listen</span>]&#x000A;        <span class="ruby-identifier">timeout</span> = <span class="ruby-identifier">opts</span>[<span class="ruby-value">:timeout</span>] <span class="ruby-operator">?</span> [<span class="ruby-identifier">opts</span>[<span class="ruby-value">:timeout</span>]] <span class="ruby-operator">:</span> []&#x000A;        <span class="ruby-keyword">if</span> <span class="ruby-identifier">l</span> = <span class="ruby-identifier">opts</span>[<span class="ruby-value">:loop</span>]&#x000A;          <span class="ruby-identifier">raise</span> <span class="ruby-constant">Error</span>, <span class="ruby-string">'calling #listen with :loop requires a block'</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block</span>&#x000A;          <span class="ruby-identifier">loop_call</span> = <span class="ruby-identifier">l</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:call</span>)&#x000A;          <span class="ruby-identifier">catch</span>(<span class="ruby-value">:stop</span>) <span class="ruby-keyword">do</span>&#x000A;            <span class="ruby-identifier">loop</span> <span class="ruby-keyword">do</span>&#x000A;              <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">wait_for_notify</span>(*<span class="ruby-identifier">timeout</span>, &amp;<span class="ruby-identifier">block</span>)&#x000A;              <span class="ruby-identifier">l</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">conn</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">loop_call</span>&#x000A;            <span class="ruby-keyword">end</span>&#x000A;          <span class="ruby-keyword">end</span>&#x000A;          <span class="ruby-keyword">nil</span>&#x000A;        <span class="ruby-keyword">else</span>&#x000A;          <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">wait_for_notify</span>(*<span class="ruby-identifier">timeout</span>, &amp;<span class="ruby-identifier">block</span>)&#x000A;        <span class="ruby-keyword">end</span>&#x000A;      <span class="ruby-keyword">ensure</span>&#x000A;        <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">execute</span>(<span class="ruby-string">&quot;UNLISTEN *&quot;</span>)&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method public-instance' id='method-method-i-to_application_timestamp'>
                <a name='method-i-to_application_timestamp'></a>
                <div class='synopsis'>
                  <span class='name'>to_application_timestamp</span>
                  <span class='arguments'>(value)</span>
                </div>
                <div class='description'>
                  
                  <p>If <a
                  href="Database.html#attribute-i-convert_infinite_timestamps">#convert_infinite_timestamps</a>
                  is true and the value is infinite, return an appropriate value based on the
                  <a
                  href="Database.html#attribute-i-convert_infinite_timestamps">#convert_infinite_timestamps</a>
                  setting.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-to_application_timestamp-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-to_application_timestamp-source'><span class="ruby-comment"># File lib/sequel/adapters/postgres.rb, line 463</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_application_timestamp</span>(<span class="ruby-identifier">value</span>)&#x000A;  <span class="ruby-keyword">if</span> <span class="ruby-identifier">convert_infinite_timestamps</span>&#x000A;    <span class="ruby-keyword">case</span> <span class="ruby-identifier">value</span>&#x000A;    <span class="ruby-keyword">when</span> *<span class="ruby-constant">INFINITE_TIMESTAMP_STRINGS</span>&#x000A;      <span class="ruby-identifier">infinite_timestamp_value</span>(<span class="ruby-identifier">value</span>)&#x000A;    <span class="ruby-keyword">else</span>&#x000A;      <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">else</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
