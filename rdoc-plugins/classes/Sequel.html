<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>Sequel</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='class' id='wrapper'>
      <div class='header'>
        <h1 class='name'>
          <span class='type'>module</span>
          Sequel
        </h1>
        <ol class='paths'>
          <li>
            <a target="docwin" href="../files/lib/sequel/extensions/_pretty_table_rb.html">lib/sequel/extensions/_pretty_table.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/arbitrary_servers_rb.html">lib/sequel/extensions/arbitrary_servers.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/columns_introspection_rb.html">lib/sequel/extensions/columns_introspection.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/connection_validator_rb.html">lib/sequel/extensions/connection_validator.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/constraint_validations_rb.html">lib/sequel/extensions/constraint_validations.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/date_arithmetic_rb.html">lib/sequel/extensions/date_arithmetic.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/empty_array_ignore_nulls_rb.html">lib/sequel/extensions/empty_array_ignore_nulls.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/error_sql_rb.html">lib/sequel/extensions/error_sql.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/eval_inspect_rb.html">lib/sequel/extensions/eval_inspect.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/filter_having_rb.html">lib/sequel/extensions/filter_having.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/from_block_rb.html">lib/sequel/extensions/from_block.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/graph_each_rb.html">lib/sequel/extensions/graph_each.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/hash_aliases_rb.html">lib/sequel/extensions/hash_aliases.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/looser_typecasting_rb.html">lib/sequel/extensions/looser_typecasting.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/meta_def_rb.html">lib/sequel/extensions/meta_def.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/migration_rb.html">lib/sequel/extensions/migration.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/mssql_emulate_lateral_with_apply_rb.html">lib/sequel/extensions/mssql_emulate_lateral_with_apply.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/named_timezones_rb.html">lib/sequel/extensions/named_timezones.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/null_dataset_rb.html">lib/sequel/extensions/null_dataset.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/pagination_rb.html">lib/sequel/extensions/pagination.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/pg_array_rb.html">lib/sequel/extensions/pg_array.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/pg_array_ops_rb.html">lib/sequel/extensions/pg_array_ops.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/pg_hstore_rb.html">lib/sequel/extensions/pg_hstore.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/pg_hstore_ops_rb.html">lib/sequel/extensions/pg_hstore_ops.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/pg_inet_rb.html">lib/sequel/extensions/pg_inet.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/pg_interval_rb.html">lib/sequel/extensions/pg_interval.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/pg_json_rb.html">lib/sequel/extensions/pg_json.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/pg_json_ops_rb.html">lib/sequel/extensions/pg_json_ops.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/pg_loose_count_rb.html">lib/sequel/extensions/pg_loose_count.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/pg_range_rb.html">lib/sequel/extensions/pg_range.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/pg_range_ops_rb.html">lib/sequel/extensions/pg_range_ops.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/pg_row_rb.html">lib/sequel/extensions/pg_row.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/pg_row_ops_rb.html">lib/sequel/extensions/pg_row_ops.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/pg_static_cache_updater_rb.html">lib/sequel/extensions/pg_static_cache_updater.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/pretty_table_rb.html">lib/sequel/extensions/pretty_table.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/query_rb.html">lib/sequel/extensions/query.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/query_literals_rb.html">lib/sequel/extensions/query_literals.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/schema_caching_rb.html">lib/sequel/extensions/schema_caching.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/schema_dumper_rb.html">lib/sequel/extensions/schema_dumper.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/select_remove_rb.html">lib/sequel/extensions/select_remove.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/sequel_3_dataset_methods_rb.html">lib/sequel/extensions/sequel_3_dataset_methods.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/server_block_rb.html">lib/sequel/extensions/server_block.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/set_overrides_rb.html">lib/sequel/extensions/set_overrides.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/split_array_nil_rb.html">lib/sequel/extensions/split_array_nil.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/thread_local_timezones_rb.html">lib/sequel/extensions/thread_local_timezones.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/extensions/to_dot_rb.html">lib/sequel/extensions/to_dot.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/active_model_rb.html">lib/sequel/plugins/active_model.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/after_initialize_rb.html">lib/sequel/plugins/after_initialize.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/association_autoreloading_rb.html">lib/sequel/plugins/association_autoreloading.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/association_dependencies_rb.html">lib/sequel/plugins/association_dependencies.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/association_pks_rb.html">lib/sequel/plugins/association_pks.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/association_proxies_rb.html">lib/sequel/plugins/association_proxies.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/auto_validations_rb.html">lib/sequel/plugins/auto_validations.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/blacklist_security_rb.html">lib/sequel/plugins/blacklist_security.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/boolean_readers_rb.html">lib/sequel/plugins/boolean_readers.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/caching_rb.html">lib/sequel/plugins/caching.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/class_table_inheritance_rb.html">lib/sequel/plugins/class_table_inheritance.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/composition_rb.html">lib/sequel/plugins/composition.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/constraint_validations_rb.html">lib/sequel/plugins/constraint_validations.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/dataset_associations_rb.html">lib/sequel/plugins/dataset_associations.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/defaults_setter_rb.html">lib/sequel/plugins/defaults_setter.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/dirty_rb.html">lib/sequel/plugins/dirty.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/eager_each_rb.html">lib/sequel/plugins/eager_each.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/error_splitter_rb.html">lib/sequel/plugins/error_splitter.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/force_encoding_rb.html">lib/sequel/plugins/force_encoding.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/hook_class_methods_rb.html">lib/sequel/plugins/hook_class_methods.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/input_transformer_rb.html">lib/sequel/plugins/input_transformer.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/instance_filters_rb.html">lib/sequel/plugins/instance_filters.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/instance_hooks_rb.html">lib/sequel/plugins/instance_hooks.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/json_serializer_rb.html">lib/sequel/plugins/json_serializer.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/lazy_attributes_rb.html">lib/sequel/plugins/lazy_attributes.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/list_rb.html">lib/sequel/plugins/list.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/many_through_many_rb.html">lib/sequel/plugins/many_through_many.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/many_to_one_pk_lookup_rb.html">lib/sequel/plugins/many_to_one_pk_lookup.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/mssql_optimistic_locking_rb.html">lib/sequel/plugins/mssql_optimistic_locking.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/nested_attributes_rb.html">lib/sequel/plugins/nested_attributes.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/optimistic_locking_rb.html">lib/sequel/plugins/optimistic_locking.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/pg_array_associations_rb.html">lib/sequel/plugins/pg_array_associations.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/pg_row_rb.html">lib/sequel/plugins/pg_row.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/pg_typecast_on_load_rb.html">lib/sequel/plugins/pg_typecast_on_load.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/prepared_statements_rb.html">lib/sequel/plugins/prepared_statements.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/prepared_statements_associations_rb.html">lib/sequel/plugins/prepared_statements_associations.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/prepared_statements_safe_rb.html">lib/sequel/plugins/prepared_statements_safe.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/prepared_statements_with_pk_rb.html">lib/sequel/plugins/prepared_statements_with_pk.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/rcte_tree_rb.html">lib/sequel/plugins/rcte_tree.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/schema_rb.html">lib/sequel/plugins/schema.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/scissors_rb.html">lib/sequel/plugins/scissors.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/serialization_rb.html">lib/sequel/plugins/serialization.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/serialization_modification_detection_rb.html">lib/sequel/plugins/serialization_modification_detection.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/sharding_rb.html">lib/sequel/plugins/sharding.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/single_table_inheritance_rb.html">lib/sequel/plugins/single_table_inheritance.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/skip_create_refresh_rb.html">lib/sequel/plugins/skip_create_refresh.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/static_cache_rb.html">lib/sequel/plugins/static_cache.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/string_stripper_rb.html">lib/sequel/plugins/string_stripper.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/subclasses_rb.html">lib/sequel/plugins/subclasses.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/table_select_rb.html">lib/sequel/plugins/table_select.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/tactical_eager_loading_rb.html">lib/sequel/plugins/tactical_eager_loading.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/timestamps_rb.html">lib/sequel/plugins/timestamps.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/touch_rb.html">lib/sequel/plugins/touch.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/tree_rb.html">lib/sequel/plugins/tree.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/typecast_on_load_rb.html">lib/sequel/plugins/typecast_on_load.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/unlimited_update_rb.html">lib/sequel/plugins/unlimited_update.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/update_primary_key_rb.html">lib/sequel/plugins/update_primary_key.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/validation_class_methods_rb.html">lib/sequel/plugins/validation_class_methods.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/validation_helpers_rb.html">lib/sequel/plugins/validation_helpers.rb</a>
          </li>
          <li class='other'>
            <a target="docwin" href="../files/lib/sequel/plugins/xml_serializer_rb.html">lib/sequel/plugins/xml_serializer.rb</a>
          </li>
          <li>
            <a class='show' href='#' onclick='this.parentNode.parentNode.className += " expanded"; this.parentNode.removeChild(this); return false'>show all</a>
          </li>
        </ol>
        <div class='parent'>
          Parent:
          <strong><a target="docwin" href="../files/lib/sequel/plugins/xml_serializer_rb.html">xml_serializer.rb</a></strong>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <p>This _pretty_table extension is only for internal use. It adds the <a
            href="Sequel/PrettyTable.html">Sequel::PrettyTable</a> class without
            modifying  <a href="Sequel/Dataset.html">Sequel::Dataset</a>.</p>
            
            <p>To load the extension:</p>
            
            <pre>Sequel.extension :_pretty_table</pre>
            
            <p>The arbitrary_servers extension allows you to connect to arbitrary
            servers/shards that were not defined when you created the database. To use
            it, you first load the extension into the <a
            href="Sequel/Database.html">Database</a> object:</p>
            
            <pre>DB.extension :arbitrary_servers</pre>
            
            <p>Then you can pass arbitrary connection options for the server/shard to use
            as a hash:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">server</span>(:<span class="ruby-identifier">host=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'...'</span>, :<span class="ruby-identifier">database=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'...'</span>).<span class="ruby-identifier">all</span></pre>
            
            <p>Because <a href="Sequel.html">Sequel</a> can never be sure that the
            connection will be reused, arbitrary connections are disconnected as soon
            as the outermost block that uses them exits.  So this example uses the same
            connection:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">transaction</span>(:<span class="ruby-identifier">server=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">host=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'...'</span>, :<span class="ruby-identifier">database=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'...'</span>}) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-constant">DB</span>.<span class="ruby-identifier">transaction</span>(:<span class="ruby-identifier">server=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">host=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'...'</span>, :<span class="ruby-identifier">database=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'...'</span>}) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">c2</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-comment"># c == c2</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>But this example does not:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">transaction</span>(:<span class="ruby-identifier">server=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">host=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'...'</span>, :<span class="ruby-identifier">database=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'...'</span>}) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-constant">DB</span>.<span class="ruby-identifier">transaction</span>(:<span class="ruby-identifier">server=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">host=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'...'</span>, :<span class="ruby-identifier">database=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'...'</span>}) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">c2</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-comment"># c != c2</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>You can use this extension in conjunction with the server_block extension:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">with_server</span>(:<span class="ruby-identifier">host=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'...'</span>, :<span class="ruby-identifier">database=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'...'</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-constant">DB</span>.<span class="ruby-identifier">synchronize</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-comment"># All of these use the host/database given to with_server</span>&#x000A;    <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">insert</span>(<span class="ruby-operator">...</span>)&#x000A;    <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">update</span>(<span class="ruby-operator">...</span>)&#x000A;    <span class="ruby-constant">DB</span>.<span class="ruby-identifier">tables</span>&#x000A;    <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">all</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Anyone using this extension in conjunction with the server_block extension
            may want to do the following to so that you don’t need to call synchronize
            separately:</p>
            
            <pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-constant">DB</span>.<span class="ruby-identifier">with_server</span>(*)&#x000A;  <span class="ruby-keyword">super</span>{<span class="ruby-identifier">synchronize</span>{<span class="ruby-keyword">yield</span>}}&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Note that this extension only works with the sharded threaded connection
            pool.  If you are using the sharded single connection pool, you need to
            switch to the sharded threaded connection pool before using this extension.</p>
            
            <p>The columns_introspection extension attempts to introspect the selected
            columns for a dataset before issuing a query.  If it thinks it can guess
            correctly at the columns the query will use, it will return the columns
            without issuing a database query.</p>
            
            <p>This method is not fool-proof, it’s possible that some databases will use
            column names that <a href="Sequel.html">Sequel</a> does not expect.  Also,
            it may not correctly handle all cases.</p>
            
            <p>To attempt to introspect columns for a single dataset:</p>
            
            <pre>ds = ds.extension(:columns_introspection)</pre>
            
            <p>To attempt to introspect columns for all datasets on a single database:</p>
            
            <pre>DB.extension(:columns_introspection)</pre>
            
            <p>The connection_validator extension modifies a database’s connection pool to
            validate that connections checked out from the pool are still valid, before
            yielding them for use.  If it detects an invalid connection, it removes it
            from the pool and tries the next available connection, creating a new
            connection if no available connection is valid.  Example of use:</p>
            
            <pre>DB.extension(:connection_validator)</pre>
            
            <p>As checking connections for validity involves issuing a query, which is
            potentially an expensive operation, the validation checks are only run if
            the connection has been idle for longer than a certain threshold. By
            default, that threshold is 3600 seconds (1 hour), but it can be modified by
            the user, set to -1 to always validate connections on checkout:</p>
            
            <pre>DB.pool.connection_validation_timeout = -1</pre>
            
            <p>Note that if you set the timeout to validate connections on every checkout,
            you should probably manually control connection checkouts on a coarse
            basis, using Database#synchronize.  In a web application, the optimal place
            for that would be a rack middleware.  Validating connections on every
            checkout without setting up coarse connection checkouts will hurt
            performance, in some cases significantly.  Note that setting up coarse
            connection checkouts reduces the concurrency level acheivable.  For
            example, in a web application, using Database#synchronize in a rack
            middleware will limit the number of concurrent web requests to the number
            to connections in the database connection pool.</p>
            
            <p>Note that this extension only affects the default threaded and the sharded
            threaded connection pool.  The single threaded and sharded single threaded
            connection pools are not affected.  As the only reason to use the single
            threaded pools is for speed, and this extension makes the connection pool
            slower, there’s not much point in modifying this extension to work with the
            single threaded pools.  The threaded pools work fine even in single
            threaded code, so if you are currently using a single threaded pool and
            want to use this extension, switch to using a threaded pool.</p>
            
            <p>The constraint_validations extension is designed to easily create database
            constraints inside create_table and alter_table blocks.  It also adds
            relevant metadata about the constraints to a separate table, which the
            constraint_validations model plugin uses to setup automatic validations.</p>
            
            <p>To use this extension, you first need to load it into the database:</p>
            
            <pre>DB.extension(:constraint_validations)</pre>
            
            <p>Note that you should only need to do this when modifying the constraint
            validations (i.e. when migrating).  You should probably not load this
            extension in general application code.</p>
            
            <p>You also need to make sure to add the metadata table for the automatic
            validations.  By default, this table is called
            sequel_constraint_validations.</p>
            
            <pre>DB.create_constraint_validations_table</pre>
            
            <p>This table should only be created once.  For new applications, you
            generally want to create it first, before creating any other application
            tables.</p>
            
            <p>Because migrations instance_eval the up and down blocks on a database,
            using this extension in a migration can be done via:</p>
            
            <pre>Sequel.migration do&#x000A;  up do&#x000A;    extension(:constraint_validations)&#x000A;    # ...&#x000A;  end&#x000A;  down do&#x000A;    extension(:constraint_validations)&#x000A;    # ...&#x000A;  end&#x000A;end</pre>
            
            <p>However, note that you cannot use change migrations with this extension,
            you need to use separate up/down migrations.</p>
            
            <p>The API for creating the constraints with automatic validations is similar
            to the validation_helpers model plugin API.  However, instead of having
            separate validates_* methods, it just adds a validate method that accepts a
            block to the schema generators.  Like the create_table and alter_table
            blocks, this block is instance_evaled and offers its own DSL. Example:</p>
            
            <pre>DB.create_table(:table) do&#x000A;  Integer :id&#x000A;  String :name&#x000A;  validate do&#x000A;    presence :id&#x000A;    min_length 5, :name&#x000A;  end&#x000A;end</pre>
            
            <p>instance_eval is used in this case because create_table and alter_table
            already use instance_eval, so losing access to the surrounding receiver is
            not an issue.</p>
            
            <p>Here’s a breakdown of the constraints created for each constraint
            validation method:</p>
            <dl class="rdoc-list note-list"><dt>All constraints except unique unless :allow_nil is true 
            <dd>
            <p>CHECK column IS NOT NULL</p>
            </dd><dt>presence (<a href="String.html">String</a> column) 
            <dd>
            <p>CHECK trim(column) != ”</p>
            </dd><dt>exact_length 5 
            <dd>
            <p>CHECK char_length(column) = 5</p>
            </dd><dt>min_length 5 
            <dd>
            <p>CHECK char_length(column) &gt;= 5</p>
            </dd><dt>max_length 5 
            <dd>
            <p>CHECK char_length(column) &lt;= 5</p>
            </dd><dt>length_range 3..5 
            <dd>
            <p>CHECK char_length(column) &gt;= 3 AND char_length(column) &lt;= 5</p>
            </dd><dt>length_range 3…5 
            <dd>
            <p>CHECK char_length(column) &gt;= 3 AND char_length(column) &lt; 5</p>
            </dd><dt>format /foo\d+/ 
            <dd>
            <p>CHECK column ~ ‘foo\d+’</p>
            </dd><dt>format /foo\d+/i 
            <dd>
            <p>CHECK column ~* ‘foo\d+’</p>
            </dd><dt>like ‘foo%’ 
            <dd>
            <p>CHECK column LIKE ‘foo%’</p>
            </dd><dt>ilike ‘foo%’ 
            <dd>
            <p>CHECK column ILIKE ‘foo%’</p>
            </dd><dt>includes [‘a’, ‘b’] 
            <dd>
            <p>CHECK column IN (‘a’, ‘b’)</p>
            </dd><dt>includes [1, 2] 
            <dd>
            <p>CHECK column IN (1, 2)</p>
            </dd><dt>includes 3..5 
            <dd>
            <p>CHECK column &gt;= 3 AND column &lt;= 5</p>
            </dd><dt>includes 3…5 
            <dd>
            <p>CHECK column &gt;= 3 AND column &lt; 5</p>
            </dd><dt>unique 
            <dd>
            <p>UNIQUE (column)</p>
            </dd></dl>
            
            <p>There are some additional API differences:</p>
            <ul><li>
            <p>Only the :message and :allow_nil options are respected.  The :allow_blank
            and :allow_missing options are not respected.</p>
            </li><li>
            <p>A new option, :name, is respected, for providing the name of the
            constraint.  It is highly recommended that you provide a name for all
            constraint validations, as otherwise, it is difficult to drop the
            constraints later.</p>
            </li><li>
            <p>The includes validation only supports an array of strings, and array of
            integers, and a range of integers.</p>
            </li><li>
            <p>There are like and ilike validations, which are similar to the format
            validation but use a case sensitive or case insensitive LIKE pattern. LIKE
            patters are very simple, so many regexp patterns cannot be expressed by
            them, but only a couple databases (PostgreSQL and MySQL) support regexp
            patterns.</p>
            </li><li>
            <p>When using the unique validation, column names cannot have embedded commas.
            For similar reasons, when using an includes validation with an array of
            strings, none of the strings in the array can have embedded commas.</p>
            </li><li>
            <p>The unique validation does not support an arbitrary number of columns. For
            a single column, just the symbol should be used, and for an array of
            columns, an array of symbols should be used.  There is no support for
            creating two separate unique validations for separate columns in a single
            call.</p>
            </li><li>
            <p>A drop method can be called with a constraint name in a alter_table
            validate block to drop an existing constraint and the related validation
            metadata.</p>
            </li><li>
            <p>While it is allowed to create a presence constraint with :allow_nil set to
            true, doing so does not create a constraint unless the column has <a
            href="String.html">String</a> type.</p>
            </li></ul>
            
            <p>Note that this extension has the following issues on certain databases:</p>
            <ul><li>
            <p>MySQL does not support check constraints (they are parsed but ignored), so
            using this extension does not actually set up constraints on MySQL, except
            for the unique constraint.  It can still be used on MySQL to add the
            validation metadata so that the plugin can setup automatic validations.</p>
            </li><li>
            <p>On SQLite, adding constraints to a table is not supported, so it must be
            emulated by dropping the table and recreating it with the constraints. If
            you want to use this plugin on SQLite with an alter_table block, you should
            drop all constraint validation metadata using
            <code>drop_constraint_validations_for(:table=&gt;'table')</code>, and then
            readd all constraints you want to use inside the alter table block, making
            no other changes inside the alter_table block.</p>
            </li></ul>
            
            <p>The date_arithmetic extension adds the ability to perform
            database-independent addition/substraction of intervals to/from dates and
            timestamps.</p>
            
            <p>First, you need to load the extension into the database:</p>
            
            <pre>DB.extension :date_arithmetic</pre>
            
            <p>Then you can use the Sequel.date_add and Sequel.date_sub methods to return
            <a href="Sequel.html">Sequel</a> expressions:</p>
            
            <pre class="ruby"><span class="ruby-identifier">add</span> = <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">date_add</span>(:<span class="ruby-identifier">date_column</span>, :<span class="ruby-identifier">years=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>, :<span class="ruby-identifier">months=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">2</span>, :<span class="ruby-identifier">days=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">3</span>)&#x000A;<span class="ruby-identifier">sub</span> = <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">date_sub</span>(:<span class="ruby-identifier">date_column</span>, :<span class="ruby-identifier">hours=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>, :<span class="ruby-identifier">minutes=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">2</span>, :<span class="ruby-identifier">seconds=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">3</span>)</pre>
            
            <p>In addition to specifying the interval as a hash, there is also support for
            specifying the interval as an ActiveSupport::Duration object:</p>
            
            <pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">'active_support/all'</span>&#x000A;<span class="ruby-identifier">add</span> = <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">date_add</span>(:<span class="ruby-identifier">date_column</span>, <span class="ruby-value">1</span>.<span class="ruby-identifier">years</span> <span class="ruby-operator">+</span> <span class="ruby-value">2</span>.<span class="ruby-identifier">months</span> <span class="ruby-operator">+</span> <span class="ruby-value">3</span>.<span class="ruby-identifier">days</span>)&#x000A;<span class="ruby-identifier">sub</span> = <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">date_sub</span>(:<span class="ruby-identifier">date_column</span>, <span class="ruby-value">1</span>.<span class="ruby-identifier">hours</span> <span class="ruby-operator">+</span> <span class="ruby-value">2</span>.<span class="ruby-identifier">minutes</span> <span class="ruby-operator">+</span> <span class="ruby-value">3</span>.<span class="ruby-identifier">seconds</span>)</pre>
            
            <p>These expressions can be used in your datasets, or anywhere else that <a
            href="Sequel.html">Sequel</a> expressions are allowed:</p>
            
            <pre>DB[:table].select(add.as(:d)).where(sub &gt; Sequel::CURRENT_TIMESTAMP)</pre>
            
            <p>This changes Sequel’s literalization of IN/NOT IN with an empty array value
            to not return NULL even if one of the referenced columns is NULL:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">test</span>].<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span>[])&#x000A;<span class="ruby-comment"># SELECT * FROM test WHERE (1 = 0)</span>&#x000A;<span class="ruby-constant">DB</span>[:<span class="ruby-identifier">test</span>].<span class="ruby-identifier">exclude</span>(:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span>[])&#x000A;<span class="ruby-comment"># SELECT * FROM test WHERE (1 = 1)</span></pre>
            
            <p>The default <a href="Sequel.html">Sequel</a> behavior is to respect NULLs,
            so that when name is NULL, the expression returns NULL.</p>
            
            <p>You can load this extension into specific datasets:</p>
            
            <pre>ds = DB[:table]&#x000A;ds = ds.extension(:empty_array_ignore_nulls)</pre>
            
            <p>Or you can load it into all of a database’s datasets, which is probably the
            desired behavior if you are using this extension:</p>
            
            <pre>DB.extension(:empty_array_ignore_nulls)</pre>
            
            <p>The error_sql extension adds a <a
            href="Sequel/DatabaseError.html#method-i-sql">Sequel::DatabaseError#sql</a>
            method that you can use to get the sql that caused the error to be raised.</p>
            
            <pre class="ruby"><span class="ruby-keyword">begin</span>&#x000A;  <span class="ruby-constant">DB</span>.<span class="ruby-identifier">run</span> <span class="ruby-string">&quot;Invalid SQL&quot;</span>&#x000A;<span class="ruby-keyword">rescue</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">e</span>&#x000A;  <span class="ruby-identifier">puts</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">sql</span> <span class="ruby-comment"># &quot;Invalid SQL&quot;</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>On some databases, the error message contains part or all of the <a
            href="Sequel/SQL.html">SQL</a> used, but on other databases, none of the <a
            href="Sequel/SQL.html">SQL</a> used is displayed in the error message, so
            it can be difficult to track down what is causing the error without using a
            logger.  This extension should hopefully make debugging easier on databases
            that have bad error messages.</p>
            
            <p>This extension may not work correctly in the following cases:</p>
            <ul><li>
            <p>log_yield is not used when executing the query.</p>
            </li><li>
            <p>The underlying exception is frozen or reused.</p>
            </li><li>
            <p>The underlying exception doesn’t correctly record instance variables set on
            it (seems to happen on JRuby when underlying exception objects are Java
            exceptions).</p>
            </li></ul>
            
            <p>To load the extension into the database:</p>
            
            <pre>DB.extension :error_sql</pre>
            
            <p>The eval_inspect extension changes inspect for <a
            href="Sequel/SQL/Expression.html">Sequel::SQL::Expression</a> subclasses to
            return a string suitable for ruby’s eval, such that</p>
            
            <pre>eval(obj.inspect) == obj</pre>
            
            <p>is true.  The above code is true for most of ruby’s simple classes such as
            <a href="String.html">String</a>, Integer, Float, and <a
            href="Symbol.html">Symbol</a>, but it’s not true for classes such as Time,
            Date, and BigDecimal.  <a href="Sequel.html">Sequel</a> attempts to handle
            situations where instances of these classes are a component of a <a
            href="Sequel.html">Sequel</a> expression.</p>
            
            <p>To load the extension:</p>
            
            <pre>Sequel.extension :eval_inspect</pre>
            
            <p>The filter_having extension allows Dataset#filter, and, or and exclude to
            operate on the HAVING clause if the dataset already has a HAVING clause,
            which was the historical behavior before <a href="Sequel.html">Sequel</a>
            4.  It is only recommended to use this for backwards compatibility.</p>
            
            <p>You can load this extension into specific datasets:</p>
            
            <pre>ds = DB[:table]&#x000A;ds = ds.extension(:filter_having)</pre>
            
            <p>Or you can load it into all of a database’s datasets, which is probably the
            desired behavior if you are using this extension:</p>
            
            <pre>DB.extension(:filter_having)</pre>
            
            <p>The from_block extension changes Database#from so that blocks given to it
            are treated as virtual rows applying to the FROM clause, instead of virtual
            rows applying to the WHERE clause.  This will probably be made the default
            in the next major version of <a href="Sequel.html">Sequel</a>.</p>
            
            <p>This makes it easier to use table returning functions:</p>
            
            <pre>DB.from{table_function(1)}&#x000A;# SELECT * FROM table_function(1)</pre>
            
            <p>To load the extension into the database:</p>
            
            <pre>DB.extension :from_block</pre>
            
            <p>The graph_each extension adds Dataset#graph_each and makes Dataset#each
            call graph_each if the dataset has been graphed. Dataset#graph_each splits
            result hashes into subhashes per table:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">a</span>].<span class="ruby-identifier">graph</span>(:<span class="ruby-identifier">b</span>, :<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">b_id</span>).<span class="ruby-identifier">all</span>&#x000A;<span class="ruby-comment"># =&gt; {:a=&gt;{:id=&gt;1, :b_id=&gt;2}, :b=&gt;{:id=&gt;2}}</span></pre>
            
            <p>You can load this extension into specific datasets:</p>
            
            <pre>ds = DB[:table]&#x000A;ds = ds.extension(:graph_each)</pre>
            
            <p>Or you can load it into all of a database’s datasets, which is probably the
            desired behavior if you are using this extension:</p>
            
            <pre>DB.extension(:graph_each)</pre>
            
            <p>The hash_aliases extension allows Dataset#select and Dataset#from to treat
            a hash argument as an alias specification, with keys being the expressions
            and values being the aliases,  which was the historical behavior before <a
            href="Sequel.html">Sequel</a> 4. It is only recommended to use this for
            backwards compatibility.</p>
            
            <p>You can load this extension into specific datasets:</p>
            
            <pre>ds = DB[:table]&#x000A;ds = ds.extension(:hash_aliases)</pre>
            
            <p>Or you can load it into all of a database’s datasets, which is probably the
            desired behavior if you are using this extension:</p>
            
            <pre>DB.extension(:hash_aliases)</pre>
            
            <p>The <a href="Sequel/LooserTypecasting.html">LooserTypecasting</a> extension
            loosens the default database typecasting for the following types:</p>
            <dl class="rdoc-list note-list"><dt>:float 
            <dd>
            <p>use to_f instead of Float()</p>
            </dd><dt>:integer 
            <dd>
            <p>use to_i instead of Integer()</p>
            </dd><dt>:decimal 
            <dd>
            <p>don’t check string conversion with Float()</p>
            </dd><dt>:string 
            <dd>
            <p>silently allow hash and array conversion to string</p>
            </dd></dl>
            
            <p>To load the extension into the database:</p>
            
            <pre>DB.extension :looser_typecasting</pre>
            
            <p>The meta_def extension is designed for backwards compatibility with older
            <a href="Sequel.html">Sequel</a> code that uses the meta_def method on <a
            href="Sequel/Database.html">Database</a>, <a
            href="Sequel/Dataset.html">Dataset</a>, and <a
            href="Sequel/Model.html">Model</a> classes and/or instances.  It is not
            recommended for usage in new code.  To load this extension:</p>
            
            <pre>Sequel.extension :meta_def</pre>
            
            <p>Adds the <a href="Sequel/Migration.html">Sequel::Migration</a> and <a
            href="Sequel/Migrator.html">Sequel::Migrator</a> classes, which allow the
            user to easily group schema changes and migrate the database to a newer
            version or revert to a previous version.</p>
            
            <p>To load the extension:</p>
            
            <pre>Sequel.extension :migration</pre>
            
            <p>The mssql_emulate_lateral_with_apply extension converts queries that use
            LATERAL into queries that use CROSS/OUTER APPLY, allowing code that works
            on databases that support LATERAL via Dataset#lateral to run on Microsoft
            <a href="Sequel/SQL.html">SQL</a> Server and Sybase SQLAnywhere.</p>
            
            <p>This is available as a separate extension instead of integrated into the
            Microsoft <a href="Sequel/SQL.html">SQL</a> Server and Sybase SQLAnywhere
            support because few people need it and there is a performance hit to code
            that doesn’t use it.</p>
            
            <p>It is possible there are cases where this emulation does not work.  Users
            should probably verify that correct results are returned when using this
            extension.</p>
            
            <p>You can load this extension into specific datasets:</p>
            
            <pre>ds = DB[:table]&#x000A;ds = ds.extension(:mssql_emulate_lateral_with_apply)</pre>
            
            <p>Or you can load it into all of a database’s datasets:</p>
            
            <pre>DB.extension(:mssql_emulate_lateral_with_apply)</pre>
            
            <p>The null_dataset extension adds the Dataset#nullify method, which returns a
            cloned dataset that will never issue a query to the database.  It
            implements the null object pattern for datasets.</p>
            
            <p>To load the extension:</p>
            
            <pre>Sequel.extension :null_dataset</pre>
            
            <p>The most common usage is probably in a method that must return a dataset,
            where the method knows the dataset shouldn’t return anything.  With
            standard <a href="Sequel.html">Sequel</a>, you’d probably just add a WHERE
            condition that is always false, but that still results in a query being
            sent to the database, and can be overridden using unfiltered, the OR
            operator, or a UNION.</p>
            
            <p>Usage:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span> = <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">items</span>].<span class="ruby-identifier">nullify</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">a=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">b</span>).<span class="ruby-identifier">select</span>(:<span class="ruby-identifier">c</span>)&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">sql</span> <span class="ruby-comment"># =&gt; &quot;SELECT c FROM items WHERE (a = b)&quot;</span>&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">all</span> <span class="ruby-comment"># =&gt; [] # no query sent to the database</span></pre>
            
            <p>Note that there is one case where a null dataset will sent a query to the
            database.  If you call columns on a nulled dataset and the dataset doesn’t
            have an already cached version of the columns, it will create a new dataset
            with the same options to get the columns.</p>
            
            <p>This extension uses Object#extend at runtime, which can hurt performance.</p>
            
            <p>The pagination extension adds the Sequel::Dataset#paginate and each_page
            methods, which return paginated (limited and offset) datasets with some
            helpful methods that make creating a paginated display easier.</p>
            
            <p>This extension uses Object#extend at runtime, which can hurt performance.</p>
            
            <p>You can load this extension into specific datasets:</p>
            
            <pre>ds = DB[:table]&#x000A;ds = ds.extension(:pagination)</pre>
            
            <p>Or you can load it into all of a database’s datasets, which is probably the
            desired behavior if you are using this extension:</p>
            
            <pre>DB.extension(:pagination)</pre>
            
            <p>The pg_array_ops extension adds support to Sequel’s DSL to make it easier
            to call PostgreSQL array functions and operators.</p>
            
            <p>To load the extension:</p>
            
            <pre>Sequel.extension :pg_array_ops</pre>
            
            <p>The most common usage is passing an expression to Sequel.pg_array_op:</p>
            
            <pre>ia = Sequel.pg_array_op(:int_array_column)</pre>
            
            <p>If you have also loaded the pg_array extension, you can use Sequel.pg_array
            as well:</p>
            
            <pre>ia = Sequel.pg_array(:int_array_column)</pre>
            
            <p>Also, on most <a href="Sequel.html">Sequel</a> expression objects, you can
            call the pg_array method:</p>
            
            <pre>ia = Sequel.expr(:int_array_column).pg_array</pre>
            
            <p>If you have loaded the <a
            href="../files/doc/core_extensions_rdoc.html">core_extensions extension</a>
            or you have loaded the core_refinements extension and have activated
            refinements for the file, you can also use <a
            href="Sequel/Postgres/ArrayOpMethods.html#method-i-pg_array">Sequel::Postgres::ArrayOpMethods#pg_array</a>:</p>
            
            <pre>ia = :int_array_column.pg_array</pre>
            
            <p>This creates a <a
            href="Sequel/Postgres/ArrayOp.html">Sequel::Postgres::ArrayOp</a> object
            that can be used for easier querying:</p>
            
            <pre>ia[1]     # int_array_column[1]&#x000A;ia[1][2]  # int_array_column[1][2]&#x000A;ia.contains(:other_int_array_column)     # @&gt; &#x000A;ia.contained_by(:other_int_array_column) # &lt;@&#x000A;ia.overlaps(:other_int_array_column)     # &amp;&amp;&#x000A;ia.concat(:other_int_array_column)       # ||&#x000A;&#x000A;ia.push(1)         # int_array_column || 1&#x000A;ia.unshift(1)      # 1 || int_array_column&#x000A;&#x000A;ia.any             # ANY(int_array_column)&#x000A;ia.all             # ALL(int_array_column)&#x000A;ia.dims            # array_dims(int_array_column)&#x000A;ia.length          # array_length(int_array_column, 1)&#x000A;ia.length(2)       # array_length(int_array_column, 2)&#x000A;ia.lower           # array_lower(int_array_column, 1)&#x000A;ia.lower(2)        # array_lower(int_array_column, 2)&#x000A;ia.join            # array_to_string(int_array_column, '', NULL)&#x000A;ia.join(':')       # array_to_string(int_array_column, ':', NULL)&#x000A;ia.join(':', ' ')  # array_to_string(int_array_column, ':', ' ')&#x000A;ia.unnest          # unnest(int_array_column)</pre>
            
            <p>See the PostgreSQL array function and operator documentation for more
            details on what these functions and operators do.</p>
            
            <p>If you are also using the pg_array extension, you should load it before
            loading this extension.  Doing so will allow you to use PGArray#op to get
            an ArrayOp, allowing you to perform array operations on array literals.</p>
            
            <p>The pg_hstore_ops extension adds support to Sequel’s DSL to make it easier
            to call PostgreSQL hstore functions and operators.</p>
            
            <p>To load the extension:</p>
            
            <pre>Sequel.extension :pg_hstore_ops</pre>
            
            <p>The most common usage is taking an object that represents an <a
            href="Sequel/SQL.html">SQL</a> expression (such as a :symbol), and calling
            Sequel.hstore_op with it:</p>
            
            <pre>h = Sequel.hstore_op(:hstore_column)</pre>
            
            <p>If you have also loaded the pg_hstore extension, you can use Sequel.hstore
            as well:</p>
            
            <pre>h = Sequel.hstore(:hstore_column)</pre>
            
            <p>Also, on most <a href="Sequel.html">Sequel</a> expression objects, you can
            call the hstore  method:</p>
            
            <pre>h = Sequel.expr(:hstore_column).hstore</pre>
            
            <p>If you have loaded the <a
            href="../files/doc/core_extensions_rdoc.html">core_extensions extension</a>
            or you have loaded the core_refinements extension and have activated
            refinements for the file, you can also use <a
            href="Sequel/Postgres/HStoreOpMethods.html#method-i-hstore">Sequel::Postgres::HStoreOpMethods#hstore</a>:</p>
            
            <pre>h = :hstore_column.hstore</pre>
            
            <p>This creates a <a
            href="Sequel/Postgres/HStoreOp.html">Sequel::Postgres::HStoreOp</a> object
            that can be used for easier querying:</p>
            
            <pre>h - 'a'    # hstore_column - CAST('a' AS text)&#x000A;h['a']     # hstore_column -&gt; 'a'&#x000A;h.concat(:other_hstore_column)       # ||&#x000A;h.has_key?('a')                      # ?&#x000A;h.contain_all(:array_column)         # ?&amp;&#x000A;h.contain_any(:array_column)         # ?|&#x000A;h.contains(:other_hstore_column)     # @&gt; &#x000A;h.contained_by(:other_hstore_column) # &lt;@&#x000A;&#x000A;h.defined        # defined(hstore_column)&#x000A;h.delete('a')    # delete(hstore_column, 'a')&#x000A;h.each           # each(hstore_column)&#x000A;h.keys           # akeys(hstore_column)&#x000A;h.populate(:a)   # populate_record(a, hstore_column)&#x000A;h.record_set(:a) # (a #= hstore_column)&#x000A;h.skeys          # skeys(hstore_column)&#x000A;h.slice(:a)      # slice(hstore_column, a)&#x000A;h.svals          # svals(hstore_column)&#x000A;h.to_array       # hstore_to_array(hstore_column)&#x000A;h.to_matrix      # hstore_to_matrix(hstore_column)&#x000A;h.values         # avals(hstore_column)</pre>
            
            <p>See the PostgreSQL hstore function and operator documentation for more
            details on what these functions and operators do.</p>
            
            <p>If you are also using the pg_hstore extension, you should load it before
            loading this extension.  Doing so will allow you to use HStore#op to get an
            HStoreOp, allowing you to perform hstore operations on hstore literals.</p>
            
            <p>The pg_json_ops extension adds support to Sequel’s DSL to make it easier to
            call PostgreSQL JSON functions and operators (added first in PostgreSQL
            9.3).</p>
            
            <p>To load the extension:</p>
            
            <pre>Sequel.extension :pg_json_ops</pre>
            
            <p>The most common usage is passing an expression to Sequel.pg_json_op:</p>
            
            <pre>j = Sequel.pg_json_op(:json_column)</pre>
            
            <p>If you have also loaded the pg_json extension, you can use Sequel.pg_json
            as well:</p>
            
            <pre>j = Sequel.pg_json(:json_column)</pre>
            
            <p>Also, on most <a href="Sequel.html">Sequel</a> expression objects, you can
            call the pg_json method:</p>
            
            <pre>j = Sequel.expr(:json_column).pg_json</pre>
            
            <p>If you have loaded the <a
            href="../files/doc/core_extensions_rdoc.html">core_extensions extension</a>
            or you have loaded the core_refinements extension and have activated
            refinements for the file, you can also use <a
            href="Sequel/Postgres/JSONOpMethods.html#method-i-pg_json">Sequel::Postgres::JSONOpMethods#pg_json</a>:</p>
            
            <pre>j = :json_column.pg_json</pre>
            
            <p>This creates a <a
            href="Sequel/Postgres/JSONOp.html">Sequel::Postgres::JSONOp</a> object that
            can be used for easier querying:</p>
            
            <pre>j[1]                     # (json_column -&gt; 1)&#x000A;j[%w'a b']               # (json_column #&gt; ARRAY['a','b'])&#x000A;j.get_text(1)            # (json_column -&gt;&gt; 1)&#x000A;j.get_text(%w'a b')      # (json_column #&gt;&gt; ARRAY['a','b'])&#x000A;j.extract('a', 'b')      # json_extract_path(json_column, 'a', 'b')&#x000A;j.extract_text('a', 'b') # json_extract_path_text(json_column, 'a', 'b')&#x000A;j.array_length           # json_array_length(json_column)&#x000A;j.array_elements         # json_array_elements(json_column)&#x000A;j.each                   # json_each(json_column)&#x000A;j.each_text              # json_each_text(json_column)&#x000A;j.keys                   # json_object_keys(json_column)&#x000A;&#x000A;j.populate(:a)           # json_populate_record(:a, json_column)&#x000A;j.populate_set(:a)       # json_populate_recordset(:a, json_column)</pre>
            
            <p>If you are also using the pg_json extension, you should load it before
            loading this extension.  Doing so will allow you to use JSONHash#op and
            JSONArray#op to get a JSONOp, allowing you to perform json operations on
            json literals.</p>
            
            <p>The pg_loose_count extension looks at the table statistics in the
            PostgreSQL system tables to get a fast approximate count of the number of
            rows in a given table:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">loose_count</span>(:<span class="ruby-identifier">table</span>) <span class="ruby-comment"># =&gt; 123456</span></pre>
            
            <p>It can also support schema qualified tables:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">loose_count</span>(:<span class="ruby-identifier">schema__table</span>) <span class="ruby-comment"># =&gt; 123456</span></pre>
            
            <p>How accurate this count is depends on the number of rows added/deleted from
            the table since the last time it was analyzed.</p>
            
            <p>To load the extension into the database:</p>
            
            <pre>DB.extension :pg_loose_count</pre>
            
            <p>The pg_range_ops extension adds support to Sequel’s DSL to make it easier
            to call PostgreSQL range functions and operators.</p>
            
            <p>To load the extension:</p>
            
            <pre>Sequel.extension :pg_range_ops</pre>
            
            <p>The most common usage is passing an expression to Sequel.pg_range_op:</p>
            
            <pre>r = Sequel.pg_range_op(:range)</pre>
            
            <p>If you have also loaded the pg_range extension, you can use Sequel.pg_range
            as well:</p>
            
            <pre>r = Sequel.pg_range(:range)</pre>
            
            <p>Also, on most <a href="Sequel.html">Sequel</a> expression objects, you can
            call the pg_range method:</p>
            
            <pre>r = Sequel.expr(:range).pg_range</pre>
            
            <p>If you have loaded the <a
            href="../files/doc/core_extensions_rdoc.html">core_extensions extension</a>
            or you have loaded the core_refinements extension and have activated
            refinements for the file, you can also use <a
            href="Sequel/Postgres/RangeOpMethods.html#method-i-pg_range">Sequel::Postgres::RangeOpMethods#pg_range</a>:</p>
            
            <pre>r = :range.pg_range</pre>
            
            <p>This creates a <a
            href="Sequel/Postgres/RangeOp.html">Sequel::Postgres::RangeOp</a> object
            that can be used for easier querying:</p>
            
            <pre>r.contains(:other)      # range @&gt; other&#x000A;r.contained_by(:other)  # range &lt;@ other&#x000A;r.overlaps(:other)      # range &amp;&amp; other&#x000A;r.left_of(:other)       # range &lt;&lt; other&#x000A;r.right_of(:other)      # range &gt;&gt; other&#x000A;r.starts_after(:other)  # range &amp;&gt; other&#x000A;r.ends_before(:other)   # range &amp;&lt; other&#x000A;r.adjacent_to(:other)   # range -|- other&#x000A;r.lower            # lower(range)&#x000A;r.upper            # upper(range)&#x000A;r.isempty          # isempty(range)&#x000A;r.lower_inc        # lower_inc(range)&#x000A;r.upper_inc        # upper_inc(range)&#x000A;r.lower_inf        # lower_inf(range)&#x000A;r.upper_inf        # upper_inf(range)</pre>
            
            <p>See the PostgreSQL range function and operator documentation for more
            details on what these functions and operators do.</p>
            
            <p>If you are also using the pg_range extension, you should load it before
            loading this extension.  Doing so will allow you to use PGArray#op to get
            an RangeOp, allowing you to perform range operations on range literals.</p>
            
            <p>The pg_row_ops extension adds support to Sequel’s DSL to make it easier to
            deal with PostgreSQL row-valued/composite types.</p>
            
            <p>To load the extension:</p>
            
            <pre>Sequel.extension :pg_row_ops</pre>
            
            <p>The most common usage is passing an expression to Sequel.pg_row_op:</p>
            
            <pre>r = Sequel.pg_row_op(:row_column)</pre>
            
            <p>If you have also loaded the pg_row extension, you can use Sequel.pg_row as
            well:</p>
            
            <pre>r = Sequel.pg_row(:row_column)</pre>
            
            <p>Also, on most <a href="Sequel.html">Sequel</a> expression objects, you can
            call the pg_row method:</p>
            
            <pre>r = Sequel.expr(:row_column).pg_row</pre>
            
            <p>If you have loaded the <a
            href="../files/doc/core_extensions_rdoc.html">core_extensions extension</a>
            or you have loaded the core_refinements extension and have activated
            refinements for the file, you can also use <a
            href="Sequel/Postgres/PGRowOp/ExpressionMethods.html#method-i-pg_row">Sequel::Postgres::PGRowOp::ExpressionMethods#pg_row</a>:</p>
            
            <pre>r = :row_column.pg_row</pre>
            
            <p>There’s only fairly basic support currently.  You can use the [] method to
            access a member of the composite type:</p>
            
            <pre>r[:a] # (row_column).a</pre>
            
            <p>This can be chained:</p>
            
            <pre>r[:a][:b] # ((row_column).a).b</pre>
            
            <p>If you’ve loaded the pg_array_ops extension, you there is also support for
            composite types that include arrays, or arrays of composite types:</p>
            
            <pre>r[1][:a] # (row_column[1]).a&#x000A;r[:a][1] # (row_column).a[1]</pre>
            
            <p>The only other support is the splat method:</p>
            
            <pre>r.splat # (row_column.*)</pre>
            
            <p>The splat method is necessary if you are trying to reference a table’s type
            when the table has the same name as one of it’s columns.  For example:</p>
            
            <pre>DB.create_table(:a){Integer :a; Integer :b}</pre>
            
            <p>Let’s say you want to reference the composite type for the table:</p>
            
            <pre>a = Sequel.pg_row_op(:a)&#x000A;DB[:a].select(a[:b]) # SELECT (a).b FROM a</pre>
            
            <p>Unfortunately, that doesn’t work, as it references the integer column, not
            the table. The splat method works around this:</p>
            
            <pre>DB[:a].select(a.splat[:b]) # SELECT (a.*).b FROM a</pre>
            
            <p>Splat also takes an argument which is used for casting.  This is necessary
            if you want to return the composite type itself, instead of the columns in
            the composite type.  For example:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">a</span>].<span class="ruby-identifier">select</span>(<span class="ruby-identifier">a</span>.<span class="ruby-identifier">splat</span>).<span class="ruby-identifier">first</span> <span class="ruby-comment"># SELECT (a.*) FROM a</span>&#x000A;<span class="ruby-comment"># =&gt; {:a=&gt;1, :b=&gt;2}</span></pre>
            
            <p>By casting the expression, you can get a composite type returned:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">a</span>].<span class="ruby-identifier">select</span>(<span class="ruby-identifier">a</span>.<span class="ruby-identifier">splat</span>).<span class="ruby-identifier">first</span> <span class="ruby-comment"># SELECT (a.*)::a FROM a</span>&#x000A;<span class="ruby-comment"># =&gt; {:a=&gt;&quot;(1,2)&quot;} # or {:a=&gt;{:a=&gt;1, :b=&gt;2}} if the &quot;a&quot; type has been registered</span>&#x000A;                   <span class="ruby-comment"># with the pg_row extension</span></pre>
            
            <p>This feature is mostly useful for a different way to graph tables:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">a</span>].<span class="ruby-identifier">join</span>(:<span class="ruby-identifier">b</span>, :<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">b_id</span>).<span class="ruby-identifier">select</span>(<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">pg_row_op</span>(:<span class="ruby-identifier">a</span>).<span class="ruby-identifier">splat</span>(:<span class="ruby-identifier">a</span>),&#x000A;                                   <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">pg_row_op</span>(:<span class="ruby-identifier">b</span>).<span class="ruby-identifier">splat</span>(:<span class="ruby-identifier">b</span>))&#x000A;<span class="ruby-comment"># SELECT (a.*)::a, (b.*)::b FROM a INNER JOIN b ON (b.id = a.b_id)</span>&#x000A;<span class="ruby-comment"># =&gt; {:a=&gt;{:id=&gt;1, :b_id=&gt;2}, :b=&gt;{:id=&gt;2}}</span></pre>
            
            <p>The pg_static_cache_updater extension is designed to automatically update
            the caches in the models using the static_cache plugin when changes to the
            underlying tables are detected.</p>
            
            <p>Before using the extension in production, you have to add triggers to the
            tables for the classes where you want the caches updated automatically. 
            You would generally do this during a migration:</p>
            
            <pre>Sequel.migration do&#x000A;  up do&#x000A;    extension :pg_static_cache_updater&#x000A;    create_static_cache_update_function&#x000A;    create_static_cache_update_trigger(:table_1)&#x000A;    create_static_cache_update_trigger(:table_2)&#x000A;  end&#x000A;  down do&#x000A;    extension :pg_static_cache_updater&#x000A;    drop_trigger(:table_2, default_static_cache_update_name)&#x000A;    drop_trigger(:table_1, default_static_cache_update_name)&#x000A;    drop_function(default_static_cache_update_name)&#x000A;  end&#x000A;end</pre>
            
            <p>After the triggers have been added, in your application process, after
            setting up your models, you need to listen for changes to the underlying
            tables:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Model1</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>(:<span class="ruby-identifier">table_1</span>)&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">static_cache</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Model2</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>(:<span class="ruby-identifier">table_2</span>)&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">static_cache</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-constant">DB</span>.<span class="ruby-identifier">extension</span> :<span class="ruby-identifier">pg_static_cache_updater</span>&#x000A;<span class="ruby-constant">DB</span>.<span class="ruby-identifier">listen_for_static_cache_updates</span>([<span class="ruby-constant">Model1</span>, <span class="ruby-constant">Model2</span>])</pre>
            
            <p>When an INSERT/UPDATE/DELETE happens on the underlying table, the trigger
            will send a notification with the table’s OID. The application(s) listening
            on that channel will receive the notification, check the oid to see if it
            matches one for the model tables it is interested in, and tell that model
            to reload the cache if there is a match.</p>
            
            <p>Note that listen_for_static_cache_updates spawns a new thread which will
            reserve its own database connection.  This thread runs until the
            application process is shutdown.</p>
            
            <p>Also note that PostgreSQL does not send notifications to channels until
            after the transaction including the changes is committed.  Also, because a
            separate thread is used to listen for notifications, there may be a slight
            delay between when the transaction is committed and when the cache is
            reloaded.</p>
            
            <p>Requirements:</p>
            <ul><li>
            <p>PostgreSQL 9.0+</p>
            </li><li>
            <p>Listening <a href="Sequel/Database.html">Database</a> object must be using
            the postgres adapter with the pg driver (the model classes do not have to
            use the same <a href="Sequel/Database.html">Database</a>).</p>
            </li><li>
            <p>Must be using a thread-safe connection pool (the default).</p>
            </li></ul>
            
            <p>The pretty_table extension adds Sequel::Dataset#print and the <a
            href="Sequel/PrettyTable.html">Sequel::PrettyTable</a> class for creating
            nice-looking plain-text tables.  Example:</p>
            
            <pre>+--+-------+&#x000A;|id|name   |&#x000A;|--+-------|&#x000A;|1 |fasdfas|&#x000A;|2 |test   |&#x000A;+--+-------+</pre>
            
            <p>You can load this extension into specific datasets:</p>
            
            <pre>ds = DB[:table]&#x000A;ds = ds.extension(:pretty_table)</pre>
            
            <p>Or you can load it into all of a database’s datasets, which is probably the
            desired behavior if you are using this extension:</p>
            
            <pre>DB.extension(:pretty_table)</pre>
            
            <p>The query extension adds Sequel::Dataset#query which allows a different way
            to construct queries instead of the usual method chaining.  See
            Sequel::Dataset#query for details.</p>
            
            <p>You can load this extension into specific datasets:</p>
            
            <pre>ds = DB[:table]&#x000A;ds = ds.extension(:query)</pre>
            
            <p>Or you can load it into all of a database’s datasets, which is probably the
            desired behavior if you are using this extension:</p>
            
            <pre>DB.extension(:query)</pre>
            
            <p>The query_literals extension changes Sequel’s default behavior of the
            select, order and group methods so that if the first argument is a regular
            string, it is treated as a literal string, with the rest of the arguments
            (if any) treated as placeholder values. This allows you to write code such
            as:</p>
            
            <pre>DB[:table].select('a, b, ?', 2).group('a, b').order('c')</pre>
            
            <p>The default <a href="Sequel.html">Sequel</a> behavior would literalize that
            as:</p>
            
            <pre>SELECT 'a, b, ?', 2 FROM table GROUP BY 'a, b' ORDER BY 'c'</pre>
            
            <p>Using this extension changes the literalization to:</p>
            
            <pre>SELECT a, b, 2, FROM table GROUP BY a, b ORDER BY c</pre>
            
            <p>This extension makes select, group, and order methods operate like filter
            methods, which support the same interface.</p>
            
            <p>There are very few places where Sequel’s default behavior is desirable in
            this area, but for backwards compatibility, the defaults won’t be changed
            until the next major release.</p>
            
            <p>You can load this extension into specific datasets:</p>
            
            <pre>ds = DB[:table]&#x000A;ds = ds.extension(:query_literals)</pre>
            
            <p>Or you can load it into all of a database’s datasets, which is probably the
            desired behavior if you are using this extension:</p>
            
            <pre>DB.extension(:query_literals)</pre>
            
            <p>The schema_caching extension adds a few methods to <a
            href="Sequel/Database.html">Sequel::Database</a> that make it easy to dump
            the parsed schema information to a file, and load it from that file. 
            Loading the schema information from a dumped file is faster than parsing it
            from the database, so this can save bootup time for applications with large
            numbers of models.</p>
            
            <p>Basic usage in application code:</p>
            
            <pre>DB = Sequel.connect('...')&#x000A;DB.extension :schema_caching&#x000A;DB.load_schema_cache('/path/to/schema.dump')&#x000A;# load model files</pre>
            
            <p>Then, whenever the database schema is modified, write a new cached file. 
            You can do that with <code>bin/sequel</code>‘s -S option:</p>
            
            <pre>bin/sequel -S /path/to/schema.dump postgres://...</pre>
            
            <p>Alternatively, if you don’t want to dump the schema information for all
            tables, and you don’t worry about race conditions, you can choose to use
            the following in your application code:</p>
            
            <pre>DB = Sequel.connect('...')&#x000A;DB.extension :schema_caching&#x000A;DB.load_schema_cache?('/path/to/schema.dump')&#x000A;# load model files&#x000A;&#x000A;DB.dump_schema_cache?('/path/to/schema.dump')</pre>
            
            <p>With this method, you just have to delete the schema dump file if the
            schema is modified, and the application will recreate it for you using just
            the tables that your models use.</p>
            
            <p>Note that it is up to the application to ensure that the dumped cached
            schema reflects the current state of the database.  <a
            href="Sequel.html">Sequel</a> does no checking to ensure this, as checking
            would take time and the purpose of this code is to take a shortcut.</p>
            
            <p>The cached schema is dumped in Marshal format, since it is the fastest and
            it handles all ruby objects used in the schema hash.  Because of this, you
            should not attempt to load the schema from a untrusted file.</p>
            
            <p>The select_remove extension adds Sequel::Dataset#select_remove for removing
            existing selected columns from a dataset.  It’s not part of <a
            href="Sequel.html">Sequel</a> core as it is rarely needed and has some
            corner cases where it can’t work correctly.</p>
            
            <p>You can load this extension into specific datasets:</p>
            
            <pre>ds = DB[:table]&#x000A;ds = ds.extension(:select_remove)</pre>
            
            <p>Or you can load it into all of a database’s datasets, which is probably the
            desired behavior if you are using this extension:</p>
            
            <pre>DB.extension(:select_remove)</pre>
            
            <p>This adds the following dataset methods:</p>
            <dl class="rdoc-list note-list"><dt>[]= 
            <dd>
            <p>filter with the first argument, update with the second</p>
            </dd><dt>insert_multiple 
            <dd>
            <p>insert multiple rows at once</p>
            </dd><dt>set 
            <dd>
            <p>alias for update</p>
            </dd><dt>to_csv 
            <dd>
            <p>return string in csv format for the dataset</p>
            </dd><dt>db= 
            <dd>
            <p>change the dataset’s database</p>
            </dd><dt>opts= 
            <dd>
            <p>change the dataset’s opts</p>
            </dd></dl>
            
            <p>It is only recommended to use this for backwards compatibility.</p>
            
            <p>You can load this extension into specific datasets:</p>
            
            <pre>ds = DB[:table]&#x000A;ds = ds.extension(:sequel_3_dataset_methods)</pre>
            
            <p>Or you can load it into all of a database’s datasets, which is probably the
            desired behavior if you are using this extension:</p>
            
            <pre>DB.extension(:sequel_3_dataset_methods)</pre>
            
            <p>The server_block extension adds the Database#with_server method, which
            takes a shard argument and a block, and makes it so that access inside the
            block will use the specified shard by default.</p>
            
            <p>First, you need to enable it on the database object:</p>
            
            <pre>DB.extension :server_block</pre>
            
            <p>Then you can call with_server:</p>
            
            <pre>DB.with_server(:shard1) do&#x000A;  DB[:a].all # Uses shard1&#x000A;  DB[:a].server(:shard2).all # Uses shard2&#x000A;end&#x000A;DB[:a].all # Uses default</pre>
            
            <p>You can even nest calls to with_server:</p>
            
            <pre>DB.with_server(:shard1) do&#x000A;  DB[:a].all # Uses shard1&#x000A;  DB.with_server(:shard2) do&#x000A;    DB[:a].all # Uses shard2&#x000A;  end&#x000A;  DB[:a].all # Uses shard1&#x000A;end&#x000A;DB[:a].all # Uses default</pre>
            
            <p>Note that if you pass the nil, :default, or :read_only server/shard names
            to Dataset#server inside a with_server block, they will be ignored and the
            server/shard given to with_server will be used:</p>
            
            <pre>DB.with_server(:shard1) do&#x000A;  DB[:a].all # Uses shard1&#x000A;  DB[:a].server(:shard2).all # Uses shard2&#x000A;  DB[:a].server(nil).all # Uses shard1&#x000A;  DB[:a].server(:default).all # Uses shard1&#x000A;  DB[:a].server(:read_only).all # Uses shard1&#x000A;end</pre>
            
            <p>The set_overrides extension adds the Dataset#set_overrides and
            Dataset#set_defaults methods which provide a crude way to control the
            values used in INSERT/UPDATE statements if a hash of values is passed to
            Dataset#insert or Dataset#update. It is only recommended to use this for
            backwards compatibility.</p>
            
            <p>You can load this extension into specific datasets:</p>
            
            <pre>ds = DB[:table]&#x000A;ds = ds.extension(:set_overrides)</pre>
            
            <p>Or you can load it into all of a database’s datasets, which is probably the
            desired behavior if you are using this extension:</p>
            
            <pre>DB.extension(:set_overrides)</pre>
            
            <p>The split_array_nil extension overrides Sequel’s default handling of IN/NOT
            IN with arrays of values to do specific nil checking.  For example,</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span> = <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">column=</span><span class="ruby-operator">&gt;</span>[<span class="ruby-value">1</span>, <span class="ruby-keyword">nil</span>])</pre>
            
            <p>By default, that produces the following SQL:</p>
            
            <pre>SELECT * FROM table WHERE (column IN (1, NULL))</pre>
            
            <p>However, because NULL = NULL is not true in <a
            href="Sequel/SQL.html">SQL</a> (it is NULL), this will not return rows in
            the table where the column is NULL.  This extension allows for an
            alternative behavior more similar to ruby, which will return rows in the
            table where the column is NULL, using a query like:</p>
            
            <pre>SELECT * FROM table WHERE ((column IN (1)) OR (column IS NULL)))</pre>
            
            <p>Similarly, for NOT IN queries:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span> = <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">exclude</span>(:<span class="ruby-identifier">column=</span><span class="ruby-operator">&gt;</span>[<span class="ruby-value">1</span>, <span class="ruby-keyword">nil</span>])&#x000A;<span class="ruby-comment"># Default:</span>&#x000A;<span class="ruby-comment">#   SELECT * FROM table WHERE (column NOT IN (1, NULL))</span>&#x000A;<span class="ruby-comment"># with split_array_nils extension:</span>&#x000A;<span class="ruby-comment">#   SELECT * FROM table WHERE ((column NOT IN (1)) AND (column IS NOT NULL)))</span></pre>
            
            <p>To use this extension with a single dataset:</p>
            
            <pre>ds = ds.extension(:split_array_nil)</pre>
            
            <p>To use this extension for all of a database’s datasets:</p>
            
            <pre>DB.extension(:split_array_nil)</pre>
            
            <p>The thread_local_timezones extension allows you to set a per-thread
            timezone that will override the default global timezone while the thread is
            executing.  The main use case is for web applications that execute each
            request in its own thread, and want to set the timezones based on the
            request.</p>
            
            <p>To load the extension:</p>
            
            <pre>Sequel.extension :thread_local_timezones</pre>
            
            <p>The most common example is having the database always store time in UTC,
            but have the application deal with the timezone of the current user.  That
            can be done with:</p>
            
            <pre>Sequel.database_timezone = :utc&#x000A;# In each thread:&#x000A;Sequel.thread_application_timezone = current_user.timezone</pre>
            
            <p>This extension is designed to work with the named_timezones extension.</p>
            
            <p>This extension adds the thread_application_timezone=,
            thread_database_timezone=, and thread_typecast_timezone= methods to the <a
            href="Sequel.html">Sequel</a> module.  It overrides the
            application_timezone, database_timezone, and typecast_timezone methods to
            check the related thread local timezone first, and use it if present. If
            the related thread local timezone is not present, it falls back to the
            default global timezone.</p>
            
            <p>There is one special case of note.  If you have a default global timezone
            and you want to have a nil thread local timezone, you have to set the
            thread local value to :nil instead of nil:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">application_timezone</span> = :<span class="ruby-identifier">utc</span>&#x000A;<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">thread_application_timezone</span> = <span class="ruby-keyword">nil</span>&#x000A;<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">application_timezone</span> <span class="ruby-comment"># =&gt; :utc</span>&#x000A;<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">thread_application_timezone</span> = :<span class="ruby-keyword">nil</span>&#x000A;<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">application_timezone</span> <span class="ruby-comment"># =&gt; nil</span></pre>
            
            <p>This adds a <code>Sequel::Dataset#to_dot</code> method.  The
            <code>to_dot</code> method returns a string that can be processed by
            graphviz’s <code>dot</code> program in order to get a visualization of the
            dataset.  Basically, it shows a version of the dataset’s abstract syntax
            tree.</p>
            
            <p>To load the extension:</p>
            
            <pre>Sequel.extension :to_dot</pre>
          </div>
          <div id='method-list'>
            <h2>Methods</h2>
            <h3>Public Class</h3>
            <ol>
              <li><a target="docwin" href="#method-c-core_extensions-3F">core_extensions?</a></li>
              <li><a target="docwin" href="#method-c-migration">migration</a></li>
            </ol>
          </div>
          <div id='context'>
          </div>
          <div id='class-list'>
            <h2>Classes and Modules</h2>
            <ol>
              <li><a target="docwin" href="Sequel/ArbitraryServers.html">Sequel::ArbitraryServers</a></li>
              <li><a target="docwin" href="Sequel/ColumnsIntrospection.html">Sequel::ColumnsIntrospection</a></li>
              <li><a target="docwin" href="Sequel/ConnectionValidator.html">Sequel::ConnectionValidator</a></li>
              <li><a target="docwin" href="Sequel/ConstraintValidations.html">Sequel::ConstraintValidations</a></li>
              <li><a target="docwin" href="Sequel/CoreRefinements.html">Sequel::CoreRefinements</a></li>
              <li><a target="docwin" href="Sequel/Database.html">Sequel::Database</a></li>
              <li><a target="docwin" href="Sequel/DatabaseQuery.html">Sequel::DatabaseQuery</a></li>
              <li><a target="docwin" href="Sequel/DatasetPagination.html">Sequel::DatasetPagination</a></li>
              <li><a target="docwin" href="Sequel/DatasetPrinter.html">Sequel::DatasetPrinter</a></li>
              <li><a target="docwin" href="Sequel/DatasetQuery.html">Sequel::DatasetQuery</a></li>
              <li><a target="docwin" href="Sequel/EmptyArrayIgnoreNulls.html">Sequel::EmptyArrayIgnoreNulls</a></li>
              <li><a target="docwin" href="Sequel/ErrorSQL.html">Sequel::ErrorSQL</a></li>
              <li><a target="docwin" href="Sequel/EvalInspect.html">Sequel::EvalInspect</a></li>
              <li><a target="docwin" href="Sequel/FilterHaving.html">Sequel::FilterHaving</a></li>
              <li><a target="docwin" href="Sequel/GraphEach.html">Sequel::GraphEach</a></li>
              <li><a target="docwin" href="Sequel/HashAliases.html">Sequel::HashAliases</a></li>
              <li><a target="docwin" href="Sequel/LooserTypecasting.html">Sequel::LooserTypecasting</a></li>
              <li><a target="docwin" href="Sequel/MSSQL.html">Sequel::MSSQL</a></li>
              <li><a target="docwin" href="Sequel/Metaprogramming.html">Sequel::Metaprogramming</a></li>
              <li><a target="docwin" href="Sequel/NamedTimezones.html">Sequel::NamedTimezones</a></li>
              <li><a target="docwin" href="Sequel/Plugins.html">Sequel::Plugins</a></li>
              <li><a target="docwin" href="Sequel/Postgres.html">Sequel::Postgres</a></li>
              <li><a target="docwin" href="Sequel/PrettyTable.html">Sequel::PrettyTable</a></li>
              <li><a target="docwin" href="Sequel/QueryLiterals.html">Sequel::QueryLiterals</a></li>
              <li><a target="docwin" href="Sequel/SQL.html">Sequel::SQL</a></li>
              <li><a target="docwin" href="Sequel/Schema.html">Sequel::Schema</a></li>
              <li><a target="docwin" href="Sequel/SchemaCaching.html">Sequel::SchemaCaching</a></li>
              <li><a target="docwin" href="Sequel/SchemaDumper.html">Sequel::SchemaDumper</a></li>
              <li><a target="docwin" href="Sequel/SelectRemove.html">Sequel::SelectRemove</a></li>
              <li><a target="docwin" href="Sequel/Sequel3DatasetMethods.html">Sequel::Sequel3DatasetMethods</a></li>
              <li><a target="docwin" href="Sequel/ServerBlock.html">Sequel::ServerBlock</a></li>
              <li><a target="docwin" href="Sequel/SetOverrides.html">Sequel::SetOverrides</a></li>
              <li><a target="docwin" href="Sequel/ThreadLocalTimezones.html">Sequel::ThreadLocalTimezones</a></li>
              <li><a target="docwin" href="Sequel/ThreadedServerBlock.html">Sequel::ThreadedServerBlock</a></li>
              <li><a target="docwin" href="Sequel/UnthreadedServerBlock.html">Sequel::UnthreadedServerBlock</a></li>
              <li><a target="docwin" href="Sequel/DatabaseError.html">Sequel::DatabaseError</a></li>
              <li><a target="docwin" href="Sequel/Dataset.html">Sequel::Dataset</a></li>
              <li><a target="docwin" href="Sequel/IntegerMigrator.html">Sequel::IntegerMigrator</a></li>
              <li><a target="docwin" href="Sequel/LiteralString.html">Sequel::LiteralString</a></li>
              <li><a target="docwin" href="Sequel/Migration.html">Sequel::Migration</a></li>
              <li><a target="docwin" href="Sequel/MigrationAlterTableReverser.html">Sequel::MigrationAlterTableReverser</a></li>
              <li><a target="docwin" href="Sequel/MigrationDSL.html">Sequel::MigrationDSL</a></li>
              <li><a target="docwin" href="Sequel/MigrationReverser.html">Sequel::MigrationReverser</a></li>
              <li><a target="docwin" href="Sequel/Migrator.html">Sequel::Migrator</a></li>
              <li><a target="docwin" href="Sequel/Model.html">Sequel::Model</a></li>
              <li><a target="docwin" href="Sequel/SimpleMigration.html">Sequel::SimpleMigration</a></li>
              <li><a target="docwin" href="Sequel/TimestampMigrator.html">Sequel::TimestampMigrator</a></li>
              <li><a target="docwin" href="Sequel/ToDot.html">Sequel::ToDot</a></li>
            </ol>
          </div>
          <div id='section'>
            <div id='methods'>
              <h2>Public Class methods</h2>
              <div class='method public-class' id='method-method-c-core_extensions-3F'>
                <a name='method-c-core_extensions-3F'></a>
                <div class='synopsis'>
                  <span class='name'>core_extensions?</span>
                  <span class='arguments'>()</span>
                </div>
                <div class='description'>
                  
                  <p>This extension loads the core extensions.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-c-core_extensions-3F-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-c-core_extensions-3F-source'><span class="ruby-comment"># File lib/sequel/extensions/core_extensions.rb, line 13</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">core_extensions?</span>&#x000A;  <span class="ruby-keyword">true</span>&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method public-class' id='method-method-c-migration'>
                <a name='method-c-migration'></a>
                <div class='synopsis'>
                  <span class='name'>migration</span>
                  <span class='arguments'>(&block)</span>
                </div>
                <div class='description'>
                  
                  <p>The preferred method for writing <a href="Sequel.html">Sequel</a>
                  migrations, using a DSL:</p>
                  
                  <pre>Sequel.migration do&#x000A;  up do&#x000A;    create_table(:artists) do&#x000A;      primary_key :id&#x000A;      String :name&#x000A;    end&#x000A;  end&#x000A;  down do&#x000A;    drop_table(:artists)&#x000A;  end&#x000A;end</pre>
                  
                  <p>Designed to be used with the <code>Migrator</code> class, part of the
                  <code>migration</code> extension.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-c-migration-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-c-migration-source'><span class="ruby-comment"># File lib/sequel/extensions/migration.rb, line 280</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">migration</span>(&amp;<span class="ruby-identifier">block</span>)&#x000A;  <span class="ruby-constant">MigrationDSL</span>.<span class="ruby-identifier">create</span>(&amp;<span class="ruby-identifier">block</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
