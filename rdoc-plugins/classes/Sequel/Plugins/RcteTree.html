<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>Sequel::Plugins::RcteTree</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='class' id='wrapper'>
      <div class='header'>
        <h1 class='name'>
          <span class='type'>module</span>
          Sequel::Plugins::RcteTree
        </h1>
        <ol class='paths'>
          <li>
            <a target="docwin" href="../../../files/lib/sequel/plugins/rcte_tree_rb.html">lib/sequel/plugins/rcte_tree.rb</a>
          </li>
        </ol>
        <div class='parent'>
          Parent:
          <strong><a target="docwin" href="../Plugins.html">Plugins</a></strong>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <h1 id="label-Overview">Overview</h1>
            
            <p>The rcte_tree plugin deals with tree structured data stored in the database
            using the adjacency list model (where child rows have a foreign key
            pointing to the parent rows), using recursive common table expressions to
            load all ancestors in a single query, all descendants in a single query,
            and all descendants to a given level (where level 1 is children, level 2 is
            children and grandchildren etc.) in a single query.</p>
            
            <h1 id="label-Background">Background</h1>
            
            <p>There are two types of common models for storing tree structured data in an
            <a href="../SQL.html">SQL</a> database, the adjacency list model and the
            nested set model. Before recursive common table expressions (or similar
            capabilities such as CONNECT BY for Oracle), the nested set model was the
            only easy way to retrieve all ancestors and descendants in a single query. 
            However, it has significant performance corner cases.</p>
            
            <p>On PostgreSQL 8.4, with a significant number of rows, the nested set model
            is almost 500 times slower than using a recursive common table expression
            with the adjacency list model to get all descendants, and almost 24,000
            times slower to get all descendants to a given level.</p>
            
            <p>Considering that the nested set model requires more difficult management
            than the adjacency list model, it’s almost always better to use the
            adjacency list model if your database supports common table expressions.
            See <a
            href="http://explainextended.com/2009/09/24/adjacency-list-vs-nested-sets-postgresql/">explainextended.com/2009/09/24/adjacency-list-vs-nested-sets-postgresql/</a>
            for detailed analysis.</p>
            
            <h1 id="label-Usage">Usage</h1>
            
            <p>The rcte_tree plugin adds four associations to the model: parent, children,
            ancestors, and descendants.  Both the parent and children are fairly
            standard many_to_one and one_to_many associations, respectively.  However,
            the ancestors and descendants associations are special.  Both the ancestors
            and descendants associations will automatically set the parent and children
            associations, respectively, for current object and all of the ancestor or
            descendant objects, whenever they are loaded (either eagerly or lazily). 
            Additionally, the descendants association can take a level argument when
            called eagerly, which limits the returned objects to only that many levels
            in the tree (see the Overview).</p>
            
            <pre class="ruby"><span class="ruby-constant">Model</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">rcte_tree</span>&#x000A;&#x000A;<span class="ruby-comment"># Lazy loading</span>&#x000A;<span class="ruby-identifier">model</span> = <span class="ruby-constant">Model</span>.<span class="ruby-identifier">first</span>&#x000A;<span class="ruby-identifier">model</span>.<span class="ruby-identifier">parent</span>&#x000A;<span class="ruby-identifier">model</span>.<span class="ruby-identifier">children</span>&#x000A;<span class="ruby-identifier">model</span>.<span class="ruby-identifier">ancestors</span> <span class="ruby-comment"># Populates :parent association for all ancestors</span>&#x000A;<span class="ruby-identifier">model</span>.<span class="ruby-identifier">descendants</span> <span class="ruby-comment"># Populates :children association for all descendants</span>&#x000A;&#x000A;<span class="ruby-comment"># Eager loading - also populates the :parent and children associations</span>&#x000A;<span class="ruby-comment"># for all ancestors and descendants</span>&#x000A;<span class="ruby-constant">Model</span>.<span class="ruby-identifier">filter</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>]).<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">ancestors</span>, :<span class="ruby-identifier">descendants</span>).<span class="ruby-identifier">all</span>&#x000A;&#x000A;<span class="ruby-comment"># Eager loading children and grand children</span>&#x000A;<span class="ruby-constant">Model</span>.<span class="ruby-identifier">filter</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>]).<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">descendants=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">2</span>).<span class="ruby-identifier">all</span>&#x000A;<span class="ruby-comment"># Eager loading children, grand children, and great grand children</span>&#x000A;<span class="ruby-constant">Model</span>.<span class="ruby-identifier">filter</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>]).<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">descendants=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">3</span>).<span class="ruby-identifier">all</span></pre>
            
            <h1 id="label-Options">Options</h1>
            
            <p>You can override the options for any specific association by making sure
            the plugin options contain one of the following keys:</p>
            <ul><li>
            <p>:parent - hash of options for the parent association</p>
            </li><li>
            <p>:children - hash of options for the children association</p>
            </li><li>
            <p>:ancestors - hash of options for the ancestors association</p>
            </li><li>
            <p>:descendants - hash of options for the descendants association</p>
            </li></ul>
            
            <p>Note that you can change the name of the above associations by specifying a
            :name key in the appropriate hash of options above.  For example:</p>
            
            <pre class="ruby"><span class="ruby-constant">Model</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">rcte_tree</span>, :<span class="ruby-identifier">parent=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">mother</span>},&#x000A; :<span class="ruby-identifier">children=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">daughters</span>}, :<span class="ruby-identifier">descendants=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">offspring</span>}</pre>
            
            <p>Any other keys in the main options hash are treated as options shared by
            all of the associations.  Here’s a few options that affect the plugin:</p>
            <ul><li>
            <p>:key - The foreign key in the table that points to the primary key of the
            parent (default: :parent_id)</p>
            </li><li>
            <p>:primary_key - The primary key to use (default: the model’s primary key)</p>
            </li><li>
            <p>:key_alias - The symbol identifier to use for aliasing when eager loading
            (default: :x_root_x)</p>
            </li><li>
            <p>:cte_name - The symbol identifier to use for the common table expression
            (default: :t)</p>
            </li><li>
            <p>:level_alias - The symbol identifier to use when eagerly loading
            descendants up to a given level (default: :x_level_x)</p>
            </li></ul>
          </div>
          <div id='method-list'>
            <h2>Methods</h2>
            <h3>Public Class</h3>
            <ol>
              <li><a target="docwin" href="#method-c-apply">apply</a></li>
            </ol>
          </div>
          <div id='context'>
          </div>
          <div id='section'>
            <div id='methods'>
              <h2>Public Class methods</h2>
              <div class='method public-class' id='method-method-c-apply'>
                <a name='method-c-apply'></a>
                <div class='synopsis'>
                  <span class='name'>apply</span>
                  <span class='arguments'>(model, opts=OPTS)</span>
                </div>
                <div class='description'>
                  
                  <p>Create the appropriate parent, children, ancestors, and descendants
                  associations for the model.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-c-apply-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-c-apply-source'><span class="ruby-comment"># File lib/sequel/plugins/rcte_tree.rb, line 95</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">model</span>, <span class="ruby-identifier">opts</span>=<span class="ruby-constant">OPTS</span>)&#x000A;  <span class="ruby-identifier">model</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:tree</span>, <span class="ruby-identifier">opts</span>&#x000A;&#x000A;  <span class="ruby-identifier">opts</span> = <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">dup</span>&#x000A;  <span class="ruby-identifier">opts</span>[<span class="ruby-value">:class</span>] = <span class="ruby-identifier">model</span>&#x000A;  <span class="ruby-identifier">opts</span>[<span class="ruby-value">:methods_module</span>] = <span class="ruby-constant">Module</span>.<span class="ruby-identifier">new</span>&#x000A;  <span class="ruby-identifier">model</span>.<span class="ruby-identifier">send</span>(<span class="ruby-value">:include</span>, <span class="ruby-identifier">opts</span>[<span class="ruby-value">:methods_module</span>])&#x000A;  &#x000A;  <span class="ruby-identifier">key</span> = <span class="ruby-identifier">opts</span>[<span class="ruby-value">:key</span>] <span class="ruby-operator">||=</span> <span class="ruby-value">:parent_id</span>&#x000A;  <span class="ruby-identifier">prkey</span> = <span class="ruby-identifier">opts</span>[<span class="ruby-value">:primary_key</span>] <span class="ruby-operator">||=</span> <span class="ruby-identifier">model</span>.<span class="ruby-identifier">primary_key</span>&#x000A;  <span class="ruby-identifier">ka</span> = <span class="ruby-identifier">opts</span>[<span class="ruby-value">:key_alias</span>] <span class="ruby-operator">||=</span> <span class="ruby-value">:x_root_x</span>&#x000A;  <span class="ruby-identifier">t</span> = <span class="ruby-identifier">opts</span>[<span class="ruby-value">:cte_name</span>] <span class="ruby-operator">||=</span> <span class="ruby-value">:t</span>&#x000A;  <span class="ruby-identifier">c_all</span> = <span class="ruby-keyword">if</span> <span class="ruby-identifier">model</span>.<span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">recursive_cte_requires_column_aliases?</span>&#x000A;    <span class="ruby-comment"># Work around Oracle/ruby-oci8 bug that returns integers as BigDecimals in recursive queries.</span>&#x000A;    <span class="ruby-identifier">conv_bd</span> = <span class="ruby-identifier">model</span>.<span class="ruby-identifier">db</span>.<span class="ruby-identifier">database_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:oracle</span>&#x000A;    <span class="ruby-identifier">col_aliases</span> = <span class="ruby-identifier">model</span>.<span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">columns</span>&#x000A;    <span class="ruby-identifier">model_table</span> = <span class="ruby-identifier">model</span>.<span class="ruby-identifier">table_name</span>&#x000A;    <span class="ruby-identifier">col_aliases</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">QualifiedIdentifier</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">model_table</span>, <span class="ruby-identifier">c</span>)}&#x000A;  <span class="ruby-keyword">else</span>&#x000A;    [<span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">ColumnAll</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">model</span>.<span class="ruby-identifier">table_name</span>)]&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  &#x000A;  <span class="ruby-identifier">bd_conv</span> = <span class="ruby-identifier">lambda</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">conv_bd</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">v</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">BigDecimal</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">v</span>.<span class="ruby-identifier">to_i</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">v</span>}&#x000A;&#x000A;  <span class="ruby-identifier">key_array</span> = <span class="ruby-constant">Array</span>(<span class="ruby-identifier">key</span>)&#x000A;  <span class="ruby-identifier">prkey_array</span> = <span class="ruby-constant">Array</span>(<span class="ruby-identifier">prkey</span>)&#x000A;  <span class="ruby-keyword">if</span> <span class="ruby-identifier">key</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>)&#x000A;    <span class="ruby-identifier">key_conv</span> = <span class="ruby-identifier">lambda</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span> <span class="ruby-identifier">key_array</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">k</span><span class="ruby-operator">|</span> <span class="ruby-identifier">m</span>[<span class="ruby-identifier">k</span>]}}&#x000A;    <span class="ruby-identifier">key_present</span> = <span class="ruby-identifier">lambda</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span> <span class="ruby-identifier">key_conv</span>[<span class="ruby-identifier">m</span>].<span class="ruby-identifier">all?</span>}&#x000A;    <span class="ruby-identifier">prkey_conv</span> = <span class="ruby-identifier">lambda</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span> <span class="ruby-identifier">prkey_array</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">k</span><span class="ruby-operator">|</span> <span class="ruby-identifier">m</span>[<span class="ruby-identifier">k</span>]}}&#x000A;    <span class="ruby-identifier">key_aliases</span> = (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-identifier">key_array</span>.<span class="ruby-identifier">length</span>).<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-value">:&quot;#{ka}_#{i}&quot;</span>}&#x000A;    <span class="ruby-identifier">ka_conv</span> = <span class="ruby-identifier">lambda</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span> <span class="ruby-identifier">key_aliases</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">k</span><span class="ruby-operator">|</span> <span class="ruby-identifier">m</span>[<span class="ruby-identifier">k</span>]}}&#x000A;    <span class="ruby-identifier">ancestor_base_case_columns</span> = <span class="ruby-identifier">prkey_array</span>.<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">key_aliases</span>).<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">k</span>, <span class="ruby-identifier">ka_</span><span class="ruby-operator">|</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">k</span>, <span class="ruby-identifier">ka_</span>)} <span class="ruby-operator">+</span> <span class="ruby-identifier">c_all</span>&#x000A;    <span class="ruby-identifier">descendant_base_case_columns</span> = <span class="ruby-identifier">key_array</span>.<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">key_aliases</span>).<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">k</span>, <span class="ruby-identifier">ka_</span><span class="ruby-operator">|</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">k</span>, <span class="ruby-identifier">ka_</span>)} <span class="ruby-operator">+</span> <span class="ruby-identifier">c_all</span>&#x000A;    <span class="ruby-identifier">recursive_case_columns</span> = <span class="ruby-identifier">prkey_array</span>.<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">key_aliases</span>).<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">k</span>, <span class="ruby-identifier">ka_</span><span class="ruby-operator">|</span> <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">QualifiedIdentifier</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">t</span>, <span class="ruby-identifier">ka_</span>)} <span class="ruby-operator">+</span> <span class="ruby-identifier">c_all</span>&#x000A;    <span class="ruby-identifier">extract_key_alias</span> = <span class="ruby-identifier">lambda</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span> <span class="ruby-identifier">key_aliases</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ka_</span><span class="ruby-operator">|</span> <span class="ruby-identifier">bd_conv</span>[<span class="ruby-identifier">m</span>.<span class="ruby-identifier">values</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">ka_</span>)]}}&#x000A;  <span class="ruby-keyword">else</span>&#x000A;    <span class="ruby-identifier">key_present</span> = <span class="ruby-identifier">key_conv</span> = <span class="ruby-identifier">lambda</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span> <span class="ruby-identifier">m</span>[<span class="ruby-identifier">key</span>]}&#x000A;    <span class="ruby-identifier">prkey_conv</span> = <span class="ruby-identifier">lambda</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span> <span class="ruby-identifier">m</span>[<span class="ruby-identifier">prkey</span>]}&#x000A;    <span class="ruby-identifier">key_aliases</span> = [<span class="ruby-identifier">ka</span>]&#x000A;    <span class="ruby-identifier">ka_conv</span> = <span class="ruby-identifier">lambda</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span> <span class="ruby-identifier">m</span>[<span class="ruby-identifier">ka</span>]}&#x000A;    <span class="ruby-identifier">ancestor_base_case_columns</span> = [<span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">prkey</span>, <span class="ruby-identifier">ka</span>)] <span class="ruby-operator">+</span> <span class="ruby-identifier">c_all</span>&#x000A;    <span class="ruby-identifier">descendant_base_case_columns</span> = [<span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">ka</span>)] <span class="ruby-operator">+</span> <span class="ruby-identifier">c_all</span>&#x000A;    <span class="ruby-identifier">recursive_case_columns</span> = [<span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">QualifiedIdentifier</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">t</span>, <span class="ruby-identifier">ka</span>)] <span class="ruby-operator">+</span> <span class="ruby-identifier">c_all</span>&#x000A;    <span class="ruby-identifier">extract_key_alias</span> = <span class="ruby-identifier">lambda</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span> <span class="ruby-identifier">bd_conv</span>[<span class="ruby-identifier">m</span>.<span class="ruby-identifier">values</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">ka</span>)]}&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  &#x000A;  <span class="ruby-identifier">parent</span> = <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:parent</span>, {})).<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:name</span>, <span class="ruby-value">:parent</span>)&#x000A;  <span class="ruby-identifier">childrena</span> = <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:children</span>, {})).<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:name</span>, <span class="ruby-value">:children</span>)&#x000A;  &#x000A;  <span class="ruby-identifier">opts</span>[<span class="ruby-value">:reciprocal</span>] = <span class="ruby-keyword">nil</span>&#x000A;  <span class="ruby-identifier">a</span> = <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:ancestors</span>, {}))&#x000A;  <span class="ruby-identifier">ancestors</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:name</span>, <span class="ruby-value">:ancestors</span>)&#x000A;  <span class="ruby-identifier">a</span>[<span class="ruby-value">:read_only</span>] = <span class="ruby-keyword">true</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-value">:read_only</span>)&#x000A;  <span class="ruby-identifier">a</span>[<span class="ruby-value">:eager_loader_key</span>] = <span class="ruby-identifier">key</span>&#x000A;  <span class="ruby-identifier">a</span>[<span class="ruby-value">:dataset</span>] <span class="ruby-operator">||=</span> <span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">base_ds</span> = <span class="ruby-identifier">model</span>.<span class="ruby-identifier">filter</span>(<span class="ruby-identifier">prkey_array</span>.<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">key_array</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">k</span><span class="ruby-operator">|</span> <span class="ruby-identifier">send</span>(<span class="ruby-identifier">k</span>)}))&#x000A;    <span class="ruby-identifier">recursive_ds</span> = <span class="ruby-identifier">model</span>.<span class="ruby-identifier">join</span>(<span class="ruby-identifier">t</span>, <span class="ruby-identifier">key_array</span>.<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">prkey_array</span>))&#x000A;    <span class="ruby-keyword">if</span> <span class="ruby-identifier">c</span> = <span class="ruby-identifier">a</span>[<span class="ruby-value">:conditions</span>]&#x000A;      (<span class="ruby-identifier">base_ds</span>, <span class="ruby-identifier">recursive_ds</span>) = [<span class="ruby-identifier">base_ds</span>, <span class="ruby-identifier">recursive_ds</span>].<span class="ruby-identifier">collect</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span>&#x000A;        (<span class="ruby-identifier">c</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">condition_specifier?</span>(<span class="ruby-identifier">c</span>)) <span class="ruby-operator">?</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">filter</span>(*<span class="ruby-identifier">c</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">filter</span>(<span class="ruby-identifier">c</span>)&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-identifier">table_alias</span> = <span class="ruby-identifier">model</span>.<span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">schema_and_table</span>(<span class="ruby-identifier">model</span>.<span class="ruby-identifier">table_name</span>)[<span class="ruby-value">1</span>].<span class="ruby-identifier">to_sym</span>&#x000A;    <span class="ruby-identifier">model</span>.<span class="ruby-identifier">from</span>(<span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">t</span>, <span class="ruby-identifier">table_alias</span>)).&#x000A;     <span class="ruby-identifier">with_recursive</span>(<span class="ruby-identifier">t</span>, <span class="ruby-identifier">col_aliases</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">base_ds</span>.<span class="ruby-identifier">select</span>(*<span class="ruby-identifier">col_aliases</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">base_ds</span>.<span class="ruby-identifier">select_all</span>,&#x000A;      <span class="ruby-identifier">recursive_ds</span>.<span class="ruby-identifier">select</span>(*<span class="ruby-identifier">c_all</span>),&#x000A;      <span class="ruby-value">:args=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">col_aliases</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-identifier">aal</span> = <span class="ruby-constant">Array</span>(<span class="ruby-identifier">a</span>[<span class="ruby-value">:after_load</span>])&#x000A;  <span class="ruby-identifier">aal</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">m</span>, <span class="ruby-identifier">ancs</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">associations</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">parent</span>)&#x000A;      <span class="ruby-identifier">parent_map</span> = {<span class="ruby-identifier">prkey_conv</span>[<span class="ruby-identifier">m</span>]=<span class="ruby-operator">&gt;</span><span class="ruby-identifier">m</span>}&#x000A;      <span class="ruby-identifier">child_map</span> = {}&#x000A;      <span class="ruby-identifier">child_map</span>[<span class="ruby-identifier">key_conv</span>[<span class="ruby-identifier">m</span>]] = <span class="ruby-identifier">m</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">key_present</span>[<span class="ruby-identifier">m</span>]&#x000A;      <span class="ruby-identifier">m</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-identifier">parent</span>] = <span class="ruby-keyword">nil</span>&#x000A;      <span class="ruby-identifier">ancs</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">obj</span><span class="ruby-operator">|</span>&#x000A;        <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-identifier">parent</span>] = <span class="ruby-keyword">nil</span>&#x000A;        <span class="ruby-identifier">parent_map</span>[<span class="ruby-identifier">prkey_conv</span>[<span class="ruby-identifier">obj</span>]] = <span class="ruby-identifier">obj</span>&#x000A;        <span class="ruby-keyword">if</span> <span class="ruby-identifier">ok</span> = <span class="ruby-identifier">key_conv</span>[<span class="ruby-identifier">obj</span>]&#x000A;          <span class="ruby-identifier">child_map</span>[<span class="ruby-identifier">ok</span>] = <span class="ruby-identifier">obj</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;      <span class="ruby-identifier">parent_map</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">parent_id</span>, <span class="ruby-identifier">obj</span><span class="ruby-operator">|</span>&#x000A;        <span class="ruby-keyword">if</span> <span class="ruby-identifier">child</span> = <span class="ruby-identifier">child_map</span>[<span class="ruby-identifier">parent_id</span>]&#x000A;          <span class="ruby-identifier">child</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-identifier">parent</span>] = <span class="ruby-identifier">obj</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-identifier">a</span>[<span class="ruby-value">:after_load</span>] <span class="ruby-operator">||=</span> <span class="ruby-identifier">aal</span>&#x000A;  <span class="ruby-identifier">a</span>[<span class="ruby-value">:eager_loader</span>] <span class="ruby-operator">||=</span> <span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">eo</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">id_map</span> = <span class="ruby-identifier">eo</span>[<span class="ruby-value">:id_map</span>]&#x000A;    <span class="ruby-identifier">parent_map</span> = {}&#x000A;    <span class="ruby-identifier">children_map</span> = {}&#x000A;    <span class="ruby-identifier">eo</span>[<span class="ruby-value">:rows</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">obj</span><span class="ruby-operator">|</span>&#x000A;      <span class="ruby-identifier">parent_map</span>[<span class="ruby-identifier">prkey_conv</span>[<span class="ruby-identifier">obj</span>]] = <span class="ruby-identifier">obj</span>&#x000A;      (<span class="ruby-identifier">children_map</span>[<span class="ruby-identifier">key_conv</span>[<span class="ruby-identifier">obj</span>]] <span class="ruby-operator">||=</span> []) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">obj</span>&#x000A;      <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-identifier">ancestors</span>] = []&#x000A;      <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-identifier">parent</span>] = <span class="ruby-keyword">nil</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-identifier">r</span> = <span class="ruby-identifier">model</span>.<span class="ruby-identifier">association_reflection</span>(<span class="ruby-identifier">ancestors</span>)&#x000A;    <span class="ruby-identifier">base_case</span> = <span class="ruby-identifier">model</span>.<span class="ruby-identifier">filter</span>(<span class="ruby-identifier">prkey</span>=<span class="ruby-operator">&gt;</span><span class="ruby-identifier">id_map</span>.<span class="ruby-identifier">keys</span>).&#x000A;     <span class="ruby-identifier">select</span>(*<span class="ruby-identifier">ancestor_base_case_columns</span>)&#x000A;    <span class="ruby-identifier">recursive_case</span> = <span class="ruby-identifier">model</span>.<span class="ruby-identifier">join</span>(<span class="ruby-identifier">t</span>, <span class="ruby-identifier">key_array</span>.<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">prkey_array</span>)).&#x000A;     <span class="ruby-identifier">select</span>(*<span class="ruby-identifier">recursive_case_columns</span>)&#x000A;    <span class="ruby-keyword">if</span> <span class="ruby-identifier">c</span> = <span class="ruby-identifier">r</span>[<span class="ruby-value">:conditions</span>]&#x000A;      (<span class="ruby-identifier">base_case</span>, <span class="ruby-identifier">recursive_case</span>) = [<span class="ruby-identifier">base_case</span>, <span class="ruby-identifier">recursive_case</span>].<span class="ruby-identifier">collect</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span>&#x000A;        (<span class="ruby-identifier">c</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">condition_specifier?</span>(<span class="ruby-identifier">c</span>)) <span class="ruby-operator">?</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">filter</span>(*<span class="ruby-identifier">c</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">filter</span>(<span class="ruby-identifier">c</span>)&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-identifier">table_alias</span> = <span class="ruby-identifier">model</span>.<span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">schema_and_table</span>(<span class="ruby-identifier">model</span>.<span class="ruby-identifier">table_name</span>)[<span class="ruby-value">1</span>].<span class="ruby-identifier">to_sym</span>&#x000A;    <span class="ruby-identifier">elds</span> = <span class="ruby-identifier">model</span>.<span class="ruby-identifier">eager_loading_dataset</span>(<span class="ruby-identifier">r</span>,&#x000A;     <span class="ruby-identifier">model</span>.<span class="ruby-identifier">from</span>(<span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">t</span>, <span class="ruby-identifier">table_alias</span>)).&#x000A;      <span class="ruby-identifier">with_recursive</span>(<span class="ruby-identifier">t</span>, <span class="ruby-identifier">base_case</span>,&#x000A;       <span class="ruby-identifier">recursive_case</span>,&#x000A;       <span class="ruby-value">:args=</span><span class="ruby-operator">&gt;</span>((<span class="ruby-identifier">key_aliases</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">col_aliases</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">col_aliases</span>)),&#x000A;     <span class="ruby-identifier">r</span>.<span class="ruby-identifier">select</span>,&#x000A;     <span class="ruby-identifier">eo</span>[<span class="ruby-value">:associations</span>], <span class="ruby-identifier">eo</span>)&#x000A;    <span class="ruby-identifier">elds</span> = <span class="ruby-identifier">elds</span>.<span class="ruby-identifier">select_append</span>(<span class="ruby-identifier">ka</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">elds</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:select</span>] <span class="ruby-operator">==</span> <span class="ruby-keyword">nil</span>&#x000A;    <span class="ruby-identifier">elds</span>.<span class="ruby-identifier">all</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">obj</span><span class="ruby-operator">|</span>&#x000A;      <span class="ruby-identifier">opk</span> = <span class="ruby-identifier">prkey_conv</span>[<span class="ruby-identifier">obj</span>]&#x000A;      <span class="ruby-keyword">if</span> <span class="ruby-identifier">parent_map</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">opk</span>)&#x000A;        <span class="ruby-keyword">if</span> <span class="ruby-identifier">idm_obj</span> = <span class="ruby-identifier">parent_map</span>[<span class="ruby-identifier">opk</span>]&#x000A;          <span class="ruby-identifier">key_aliases</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ka_</span><span class="ruby-operator">|</span> <span class="ruby-identifier">idm_obj</span>.<span class="ruby-identifier">values</span>[<span class="ruby-identifier">ka_</span>] = <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">values</span>[<span class="ruby-identifier">ka_</span>]}&#x000A;          <span class="ruby-identifier">obj</span> = <span class="ruby-identifier">idm_obj</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;      <span class="ruby-keyword">else</span>&#x000A;        <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-identifier">parent</span>] = <span class="ruby-keyword">nil</span>&#x000A;        <span class="ruby-identifier">parent_map</span>[<span class="ruby-identifier">opk</span>] = <span class="ruby-identifier">obj</span>&#x000A;        (<span class="ruby-identifier">children_map</span>[<span class="ruby-identifier">key_conv</span>[<span class="ruby-identifier">obj</span>]] <span class="ruby-operator">||=</span> []) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">obj</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;      &#x000A;      <span class="ruby-keyword">if</span> <span class="ruby-identifier">roots</span> = <span class="ruby-identifier">id_map</span>[<span class="ruby-identifier">extract_key_alias</span>[<span class="ruby-identifier">obj</span>]]&#x000A;        <span class="ruby-identifier">roots</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">root</span><span class="ruby-operator">|</span>&#x000A;          <span class="ruby-identifier">root</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-identifier">ancestors</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">obj</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-identifier">parent_map</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">parent_id</span>, <span class="ruby-identifier">obj</span><span class="ruby-operator">|</span>&#x000A;      <span class="ruby-keyword">if</span> <span class="ruby-identifier">children</span> = <span class="ruby-identifier">children_map</span>[<span class="ruby-identifier">parent_id</span>]&#x000A;        <span class="ruby-identifier">children</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">child</span><span class="ruby-operator">|</span>&#x000A;          <span class="ruby-identifier">child</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-identifier">parent</span>] = <span class="ruby-identifier">obj</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-identifier">model</span>.<span class="ruby-identifier">one_to_many</span> <span class="ruby-identifier">ancestors</span>, <span class="ruby-identifier">a</span>&#x000A;  &#x000A;  <span class="ruby-identifier">d</span> = <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:descendants</span>, {}))&#x000A;  <span class="ruby-identifier">descendants</span> = <span class="ruby-identifier">d</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:name</span>, <span class="ruby-value">:descendants</span>)&#x000A;  <span class="ruby-identifier">d</span>[<span class="ruby-value">:read_only</span>] = <span class="ruby-keyword">true</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">d</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-value">:read_only</span>)&#x000A;  <span class="ruby-identifier">la</span> = <span class="ruby-identifier">d</span>[<span class="ruby-value">:level_alias</span>] <span class="ruby-operator">||=</span> <span class="ruby-value">:x_level_x</span>&#x000A;  <span class="ruby-identifier">d</span>[<span class="ruby-value">:dataset</span>] <span class="ruby-operator">||=</span> <span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">base_ds</span> = <span class="ruby-identifier">model</span>.<span class="ruby-identifier">filter</span>(<span class="ruby-identifier">key_array</span>.<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">prkey_array</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">k</span><span class="ruby-operator">|</span> <span class="ruby-identifier">send</span>(<span class="ruby-identifier">k</span>)}))&#x000A;    <span class="ruby-identifier">recursive_ds</span> = <span class="ruby-identifier">model</span>.<span class="ruby-identifier">join</span>(<span class="ruby-identifier">t</span>, <span class="ruby-identifier">prkey_array</span>.<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">key_array</span>))&#x000A;    <span class="ruby-keyword">if</span> <span class="ruby-identifier">c</span> = <span class="ruby-identifier">d</span>[<span class="ruby-value">:conditions</span>]&#x000A;      (<span class="ruby-identifier">base_ds</span>, <span class="ruby-identifier">recursive_ds</span>) = [<span class="ruby-identifier">base_ds</span>, <span class="ruby-identifier">recursive_ds</span>].<span class="ruby-identifier">collect</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span>&#x000A;        (<span class="ruby-identifier">c</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">condition_specifier?</span>(<span class="ruby-identifier">c</span>)) <span class="ruby-operator">?</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">filter</span>(*<span class="ruby-identifier">c</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">filter</span>(<span class="ruby-identifier">c</span>)&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-identifier">table_alias</span> = <span class="ruby-identifier">model</span>.<span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">schema_and_table</span>(<span class="ruby-identifier">model</span>.<span class="ruby-identifier">table_name</span>)[<span class="ruby-value">1</span>].<span class="ruby-identifier">to_sym</span>&#x000A;    <span class="ruby-identifier">model</span>.<span class="ruby-identifier">from</span>(<span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">t</span>, <span class="ruby-identifier">table_alias</span>)).&#x000A;     <span class="ruby-identifier">with_recursive</span>(<span class="ruby-identifier">t</span>, <span class="ruby-identifier">col_aliases</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">base_ds</span>.<span class="ruby-identifier">select</span>(*<span class="ruby-identifier">col_aliases</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">base_ds</span>.<span class="ruby-identifier">select_all</span>,&#x000A;      <span class="ruby-identifier">recursive_ds</span>.<span class="ruby-identifier">select</span>(*<span class="ruby-identifier">c_all</span>),&#x000A;      <span class="ruby-value">:args=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">col_aliases</span>)&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-identifier">dal</span> = <span class="ruby-constant">Array</span>(<span class="ruby-identifier">d</span>[<span class="ruby-value">:after_load</span>])&#x000A;  <span class="ruby-identifier">dal</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">m</span>, <span class="ruby-identifier">descs</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">associations</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">childrena</span>)&#x000A;      <span class="ruby-identifier">parent_map</span> = {<span class="ruby-identifier">prkey_conv</span>[<span class="ruby-identifier">m</span>]=<span class="ruby-operator">&gt;</span><span class="ruby-identifier">m</span>}&#x000A;      <span class="ruby-identifier">children_map</span> = {}&#x000A;      <span class="ruby-identifier">m</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-identifier">childrena</span>] = []&#x000A;      <span class="ruby-identifier">descs</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">obj</span><span class="ruby-operator">|</span>&#x000A;        <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-identifier">childrena</span>] = []&#x000A;        <span class="ruby-keyword">if</span> <span class="ruby-identifier">opk</span> = <span class="ruby-identifier">prkey_conv</span>[<span class="ruby-identifier">obj</span>]&#x000A;          <span class="ruby-identifier">parent_map</span>[<span class="ruby-identifier">opk</span>] = <span class="ruby-identifier">obj</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;        <span class="ruby-keyword">if</span> <span class="ruby-identifier">ok</span> = <span class="ruby-identifier">key_conv</span>[<span class="ruby-identifier">obj</span>]&#x000A;          (<span class="ruby-identifier">children_map</span>[<span class="ruby-identifier">ok</span>] <span class="ruby-operator">||=</span> []) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">obj</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;      <span class="ruby-identifier">children_map</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">parent_id</span>, <span class="ruby-identifier">objs</span><span class="ruby-operator">|</span>&#x000A;        <span class="ruby-identifier">parent_map</span>[<span class="ruby-identifier">parent_id</span>].<span class="ruby-identifier">associations</span>[<span class="ruby-identifier">childrena</span>] = <span class="ruby-identifier">objs</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-identifier">d</span>[<span class="ruby-value">:after_load</span>] = <span class="ruby-identifier">dal</span>&#x000A;  <span class="ruby-identifier">d</span>[<span class="ruby-value">:eager_loader</span>] <span class="ruby-operator">||=</span> <span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">eo</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">id_map</span> = <span class="ruby-identifier">eo</span>[<span class="ruby-value">:id_map</span>]&#x000A;    <span class="ruby-identifier">associations</span> = <span class="ruby-identifier">eo</span>[<span class="ruby-value">:associations</span>]&#x000A;    <span class="ruby-identifier">parent_map</span> = {}&#x000A;    <span class="ruby-identifier">children_map</span> = {}&#x000A;    <span class="ruby-identifier">eo</span>[<span class="ruby-value">:rows</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">obj</span><span class="ruby-operator">|</span>&#x000A;      <span class="ruby-identifier">parent_map</span>[<span class="ruby-identifier">prkey_conv</span>[<span class="ruby-identifier">obj</span>]] = <span class="ruby-identifier">obj</span>&#x000A;      <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-identifier">descendants</span>] = []&#x000A;      <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-identifier">childrena</span>] = []&#x000A;    <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-identifier">r</span> = <span class="ruby-identifier">model</span>.<span class="ruby-identifier">association_reflection</span>(<span class="ruby-identifier">descendants</span>)&#x000A;    <span class="ruby-identifier">base_case</span> = <span class="ruby-identifier">model</span>.<span class="ruby-identifier">filter</span>(<span class="ruby-identifier">key</span>=<span class="ruby-operator">&gt;</span><span class="ruby-identifier">id_map</span>.<span class="ruby-identifier">keys</span>).&#x000A;     <span class="ruby-identifier">select</span>(*<span class="ruby-identifier">descendant_base_case_columns</span>)&#x000A;    <span class="ruby-identifier">recursive_case</span> = <span class="ruby-identifier">model</span>.<span class="ruby-identifier">join</span>(<span class="ruby-identifier">t</span>, <span class="ruby-identifier">prkey_array</span>.<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">key_array</span>)).&#x000A;     <span class="ruby-identifier">select</span>(*<span class="ruby-identifier">recursive_case_columns</span>)&#x000A;    <span class="ruby-keyword">if</span> <span class="ruby-identifier">c</span> = <span class="ruby-identifier">r</span>[<span class="ruby-value">:conditions</span>]&#x000A;      (<span class="ruby-identifier">base_case</span>, <span class="ruby-identifier">recursive_case</span>) = [<span class="ruby-identifier">base_case</span>, <span class="ruby-identifier">recursive_case</span>].<span class="ruby-identifier">collect</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span>&#x000A;        (<span class="ruby-identifier">c</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">condition_specifier?</span>(<span class="ruby-identifier">c</span>)) <span class="ruby-operator">?</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">filter</span>(*<span class="ruby-identifier">c</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">filter</span>(<span class="ruby-identifier">c</span>)&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">if</span> <span class="ruby-identifier">associations</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Integer</span>)&#x000A;      <span class="ruby-identifier">level</span> = <span class="ruby-identifier">associations</span>&#x000A;      <span class="ruby-identifier">no_cache_level</span> = <span class="ruby-identifier">level</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>&#x000A;      <span class="ruby-identifier">associations</span> = {}&#x000A;      <span class="ruby-identifier">base_case</span> = <span class="ruby-identifier">base_case</span>.<span class="ruby-identifier">select_more</span>(<span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-value">0</span>, <span class="ruby-constant">Integer</span>), <span class="ruby-identifier">la</span>))&#x000A;      <span class="ruby-identifier">recursive_case</span> = <span class="ruby-identifier">recursive_case</span>.<span class="ruby-identifier">select_more</span>(<span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">QualifiedIdentifier</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">t</span>, <span class="ruby-identifier">la</span>) <span class="ruby-operator">+</span> <span class="ruby-value">1</span>, <span class="ruby-identifier">la</span>)).<span class="ruby-identifier">filter</span>(<span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">QualifiedIdentifier</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">t</span>, <span class="ruby-identifier">la</span>) <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">level</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>)&#x000A;    <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-identifier">table_alias</span> = <span class="ruby-identifier">model</span>.<span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">schema_and_table</span>(<span class="ruby-identifier">model</span>.<span class="ruby-identifier">table_name</span>)[<span class="ruby-value">1</span>].<span class="ruby-identifier">to_sym</span>&#x000A;    <span class="ruby-identifier">elds</span> = <span class="ruby-identifier">model</span>.<span class="ruby-identifier">eager_loading_dataset</span>(<span class="ruby-identifier">r</span>,&#x000A;     <span class="ruby-identifier">model</span>.<span class="ruby-identifier">from</span>(<span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">t</span>, <span class="ruby-identifier">table_alias</span>)).<span class="ruby-identifier">with_recursive</span>(<span class="ruby-identifier">t</span>, <span class="ruby-identifier">base_case</span>, <span class="ruby-identifier">recursive_case</span>,&#x000A;      <span class="ruby-value">:args=</span><span class="ruby-operator">&gt;</span>((<span class="ruby-identifier">key_aliases</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">col_aliases</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">level</span> <span class="ruby-operator">?</span> [<span class="ruby-identifier">la</span>] <span class="ruby-operator">:</span> [])) <span class="ruby-keyword">if</span> <span class="ruby-identifier">col_aliases</span>)),&#x000A;     <span class="ruby-identifier">r</span>.<span class="ruby-identifier">select</span>,&#x000A;     <span class="ruby-identifier">associations</span>, <span class="ruby-identifier">eo</span>)&#x000A;    <span class="ruby-identifier">elds</span> = <span class="ruby-identifier">elds</span>.<span class="ruby-identifier">select_append</span>(<span class="ruby-identifier">ka</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">elds</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:select</span>] <span class="ruby-operator">==</span> <span class="ruby-keyword">nil</span>&#x000A;    <span class="ruby-identifier">elds</span>.<span class="ruby-identifier">all</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">obj</span><span class="ruby-operator">|</span>&#x000A;      <span class="ruby-keyword">if</span> <span class="ruby-identifier">level</span>&#x000A;        <span class="ruby-identifier">no_cache</span> = <span class="ruby-identifier">no_cache_level</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">values</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">la</span>)&#x000A;      <span class="ruby-keyword">end</span>&#x000A;      &#x000A;      <span class="ruby-identifier">opk</span> = <span class="ruby-identifier">prkey_conv</span>[<span class="ruby-identifier">obj</span>]&#x000A;      <span class="ruby-keyword">if</span> <span class="ruby-identifier">parent_map</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">opk</span>)&#x000A;        <span class="ruby-keyword">if</span> <span class="ruby-identifier">idm_obj</span> = <span class="ruby-identifier">parent_map</span>[<span class="ruby-identifier">opk</span>]&#x000A;          <span class="ruby-identifier">key_aliases</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ka_</span><span class="ruby-operator">|</span> <span class="ruby-identifier">idm_obj</span>.<span class="ruby-identifier">values</span>[<span class="ruby-identifier">ka_</span>] = <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">values</span>[<span class="ruby-identifier">ka_</span>]}&#x000A;          <span class="ruby-identifier">obj</span> = <span class="ruby-identifier">idm_obj</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;      <span class="ruby-keyword">else</span>&#x000A;        <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-identifier">childrena</span>] = [] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">no_cache</span>&#x000A;        <span class="ruby-identifier">parent_map</span>[<span class="ruby-identifier">opk</span>] = <span class="ruby-identifier">obj</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;      &#x000A;      <span class="ruby-keyword">if</span> <span class="ruby-identifier">root</span> = <span class="ruby-identifier">id_map</span>[<span class="ruby-identifier">extract_key_alias</span>[<span class="ruby-identifier">obj</span>]].<span class="ruby-identifier">first</span>&#x000A;        <span class="ruby-identifier">root</span>.<span class="ruby-identifier">associations</span>[<span class="ruby-identifier">descendants</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">obj</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;      &#x000A;      (<span class="ruby-identifier">children_map</span>[<span class="ruby-identifier">key_conv</span>[<span class="ruby-identifier">obj</span>]] <span class="ruby-operator">||=</span> []) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">obj</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-identifier">children_map</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">parent_id</span>, <span class="ruby-identifier">objs</span><span class="ruby-operator">|</span>&#x000A;      <span class="ruby-identifier">parent_map</span>[<span class="ruby-identifier">parent_id</span>].<span class="ruby-identifier">associations</span>[<span class="ruby-identifier">childrena</span>] = <span class="ruby-identifier">objs</span>.<span class="ruby-identifier">uniq</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-identifier">model</span>.<span class="ruby-identifier">one_to_many</span> <span class="ruby-identifier">descendants</span>, <span class="ruby-identifier">d</span>&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
