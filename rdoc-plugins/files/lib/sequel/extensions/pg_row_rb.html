<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>pg_row.rb</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='file' id='wrapper'>
      <div class='header'>
        <h1 class='name'>pg_row.rb</h1>
        <div class='paths'>
          lib/sequel/extensions/pg_row.rb
        </div>
        <div class='last-update'>
          Last Update:
          <span class='datetime'>2013-11-08 08:08:17 -0500</span>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <p>The pg_row extension adds support for <a
            href="../../../../classes/Sequel.html">Sequel</a> to handle PostgreSQL’s
            row-valued/composite types.</p>
            
            <p>This extension integrates with Sequel’s native postgres adapter, so that
            when composite fields are retrieved, they are parsed and returned as
            instances of Sequel::Postgres::PGRow::(HashRow|ArrayRow), or optionally a
            custom type.  HashRow and ArrayRow are DelegateClasses of of <a
            href="../../../../classes/Hash.html">Hash</a> and <a
            href="../../../../classes/Array.html">Array</a>, so they mostly act like a
            hash or array, but not completely (is_a?(<a
            href="../../../../classes/Hash.html">Hash</a>) and is_a?(<a
            href="../../../../classes/Array.html">Array</a>) are false).  If you want
            the actual hash for a HashRow, call HashRow#to_hash, and if you want the
            actual array for an ArrayRow, call ArrayRow#to_a.  This is done so that <a
            href="../../../../classes/Sequel.html">Sequel</a> does not treat a values
            like an <a href="../../../../classes/Array.html">Array</a> or <a
            href="../../../../classes/Hash.html">Hash</a> by default, which would cause
            issues.</p>
            
            <p>In addition to the parsers, this extension comes with literalizers for
            HashRow and ArrayRow using the standard <a
            href="../../../../classes/Sequel.html">Sequel</a> literalization callbacks,
            so they work with on all adapters.</p>
            
            <p>The first thing you are going to want to do is to load the extension into
            your Database object.  Make sure you load the :pg_array extension first if
            you plan to use composite types in bound variables:</p>
            
            <pre>DB.extension(:pg_array, :pg_row)</pre>
            
            <p>You can create an anonymous row type by calling the Sequel.pg_row with an
            array:</p>
            
            <pre>Sequel.pg_row(array)</pre>
            
            <p>If you have loaded the <a
            href="../../../doc/core_extensions_rdoc.html">core_extensions extension</a>
            or you have loaded the core_refinements extension and have activated
            refinements for the file, you can also use <a
            href="../../../../classes/Array.html#method-i-pg_row">Array#pg_row</a>:</p>
            
            <pre>array.pg_row</pre>
            
            <p>However, in most cases you are going to want something beyond anonymous row
            types.  This extension allows you to register row types on a per database
            basis, using Database#register_row_type:</p>
            
            <pre>DB.register_row_type(:foo)</pre>
            
            <p>When you register the row type, <a
            href="../../../../classes/Sequel.html">Sequel</a> will query the PostgreSQL
            system tables to find the related metadata, and will setup a custom HashRow
            subclass for that type.  This includes looking up conversion procs for each
            column in the type, so that when the composite type is returned from the
            database, the members of the type have the correct type.  Additionally, if
            the composite type also has an array form, <a
            href="../../../../classes/Sequel.html">Sequel</a> registers an array type
            for the composite type, so that array columns of the composite type are
            converted correctly.</p>
            
            <p>You can then create values of that type by using Database#row_type:</p>
            
            <pre>DB.row_type(:address, ['123 Sesame St.', 'Some City', '12345'])</pre>
            
            <p>Let’s say table address has columns street, city, and zip.  This would
            return something similar to:</p>
            
            <pre class="ruby">{:<span class="ruby-identifier">street=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'123 Sesame St.'</span>, :<span class="ruby-identifier">city=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'Some City'</span>, :<span class="ruby-identifier">zip=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'12345'</span>}</pre>
            
            <p>You can also use a hash:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">row_type</span>(:<span class="ruby-identifier">address</span>, :<span class="ruby-identifier">street=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'123 Sesame St.'</span>, :<span class="ruby-identifier">city=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'Some City'</span>, :<span class="ruby-identifier">zip=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'12345'</span>)</pre>
            
            <p>So if you have a person table that has an address column, here’s how you
            could insert into the column:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">insert</span>(:<span class="ruby-identifier">address=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">DB</span>.<span class="ruby-identifier">row_type</span>(:<span class="ruby-identifier">address</span>, :<span class="ruby-identifier">street=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'123 Sesame St.'</span>, :<span class="ruby-identifier">city=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'Some City'</span>, :<span class="ruby-identifier">zip=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'12345'</span>))</pre>
            
            <p>Note that registering row types without providing an explicit :converter
            option creates anonymous classes.  This results in ruby being unable to
            Marshal such objects.  You can work around this by assigning the anonymous
            class to a constant. To get a list of such anonymous classes, you can use
            the following code:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">conversion_procs</span>.<span class="ruby-identifier">select</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">k</span>,<span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">v</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Postgres</span><span class="ruby-operator">::</span><span class="ruby-constant">PGRow</span><span class="ruby-operator">::</span><span class="ruby-constant">Parser</span>) <span class="ruby-operator">&amp;&amp;</span>    <span class="ruby-identifier">v</span>.<span class="ruby-identifier">converter</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">v</span>.<span class="ruby-identifier">converter</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">v</span>.<span class="ruby-identifier">converter</span>.<span class="ruby-identifier">name</span> <span class="ruby-operator">==</span> <span class="ruby-string">''</span>) }.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">k</span>,<span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">v</span>}</pre>
            
            <p>If you are not using the native postgres adapter and are using composite
            types types as model column values you probably should use the
            pg_typecast_on_load plugin if the column values are returned as a string.</p>
            
            <p>This extension requires both the strscan and delegate libraries.</p>
          </div>
          <div id='context'>
            <div id='requires'>
              <h2>Required files</h2>
              <ol>
                <li>delegate</li>
                <li>strscan</li>
                <li>adapters/utils/pg_types</li>
              </ol>
            </div>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
