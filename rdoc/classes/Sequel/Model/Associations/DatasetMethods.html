<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>Sequel::Model::Associations::DatasetMethods</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='class' id='wrapper'>
      <div class='header'>
        <h1 class='name'>
          <span class='type'>module</span>
          Sequel::Model::Associations::DatasetMethods
        </h1>
        <ol class='paths'>
          <li>
            <a target="docwin" href="../../../../files/lib/sequel/model/associations_rb.html">lib/sequel/model/associations.rb</a>
          </li>
        </ol>
        <div class='parent'>
          Parent:
          <strong><a target="docwin" href="../Associations.html">Associations</a></strong>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <p>Eager loading makes it so that you can load all associated records for a
            set of objects in a single query, instead of a separate query for each
            object.</p>
            
            <p>Two separate implementations are provided.  <code>eager</code> should be
            used most of the time, as it loads associated records using one query per
            association.  However, it does not allow you the ability to filter or order
            based on columns in associated tables.  <code>eager_graph</code> loads all
            records in a single query using JOINs, allowing you to filter or order
            based on columns in associated tables.  However, <code>eager_graph</code>
            is usually slower than <code>eager</code>, especially if multiple
            one_to_many or many_to_many associations are joined.</p>
            
            <p>You can cascade the eager loading (loading associations on associated
            objects) with no limit to the depth of the cascades.  You do this by
            passing a hash to <code>eager</code> or <code>eager_graph</code> with the
            keys being associations of the current model and values being associations
            of the model associated with the current model via the key.</p>
            
            <p>The arguments can be symbols or hashes with symbol keys (for cascaded eager
            loading). Examples:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">artist</span>).<span class="ruby-identifier">all</span>&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager_graph</span>(:<span class="ruby-identifier">artist</span>).<span class="ruby-identifier">all</span>&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">artist</span>, :<span class="ruby-identifier">genre</span>).<span class="ruby-identifier">all</span>&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager_graph</span>(:<span class="ruby-identifier">artist</span>, :<span class="ruby-identifier">genre</span>).<span class="ruby-identifier">all</span>&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">artist</span>).<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">genre</span>).<span class="ruby-identifier">all</span>&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager_graph</span>(:<span class="ruby-identifier">artist</span>).<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">genre</span>).<span class="ruby-identifier">all</span>&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">albums=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">tracks</span>).<span class="ruby-identifier">all</span>&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager_graph</span>(:<span class="ruby-identifier">albums=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">tracks</span>).<span class="ruby-identifier">all</span>&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">albums=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">tracks=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">genre</span>}).<span class="ruby-identifier">all</span>&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager_graph</span>(:<span class="ruby-identifier">albums=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">tracks=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">genre</span>}).<span class="ruby-identifier">all</span></pre>
            
            <p>You can also pass a callback as a hash value in order to customize the
            dataset being eager loaded at query time, analogous to the way the
            :eager_block association option allows you to customize it at association
            definition time. For example, if you wanted artists with their albums since
            1990:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">albums</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">year</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1990</span>}})</pre>
            
            <p>Or if you needed albums and their artistâ€™s name only, using a single query:</p>
            
            <pre class="ruby"><span class="ruby-constant">Albums</span>.<span class="ruby-identifier">eager_graph</span>(:<span class="ruby-identifier">artist</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>(:<span class="ruby-identifier">name</span>)})</pre>
            
            <p>To cascade eager loading while using a callback, you substitute the
            cascaded associations with a single entry hash that has the proc callback
            as the key and  the cascaded associations as the value.  This will load
            artists with their albums since 1990, and also the tracks on those albums
            and the genre for those tracks:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">albums</span> =<span class="ruby-operator">&gt;</span> {<span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">year</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1990</span>}}=<span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">tracks</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">genre</span>}})</pre>
          </div>
          <div id='method-list'>
            <h2>Methods</h2>
            <h3>Public Instance</h3>
            <ol>
              <li><a target="docwin" href="#method-i-complex_expression_sql_append">complex_expression_sql_append</a></li>
              <li><a target="docwin" href="#method-i-eager">eager</a></li>
              <li><a target="docwin" href="#method-i-eager_graph">eager_graph</a></li>
              <li><a target="docwin" href="#method-i-ungraphed">ungraphed</a></li>
            </ol>
            <h3>Protected Instance</h3>
            <ol>
              <li><a target="docwin" href="#method-i-eager_graph_association">eager_graph_association</a></li>
              <li><a target="docwin" href="#method-i-eager_graph_associations">eager_graph_associations</a></li>
              <li><a target="docwin" href="#method-i-eager_graph_build_associations">eager_graph_build_associations</a></li>
            </ol>
          </div>
          <div id='context'>
          </div>
          <div id='section'>
            <div id='methods'>
              <h2>Public Instance methods</h2>
              <div class='method public-instance' id='method-method-i-complex_expression_sql_append'>
                <a name='method-i-complex_expression_sql_append'></a>
                <div class='synopsis'>
                  <span class='name'>complex_expression_sql_append</span>
                  <span class='arguments'>(sql, op, args)</span>
                </div>
                <div class='description'>
                  
                  <p>If the expression is in the form <code>x = y</code> where <code>y</code> is
                  a <code>Sequel::Model</code> instance, array of <code>Sequel::Model</code>
                  instances, or a <code>Sequel::Model</code> dataset, assume <code>x</code>
                  is an association symbol and look up the association reflection via the
                  datasetâ€™s model.  From there, return the appropriate <a
                  href="../../SQL.html">SQL</a> based on the type of association and the
                  values of the foreign/primary keys of <code>y</code>.  For most association
                  types, this is a simple transformation, but for <code>many_to_many</code>
                  associations this  creates a subquery to the join table.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-complex_expression_sql_append-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-complex_expression_sql_append-source'><span class="ruby-comment"># File lib/sequel/model/associations.rb, line 1840</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">complex_expression_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">op</span>, <span class="ruby-identifier">args</span>)&#x000A;  <span class="ruby-identifier">r</span> = <span class="ruby-identifier">args</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">1</span>)&#x000A;  <span class="ruby-keyword">if</span> (((<span class="ruby-identifier">op</span> <span class="ruby-operator">==</span> <span class="ruby-value">:'='</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">op</span> <span class="ruby-operator">==</span> <span class="ruby-value">:'!='</span>) <span class="ruby-keyword">and</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>)) <span class="ruby-operator">||</span>&#x000A;      (<span class="ruby-identifier">multiple</span> = ((<span class="ruby-identifier">op</span> <span class="ruby-operator">==</span> <span class="ruby-value">:IN</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">op</span> <span class="ruby-operator">==</span> <span class="ruby-value">:'NOT IN'</span>) <span class="ruby-keyword">and</span> ((<span class="ruby-identifier">is_ds</span> = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Dataset</span>)) <span class="ruby-keyword">or</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">all?</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>)}))))&#x000A;    <span class="ruby-identifier">l</span> = <span class="ruby-identifier">args</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">0</span>)&#x000A;    <span class="ruby-keyword">if</span> <span class="ruby-identifier">ar</span> = <span class="ruby-identifier">model</span>.<span class="ruby-identifier">association_reflections</span>[<span class="ruby-identifier">l</span>]&#x000A;      <span class="ruby-keyword">if</span> <span class="ruby-identifier">multiple</span>&#x000A;        <span class="ruby-identifier">klass</span> = <span class="ruby-identifier">ar</span>.<span class="ruby-identifier">associated_class</span>&#x000A;        <span class="ruby-keyword">if</span> <span class="ruby-identifier">is_ds</span>&#x000A;          <span class="ruby-keyword">if</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:model</span>)&#x000A;            <span class="ruby-keyword">unless</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">model</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">klass</span>&#x000A;              <span class="ruby-comment"># A dataset for a different model class, could be a valid regular query</span>&#x000A;              <span class="ruby-keyword">return</span> <span class="ruby-keyword">super</span>&#x000A;            <span class="ruby-keyword">end</span>&#x000A;          <span class="ruby-keyword">else</span>&#x000A;            <span class="ruby-comment"># Not a model dataset, could be a valid regular query</span>&#x000A;            <span class="ruby-keyword">return</span> <span class="ruby-keyword">super</span>&#x000A;          <span class="ruby-keyword">end</span>&#x000A;        <span class="ruby-keyword">else</span>&#x000A;          <span class="ruby-keyword">unless</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">all?</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-identifier">klass</span>)}&#x000A;            <span class="ruby-identifier">raise</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Error</span>, <span class="ruby-node">&quot;invalid association class for one object for association #{l.inspect} used in dataset filter for model #{model.inspect}, expected class #{klass.inspect}&quot;</span>&#x000A;          <span class="ruby-keyword">end</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;      <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">r</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-identifier">ar</span>.<span class="ruby-identifier">associated_class</span>)&#x000A;        <span class="ruby-identifier">raise</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Error</span>, <span class="ruby-node">&quot;invalid association class #{r.class.inspect} for association #{l.inspect} used in dataset filter for model #{model.inspect}, expected class #{ar.associated_class.inspect}&quot;</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;&#x000A;      <span class="ruby-keyword">if</span> <span class="ruby-identifier">exp</span> = <span class="ruby-identifier">association_filter_expression</span>(<span class="ruby-identifier">op</span>, <span class="ruby-identifier">ar</span>, <span class="ruby-identifier">r</span>)&#x000A;        <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">exp</span>)&#x000A;      <span class="ruby-keyword">else</span>&#x000A;        <span class="ruby-identifier">raise</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Error</span>, <span class="ruby-node">&quot;invalid association type #{ar[:type].inspect} for association #{l.inspect} used in dataset filter for model #{model.inspect}&quot;</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">multiple</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">is_ds</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">empty?</span>)&#x000A;      <span class="ruby-comment"># Not a query designed for this support, could be a valid regular query</span>&#x000A;      <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-keyword">else</span>&#x000A;      <span class="ruby-identifier">raise</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Error</span>, <span class="ruby-node">&quot;invalid association #{l.inspect} used in dataset filter for model #{model.inspect}&quot;</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">else</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method public-instance' id='method-method-i-eager'>
                <a name='method-i-eager'></a>
                <div class='synopsis'>
                  <span class='name'>eager</span>
                  <span class='arguments'>(*associations)</span>
                </div>
                <div class='description'>
                  
                  <p>The preferred eager loading method.  Loads all associated records using one
                  query for each association.</p>
                  
                  <p>The basic idea for how it works is that the dataset is first loaded
                  normally. Then it goes through all associations that have been specified
                  via <code>eager</code>. It loads each of those associations separately,
                  then associates them back to the original dataset via primary/foreign keys.
                  Due to the necessity of all objects being present, you need to use
                  <code>all</code> to use eager loading, as it canâ€™t work with
                  <code>each</code>.</p>
                  
                  <p>This implementation avoids the complexity of extracting an object graph out
                  of a single dataset, by building the object graph out of multiple datasets,
                  one for each association.  By using a separate dataset for each
                  association, it avoids problems such as aliasing conflicts and creating
                  cartesian product result sets if multiple one_to_many or many_to_many eager
                  associations are requested.</p>
                  
                  <p>One limitation of using this method is that you cannot filter the dataset
                  based on values of columns in an associated table, since the associations
                  are loaded in separate queries.  To do that you need to load all
                  associations in the same query, and extract an object graph from the
                  results of that query. If you need to filter based on columns in associated
                  tables, look at <code>eager_graph</code> or join the tables you need to
                  filter on manually.</p>
                  
                  <p>Each associationâ€™s order, if defined, is respected. If the association uses
                  a block or has an :eager_block argument, it is used.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-eager-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-eager-source'><span class="ruby-comment"># File lib/sequel/model/associations.rb, line 1908</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">eager</span>(*<span class="ruby-identifier">associations</span>)&#x000A;  <span class="ruby-identifier">opt</span> = <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:eager</span>]&#x000A;  <span class="ruby-identifier">opt</span> = <span class="ruby-identifier">opt</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">opt</span>.<span class="ruby-identifier">dup</span> <span class="ruby-operator">:</span> {}&#x000A;  <span class="ruby-identifier">associations</span>.<span class="ruby-identifier">flatten</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">association</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-keyword">case</span> <span class="ruby-identifier">association</span>&#x000A;    <span class="ruby-keyword">when</span> <span class="ruby-constant">Symbol</span>&#x000A;      <span class="ruby-identifier">check_association</span>(<span class="ruby-identifier">model</span>, <span class="ruby-identifier">association</span>)&#x000A;      <span class="ruby-identifier">opt</span>[<span class="ruby-identifier">association</span>] = <span class="ruby-keyword">nil</span>&#x000A;    <span class="ruby-keyword">when</span> <span class="ruby-constant">Hash</span>&#x000A;      <span class="ruby-identifier">association</span>.<span class="ruby-identifier">keys</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">assoc</span><span class="ruby-operator">|</span> <span class="ruby-identifier">check_association</span>(<span class="ruby-identifier">model</span>, <span class="ruby-identifier">assoc</span>)}&#x000A;      <span class="ruby-identifier">opt</span>.<span class="ruby-identifier">merge!</span>(<span class="ruby-identifier">association</span>)&#x000A;    <span class="ruby-keyword">else</span>&#x000A;      <span class="ruby-identifier">raise</span>(<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Error</span>, <span class="ruby-string">'Associations must be in the form of a symbol or hash'</span>)&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-identifier">clone</span>(<span class="ruby-value">:eager=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">opt</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method public-instance' id='method-method-i-eager_graph'>
                <a name='method-i-eager_graph'></a>
                <div class='synopsis'>
                  <span class='name'>eager_graph</span>
                  <span class='arguments'>(*associations)</span>
                </div>
                <div class='description'>
                  
                  <p>The secondary eager loading method.  Loads all associations in a single
                  query. This method should only be used if you need to filter or order based
                  on columns in associated tables.</p>
                  
                  <p>This method uses <code>Dataset#graph</code> to create appropriate aliases
                  for columns in all the tables.  Then it uses the graphâ€™s metadata to build
                  the associations from the single hash, and finally replaces the array of
                  hashes with an array model objects inside all.</p>
                  
                  <p>Be very careful when using this with multiple one_to_many or many_to_many
                  associations, as you can create large cartesian products.  If you must
                  graph multiple one_to_many and many_to_many associations, make sure your
                  filters are narrow if you have a large database.</p>
                  
                  <p>Each associationâ€™s order, if definied, is respected.
                  <code>eager_graph</code> probably wonâ€™t work correctly on a limited
                  dataset, unless you are only graphing many_to_one and one_to_one
                  associations.</p>
                  
                  <p>Does not use the block defined for the association, since it does a single
                  query for all objects.  You can use the :graph_* association options to
                  modify the <a href="../../SQL.html">SQL</a> query.</p>
                  
                  <p>Like <code>eager</code>, you need to call <code>all</code> on the dataset
                  for the eager loading to work.  If you just call <code>each</code>, it will
                  yield plain hashes, each containing all columns from all the tables.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-eager_graph-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-eager_graph-source'><span class="ruby-comment"># File lib/sequel/model/associations.rb, line 1946</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">eager_graph</span>(*<span class="ruby-identifier">associations</span>)&#x000A;  <span class="ruby-keyword">if</span> <span class="ruby-identifier">eg</span> = <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:eager_graph</span>]&#x000A;    <span class="ruby-identifier">eg</span> = <span class="ruby-identifier">eg</span>.<span class="ruby-identifier">dup</span>&#x000A;    [<span class="ruby-value">:requirements</span>, <span class="ruby-value">:reflections</span>, <span class="ruby-value">:reciprocals</span>].<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">k</span><span class="ruby-operator">|</span> <span class="ruby-identifier">eg</span>[<span class="ruby-identifier">k</span>] = <span class="ruby-identifier">eg</span>[<span class="ruby-identifier">k</span>].<span class="ruby-identifier">dup</span>}&#x000A;    <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">clone</span>(<span class="ruby-value">:eager_graph=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">eg</span>)&#x000A;    <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">eager_graph_associations</span>(<span class="ruby-identifier">ds</span>, <span class="ruby-identifier">model</span>, <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:eager_graph</span>][<span class="ruby-value">:master</span>], [], *<span class="ruby-identifier">associations</span>)&#x000A;  <span class="ruby-keyword">else</span>&#x000A;    <span class="ruby-comment"># Each of the following have a symbol key for the table alias, with the following values: </span>&#x000A;    <span class="ruby-comment"># :reciprocals - the reciprocal instance variable to use for this association</span>&#x000A;    <span class="ruby-comment"># :reflections - AssociationReflection instance related to this association</span>&#x000A;    <span class="ruby-comment"># :requirements - array of requirements for this association</span>&#x000A;    <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">clone</span>(<span class="ruby-value">:eager_graph=</span><span class="ruby-operator">&gt;</span>{<span class="ruby-value">:requirements=</span><span class="ruby-operator">&gt;</span>{}, <span class="ruby-value">:master=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">alias_symbol</span>(<span class="ruby-identifier">first_source</span>), <span class="ruby-value">:reflections=</span><span class="ruby-operator">&gt;</span>{}, <span class="ruby-value">:reciprocals=</span><span class="ruby-operator">&gt;</span>{}, <span class="ruby-value">:cartesian_product_number=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">0</span>, <span class="ruby-value">:row_proc=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">row_proc</span>})&#x000A;    <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">eager_graph_associations</span>(<span class="ruby-identifier">ds</span>, <span class="ruby-identifier">model</span>, <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:eager_graph</span>][<span class="ruby-value">:master</span>], [], *<span class="ruby-identifier">associations</span>).&#x000A;      <span class="ruby-identifier">naked</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method public-instance' id='method-method-i-ungraphed'>
                <a name='method-i-ungraphed'></a>
                <div class='synopsis'>
                  <span class='name'>ungraphed</span>
                  <span class='arguments'>()</span>
                </div>
                <div class='description'>
                  
                  <p>Do not attempt to split the result set into associations, just return
                  results as simple objects.  This is useful if you want to use <a
                  href="DatasetMethods.html#method-i-eager_graph">#eager_graph</a> as a
                  shortcut to have all of the joins and aliasing set up, but want to do
                  something else with the dataset.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-ungraphed-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-ungraphed-source'><span class="ruby-comment"># File lib/sequel/model/associations.rb, line 1967</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">ungraphed</span>&#x000A;  <span class="ruby-identifier">ds</span> = <span class="ruby-keyword">super</span>.<span class="ruby-identifier">clone</span>(<span class="ruby-value">:eager_graph=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">nil</span>)&#x000A;  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">eg</span> = <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:eager_graph</span>]) <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">rp</span> = <span class="ruby-identifier">eg</span>[<span class="ruby-value">:row_proc</span>])&#x000A;    <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">row_proc</span> = <span class="ruby-identifier">rp</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-identifier">ds</span>&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <h2>Protected Instance methods</h2>
              <div class='method protected-instance' id='method-method-i-eager_graph_association'>
                <a name='method-i-eager_graph_association'></a>
                <div class='synopsis'>
                  <span class='name'>eager_graph_association</span>
                  <span class='arguments'>(ds, model, ta, requirements, r, *associations)</span>
                </div>
                <div class='description'>
                  
                  <p>Call graph on the association with the correct arguments, update the <a
                  href="DatasetMethods.html#method-i-eager_graph">#eager_graph</a> data
                  structure, and recurse into <a
                  href="DatasetMethods.html#method-i-eager_graph_associations">#eager_graph_associations</a>
                  if there are any passed in associations (which would be dependencies of the
                  current association)</p>
                  
                  <p>Arguments:</p>
                  <dl class="rdoc-list note-list"><dt>ds 
                  <dd>
                  <p>Current dataset</p>
                  </dd><dt>model 
                  <dd>
                  <p>Current <a href="../../Model.html">Model</a></p>
                  </dd><dt>ta 
                  <dd>
                  <p>table_alias used for the parent association</p>
                  </dd><dt>requirements 
                  <dd>
                  <p>an array, used as a stack for requirements</p>
                  </dd><dt>r 
                  <dd>
                  <p>association reflection for the current association, or an <a
                  href="../../SQL/AliasedExpression.html">SQL::AliasedExpression</a> with the
                  reflection as the expression and the alias base as the aliaz.</p>
                  </dd><dt>*associations 
                  <dd>
                  <p>any associations dependent on this one</p>
                  </dd></dl>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-eager_graph_association-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-eager_graph_association-source'><span class="ruby-comment"># File lib/sequel/model/associations.rb, line 1990</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">eager_graph_association</span>(<span class="ruby-identifier">ds</span>, <span class="ruby-identifier">model</span>, <span class="ruby-identifier">ta</span>, <span class="ruby-identifier">requirements</span>, <span class="ruby-identifier">r</span>, *<span class="ruby-identifier">associations</span>)&#x000A;  <span class="ruby-keyword">if</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>)&#x000A;    <span class="ruby-identifier">alias_base</span> = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">aliaz</span>&#x000A;    <span class="ruby-identifier">r</span> = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">expression</span>&#x000A;  <span class="ruby-keyword">else</span>&#x000A;    <span class="ruby-identifier">alias_base</span> = <span class="ruby-identifier">r</span>[<span class="ruby-value">:graph_alias_base</span>]&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-identifier">assoc_table_alias</span> = <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">unused_table_alias</span>(<span class="ruby-identifier">alias_base</span>)&#x000A;  <span class="ruby-identifier">loader</span> = <span class="ruby-identifier">r</span>[<span class="ruby-value">:eager_grapher</span>]&#x000A;  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">associations</span>.<span class="ruby-identifier">empty?</span>&#x000A;    <span class="ruby-keyword">if</span> <span class="ruby-identifier">associations</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:call</span>)&#x000A;      <span class="ruby-identifier">callback</span> = <span class="ruby-identifier">associations</span>.<span class="ruby-identifier">first</span>&#x000A;      <span class="ruby-identifier">associations</span> = {}&#x000A;    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">associations</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">assocs</span> = <span class="ruby-identifier">associations</span>.<span class="ruby-identifier">first</span>).<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Hash</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">assocs</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">pr_assoc</span> = <span class="ruby-identifier">assocs</span>.<span class="ruby-identifier">to_a</span>.<span class="ruby-identifier">first</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">pr_assoc</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:call</span>)&#x000A;      <span class="ruby-identifier">callback</span>, <span class="ruby-identifier">assoc</span> = <span class="ruby-identifier">pr_assoc</span>&#x000A;      <span class="ruby-identifier">associations</span> = <span class="ruby-identifier">assoc</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">assoc</span> <span class="ruby-operator">:</span> [<span class="ruby-identifier">assoc</span>]&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">loader</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">:self</span>=<span class="ruby-operator">&gt;</span><span class="ruby-identifier">ds</span>, <span class="ruby-value">:table_alias=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">assoc_table_alias</span>, <span class="ruby-value">:implicit_qualifier=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">ta</span>, <span class="ruby-value">:callback=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">callback</span>)&#x000A;  <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">order_more</span>(*<span class="ruby-identifier">qualified_expression</span>(<span class="ruby-identifier">r</span>[<span class="ruby-value">:order</span>], <span class="ruby-identifier">assoc_table_alias</span>)) <span class="ruby-keyword">if</span> <span class="ruby-identifier">r</span>[<span class="ruby-value">:order</span>] <span class="ruby-keyword">and</span> <span class="ruby-identifier">r</span>[<span class="ruby-value">:order_eager_graph</span>]&#x000A;  <span class="ruby-identifier">eager_graph</span> = <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:eager_graph</span>]&#x000A;  <span class="ruby-identifier">eager_graph</span>[<span class="ruby-value">:requirements</span>][<span class="ruby-identifier">assoc_table_alias</span>] = <span class="ruby-identifier">requirements</span>.<span class="ruby-identifier">dup</span>&#x000A;  <span class="ruby-identifier">eager_graph</span>[<span class="ruby-value">:reflections</span>][<span class="ruby-identifier">assoc_table_alias</span>] = <span class="ruby-identifier">r</span>&#x000A;  <span class="ruby-identifier">eager_graph</span>[<span class="ruby-value">:cartesian_product_number</span>] <span class="ruby-operator">+=</span> <span class="ruby-identifier">r</span>[<span class="ruby-value">:cartesian_product_number</span>] <span class="ruby-operator">||</span> <span class="ruby-value">2</span>&#x000A;  <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">eager_graph_associations</span>(<span class="ruby-identifier">ds</span>, <span class="ruby-identifier">r</span>.<span class="ruby-identifier">associated_class</span>, <span class="ruby-identifier">assoc_table_alias</span>, <span class="ruby-identifier">requirements</span> <span class="ruby-operator">+</span> [<span class="ruby-identifier">assoc_table_alias</span>], *<span class="ruby-identifier">associations</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">associations</span>.<span class="ruby-identifier">empty?</span>&#x000A;  <span class="ruby-identifier">ds</span>&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method protected-instance' id='method-method-i-eager_graph_associations'>
                <a name='method-i-eager_graph_associations'></a>
                <div class='synopsis'>
                  <span class='name'>eager_graph_associations</span>
                  <span class='arguments'>(ds, model, ta, requirements, *associations)</span>
                </div>
                <div class='description'>
                  
                  <p>Check the associations are valid for the given model. Call <a
                  href="DatasetMethods.html#method-i-eager_graph_association">#eager_graph_association</a>
                  on each association.</p>
                  
                  <p>Arguments:</p>
                  <dl class="rdoc-list note-list"><dt>ds 
                  <dd>
                  <p>Current dataset</p>
                  </dd><dt>model 
                  <dd>
                  <p>Current <a href="../../Model.html">Model</a></p>
                  </dd><dt>ta 
                  <dd>
                  <p>table_alias used for the parent association</p>
                  </dd><dt>requirements 
                  <dd>
                  <p>an array, used as a stack for requirements</p>
                  </dd><dt>*associations 
                  <dd>
                  <p>the associations to add to the graph</p>
                  </dd></dl>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-eager_graph_associations-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-eager_graph_associations-source'><span class="ruby-comment"># File lib/sequel/model/associations.rb, line 2027</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">eager_graph_associations</span>(<span class="ruby-identifier">ds</span>, <span class="ruby-identifier">model</span>, <span class="ruby-identifier">ta</span>, <span class="ruby-identifier">requirements</span>, *<span class="ruby-identifier">associations</span>)&#x000A;  <span class="ruby-keyword">return</span> <span class="ruby-identifier">ds</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">associations</span>.<span class="ruby-identifier">empty?</span>&#x000A;  <span class="ruby-identifier">associations</span>.<span class="ruby-identifier">flatten</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">association</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">ds</span> = <span class="ruby-keyword">case</span> <span class="ruby-identifier">association</span>&#x000A;    <span class="ruby-keyword">when</span> <span class="ruby-constant">Symbol</span>, <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>&#x000A;      <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">eager_graph_association</span>(<span class="ruby-identifier">ds</span>, <span class="ruby-identifier">model</span>, <span class="ruby-identifier">ta</span>, <span class="ruby-identifier">requirements</span>, <span class="ruby-identifier">eager_graph_check_association</span>(<span class="ruby-identifier">model</span>, <span class="ruby-identifier">association</span>))&#x000A;    <span class="ruby-keyword">when</span> <span class="ruby-constant">Hash</span>&#x000A;      <span class="ruby-identifier">association</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">assoc</span>, <span class="ruby-identifier">assoc_assocs</span><span class="ruby-operator">|</span>&#x000A;        <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">eager_graph_association</span>(<span class="ruby-identifier">ds</span>, <span class="ruby-identifier">model</span>, <span class="ruby-identifier">ta</span>, <span class="ruby-identifier">requirements</span>, <span class="ruby-identifier">eager_graph_check_association</span>(<span class="ruby-identifier">model</span>, <span class="ruby-identifier">assoc</span>), <span class="ruby-identifier">assoc_assocs</span>)&#x000A;      <span class="ruby-keyword">end</span>&#x000A;      <span class="ruby-identifier">ds</span>&#x000A;    <span class="ruby-keyword">else</span>&#x000A;      <span class="ruby-identifier">raise</span>(<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Error</span>, <span class="ruby-string">'Associations must be in the form of a symbol or hash'</span>)&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-identifier">ds</span>&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method protected-instance' id='method-method-i-eager_graph_build_associations'>
                <a name='method-i-eager_graph_build_associations'></a>
                <div class='synopsis'>
                  <span class='name'>eager_graph_build_associations</span>
                  <span class='arguments'>(hashes)</span>
                </div>
                <div class='description'>
                  
                  <p>Replace the array of plain hashes with an array of model objects will all
                  eager_graphed associations set in the associations cache for each object.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-eager_graph_build_associations-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-eager_graph_build_associations-source'><span class="ruby-comment"># File lib/sequel/model/associations.rb, line 2047</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier">eager_graph_build_associations</span>(<span class="ruby-identifier">hashes</span>)&#x000A;  <span class="ruby-identifier">hashes</span>.<span class="ruby-identifier">replace</span>(<span class="ruby-constant">EagerGraphLoader</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>).<span class="ruby-identifier">load</span>(<span class="ruby-identifier">hashes</span>))&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
