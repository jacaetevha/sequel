<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>README.rdoc</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='file' id='wrapper'>
      <div class='header'>
        <h1 class='name'>README.rdoc</h1>
        <div class='paths'>
          README.rdoc
        </div>
        <div class='last-update'>
          Last Update:
          <span class='datetime'>2013-11-08 08:08:17 -0500</span>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <h2 id="label-Sequel%3A+The+Database+Toolkit+for+Ruby">Sequel: The Database Toolkit for Ruby</h2>
            
            <p><a href="../classes/Sequel.html">Sequel</a> is a simple, flexible, and
            powerful SQL database access toolkit for Ruby.</p>
            <ul><li>
            <p><a href="../classes/Sequel.html">Sequel</a> provides thread safety,
            connection pooling and a concise DSL for constructing SQL queries and table
            schemas.</p>
            </li><li>
            <p><a href="../classes/Sequel.html">Sequel</a> includes a comprehensive ORM
            layer for mapping records to Ruby objects and handling associated records.</p>
            </li><li>
            <p><a href="../classes/Sequel.html">Sequel</a> supports advanced database
            features such as prepared statements, bound variables, stored procedures,
            savepoints, two-phase commit, transaction isolation, master/slave
            configurations, and database sharding.</p>
            </li><li>
            <p><a href="../classes/Sequel.html">Sequel</a> currently has adapters for ADO,
            Amalgalite, CUBRID, DataObjects, DB2, DBI, Firebird, IBM_DB, Informix,
            JDBC, MySQL, Mysql2, ODBC, OpenBase, Oracle, PostgreSQL, SQLAnywhere,
            SQLite3, Swift, and TinyTDS.</p>
            </li></ul>
            
            <h2 id="label-Resources">Resources</h2>
            <ul><li>
            <p><a target="_top" href="http://sequel.rubyforge.org">Website</a></p>
            </li><li>
            <p><a target="_top" href="http://sequel.heroku.com">Blog</a></p>
            </li><li>
            <p><a target="_top" href="http://github.com/jeremyevans/sequel">Source code</a></p>
            </li><li>
            <p><a target="_top" href="http://github.com/jeremyevans/sequel/issues">Bug tracking</a></p>
            </li><li>
            <p><a target="_top" href="http://groups.google.com/group/sequel-talk">Google group</a></p>
            </li><li>
            <p><a target="_top" href="http://sequel.rubyforge.org/rdoc">RDoc</a></p>
            </li></ul>
            
            <p>To check out the source code:</p>
            
            <pre>git clone git://github.com/jeremyevans/sequel.git</pre>
            
            <h3 id="label-Contact">Contact</h3>
            
            <p>If you have any comments or suggestions please post to the Google group.</p>
            
            <h2 id="label-Installation">Installation</h2>
            
            <pre>sudo gem install sequel</pre>
            
            <h2 id="label-A+Short+Example">A Short Example</h2>
            
            <pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">'sequel'</span>&#x000A;&#x000A;<span class="ruby-constant">DB</span> = <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">sqlite</span> <span class="ruby-comment"># memory database</span>&#x000A;&#x000A;<span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span> :<span class="ruby-identifier">items</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">primary_key</span> :<span class="ruby-identifier">id</span>&#x000A;  <span class="ruby-constant">String</span> :<span class="ruby-identifier">name</span>&#x000A;  <span class="ruby-constant">Float</span> :<span class="ruby-identifier">price</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-identifier">items</span> = <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">items</span>] <span class="ruby-comment"># Create a dataset</span>&#x000A;&#x000A;<span class="ruby-comment"># Populate the table</span>&#x000A;<span class="ruby-identifier">items</span>.<span class="ruby-identifier">insert</span>(:<span class="ruby-identifier">name</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'abc'</span>, :<span class="ruby-identifier">price</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">rand</span> * <span class="ruby-value">100</span>)&#x000A;<span class="ruby-identifier">items</span>.<span class="ruby-identifier">insert</span>(:<span class="ruby-identifier">name</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'def'</span>, :<span class="ruby-identifier">price</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">rand</span> * <span class="ruby-value">100</span>)&#x000A;<span class="ruby-identifier">items</span>.<span class="ruby-identifier">insert</span>(:<span class="ruby-identifier">name</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'ghi'</span>, :<span class="ruby-identifier">price</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">rand</span> * <span class="ruby-value">100</span>)&#x000A;&#x000A;<span class="ruby-comment"># Print out the number of records</span>&#x000A;<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;Item count: #{items.count}&quot;</span>&#x000A;&#x000A;<span class="ruby-comment"># Print out the average price</span>&#x000A;<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;The average price is: #{items.avg(:price)}&quot;</span></pre>
            
            <h2 id="label-The+Sequel+Console">The <a href="../classes/Sequel.html">Sequel</a> Console</h2>
            
            <p><a href="../classes/Sequel.html">Sequel</a> includes an IRB console for
            quick access to databases (usually referred to as <code>bin/sequel</code>).
            You can use it like this:</p>
            
            <pre>sequel sqlite://test.db # test.db in current directory</pre>
            
            <p>You get an IRB session with the database object stored in DB.</p>
            
            <p>In addition to providing an IRB shell (the default behavior), bin/sequel
            also has support for migrating databases, dumping schema migrations, and
            copying databases.  See the <a href="doc/bin_sequel_rdoc.html">bin/sequel
            guide</a> for more details.</p>
            
            <h2 id="label-An+Introduction">An Introduction</h2>
            
            <p><a href="../classes/Sequel.html">Sequel</a> is designed to take the hassle
            away from connecting to databases and manipulating them. <a
            href="../classes/Sequel.html">Sequel</a> deals with all the boring stuff
            like maintaining connections, formatting SQL correctly and fetching records
            so you can concentrate on your application.</p>
            
            <p><a href="../classes/Sequel.html">Sequel</a> uses the concept of datasets to
            retrieve data. A Dataset object encapsulates an SQL query and supports
            chainability, letting you fetch data using a convenient Ruby DSL that is
            both concise and flexible.</p>
            
            <p>For example, the following one-liner returns the average GDP for countries
            in the middle east region:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">countries</span>].<span class="ruby-identifier">filter</span>(:<span class="ruby-identifier">region</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'Middle East'</span>).<span class="ruby-identifier">avg</span>(:<span class="ruby-constant">GDP</span>)</pre>
            
            <p>Which is equivalent to:</p>
            
            <pre>SELECT avg(GDP) FROM countries WHERE region = 'Middle East'</pre>
            
            <p>Since datasets retrieve records only when needed, they can be stored and
            later reused. Records are fetched as hashes (or custom model objects), and
            are accessed using an <code>Enumerable</code> interface:</p>
            
            <pre class="ruby"><span class="ruby-identifier">middle_east</span> = <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">countries</span>].<span class="ruby-identifier">filter</span>(:<span class="ruby-identifier">region</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'Middle East'</span>)&#x000A;<span class="ruby-identifier">middle_east</span>.<span class="ruby-identifier">order</span>(:<span class="ruby-identifier">name</span>).<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">r</span>[:<span class="ruby-identifier">name</span>]}</pre>
            
            <p><a href="../classes/Sequel.html">Sequel</a> also offers convenience methods
            for extracting data from Datasets, such as an extended <code>map</code>
            method:</p>
            
            <pre class="ruby"><span class="ruby-identifier">middle_east</span>.<span class="ruby-identifier">map</span>(:<span class="ruby-identifier">name</span>) <span class="ruby-comment">#=&gt; ['Egypt', 'Turkey', 'Israel', ...]</span></pre>
            
            <p>Or getting results as a hash via <code>to_hash</code>, with one column as
            key and another as value:</p>
            
            <pre class="ruby"><span class="ruby-identifier">middle_east</span>.<span class="ruby-identifier">to_hash</span>(:<span class="ruby-identifier">name</span>, :<span class="ruby-identifier">area</span>) <span class="ruby-comment">#=&gt; {'Israel' =&gt; 20000, 'Turkey' =&gt; 120000, ...}</span></pre>
            
            <h2 id="label-Getting+Started">Getting Started</h2>
            
            <h3 id="label-Connecting+to+a+database">Connecting to a database</h3>
            
            <p>To connect to a database you simply provide <code>Sequel.connect</code>
            with a URL:</p>
            
            <pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">'sequel'</span>&#x000A;<span class="ruby-constant">DB</span> = <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">connect</span>(<span class="ruby-string">'sqlite://blog.db'</span>)</pre>
            
            <p>The connection URL can also include such stuff as the user name, password,
            and port:</p>
            
            <pre>DB = Sequel.connect('postgres://user:password@host:port/database_name')</pre>
            
            <p>You can also specify optional parameters, such as the connection pool size,
            or loggers for logging SQL queries:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span> = <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">connect</span>(<span class="ruby-string">&quot;postgres://user:password@host:port/database_name&quot;</span>,&#x000A;  :<span class="ruby-identifier">max_connections</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">10</span>, :<span class="ruby-identifier">logger</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-constant">Logger</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'log/db.log'</span>))</pre>
            
            <p>You can specify a block to connect, which will disconnect from the database
            after it completes:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">connect</span>(<span class="ruby-string">'postgres://user:password@host:port/database_name'</span>){<span class="ruby-operator">|</span><span class="ruby-identifier">db</span><span class="ruby-operator">|</span> <span class="ruby-identifier">db</span>[:<span class="ruby-identifier">posts</span>].<span class="ruby-identifier">delete</span>}</pre>
            
            <h3 id="label-The+DB+convention">The DB convention</h3>
            
            <p>Throughout Sequel’s documentation, you will see the <code>DB</code>
            constant used to refer to the <a
            href="../classes/Sequel/Database.html">Sequel::Database</a> instance you
            create. This reflects the recommendation that for an app with a single <a
            href="../classes/Sequel/Database.html">Sequel::Database</a> instance, the
            <a href="../classes/Sequel.html">Sequel</a> convention is to store the
            instance in the <code>DB</code> constant.  This is just a convention, it’s
            not required, but it is recommended.</p>
            
            <p>Note that some frameworks that use <a
            href="../classes/Sequel.html">Sequel</a> may create the <a
            href="../classes/Sequel/Database.html">Sequel::Database</a> instance for
            you, and you might not know how to access it.  In most cases, you can
            access the <a href="../classes/Sequel/Database.html">Sequel::Database</a>
            instance through <code>Sequel::Model.db</code>.</p>
            
            <h3 id="label-Arbitrary+SQL+queries">Arbitrary SQL queries</h3>
            
            <p>You can execute arbitrary SQL code using <code>Database#run</code>:</p>
            
            <pre>DB.run(&quot;create table t (a text, b text)&quot;)&#x000A;DB.run(&quot;insert into t values ('a', 'b')&quot;)</pre>
            
            <p>You can also create datasets based on raw SQL:</p>
            
            <pre>dataset = DB['select id from items']&#x000A;dataset.count # will return the number of records in the result set&#x000A;dataset.map(:id) # will return an array containing all values of the id column in the result set</pre>
            
            <p>You can also fetch records with raw SQL through the dataset:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>[<span class="ruby-string">'select * from items'</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">row</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">p</span> <span class="ruby-identifier">row</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>You can use placeholders in your SQL string as well:</p>
            
            <pre class="ruby"><span class="ruby-identifier">name</span> = <span class="ruby-string">'Jim'</span>&#x000A;<span class="ruby-constant">DB</span>[<span class="ruby-string">'select * from items where name = ?'</span>, <span class="ruby-identifier">name</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">row</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">p</span> <span class="ruby-identifier">row</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-Getting+Dataset+Instances">Getting Dataset Instances</h3>
            
            <p>Datasets are the primary way records are retrieved and manipulated.  They
            are generally created via the <code>Database#from</code> or
            <code>Database#[]</code> methods:</p>
            
            <pre>posts = DB.from(:posts)&#x000A;posts = DB[:posts] # same</pre>
            
            <p>Datasets will only fetch records when you tell them to. They can be
            manipulated to filter records, change ordering, join tables, etc..</p>
            
            <h3 id="label-Retrieving+Records">Retrieving Records</h3>
            
            <p>You can retrieve all records by using the <code>all</code> method:</p>
            
            <pre>posts.all&#x000A;# SELECT * FROM posts</pre>
            
            <p>The all method returns an array of hashes, where each hash corresponds to a
            record.</p>
            
            <p>You can also iterate through records one at a time using <code>each</code>:</p>
            
            <pre class="ruby"><span class="ruby-identifier">posts</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">row</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">row</span>}</pre>
            
            <p>Or perform more advanced stuff:</p>
            
            <pre class="ruby"><span class="ruby-identifier">names_and_dates</span> = <span class="ruby-identifier">posts</span>.<span class="ruby-identifier">map</span>([:<span class="ruby-identifier">name</span>, :<span class="ruby-identifier">date</span>])&#x000A;<span class="ruby-identifier">old_posts</span>, <span class="ruby-identifier">recent_posts</span> = <span class="ruby-identifier">posts</span>.<span class="ruby-identifier">partition</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">r</span>[:<span class="ruby-identifier">date</span>] <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Date</span>.<span class="ruby-identifier">today</span> <span class="ruby-operator">-</span> <span class="ruby-value">7</span>}</pre>
            
            <p>You can also retrieve the first record in a dataset:</p>
            
            <pre>posts.first&#x000A;# SELECT * FROM posts LIMIT 1</pre>
            
            <p>Or retrieve a single record with a specific value:</p>
            
            <pre class="ruby"><span class="ruby-identifier">posts</span>[:<span class="ruby-identifier">id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>]&#x000A;<span class="ruby-comment"># SELECT * FROM posts WHERE id = 1 LIMIT 1</span></pre>
            
            <p>If the dataset is ordered, you can also ask for the last record:</p>
            
            <pre>posts.order(:stamp).last&#x000A;# SELECT * FROM posts ORDER BY stamp DESC LIMIT 1</pre>
            
            <h3 id="label-Filtering+Records">Filtering Records</h3>
            
            <p>An easy way to filter records is to provide a hash of values to match to
            <code>where</code>:</p>
            
            <pre class="ruby"><span class="ruby-identifier">my_posts</span> = <span class="ruby-identifier">posts</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">category</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'ruby'</span>, :<span class="ruby-identifier">author</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'david'</span>)&#x000A;<span class="ruby-comment"># WHERE category = 'ruby' AND author = 'david'</span></pre>
            
            <p>You can also specify ranges:</p>
            
            <pre class="ruby"><span class="ruby-identifier">my_posts</span> = <span class="ruby-identifier">posts</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">stamp</span> =<span class="ruby-operator">&gt;</span> (<span class="ruby-constant">Date</span>.<span class="ruby-identifier">today</span> <span class="ruby-operator">-</span> <span class="ruby-value">14</span>)<span class="ruby-operator">..</span>(<span class="ruby-constant">Date</span>.<span class="ruby-identifier">today</span> <span class="ruby-operator">-</span> <span class="ruby-value">7</span>))&#x000A;<span class="ruby-comment"># WHERE stamp &gt;= '2010-06-30' AND stamp &lt;= '2010-07-07'</span></pre>
            
            <p>Or arrays of values:</p>
            
            <pre class="ruby"><span class="ruby-identifier">my_posts</span> = <span class="ruby-identifier">posts</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">category</span> =<span class="ruby-operator">&gt;</span> [<span class="ruby-string">'ruby'</span>, <span class="ruby-string">'postgres'</span>, <span class="ruby-string">'linux'</span>])&#x000A;<span class="ruby-comment"># WHERE category IN ('ruby', 'postgres', 'linux')</span></pre>
            
            <p><a href="../classes/Sequel.html">Sequel</a> also accepts expressions:</p>
            
            <pre>my_posts = posts.where{stamp &gt; Date.today &lt;&lt; 1}&#x000A;# WHERE stamp &gt; '2010-06-14'</pre>
            
            <p>Some adapters will also let you specify Regexps:</p>
            
            <pre class="ruby"><span class="ruby-identifier">my_posts</span> = <span class="ruby-identifier">posts</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">category</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-regexp">/ruby/</span>)&#x000A;<span class="ruby-comment"># WHERE category ~* 'ruby'</span></pre>
            
            <p>You can also use an inverse filter via <code>exclude</code>:</p>
            
            <pre class="ruby"><span class="ruby-identifier">my_posts</span> = <span class="ruby-identifier">posts</span>.<span class="ruby-identifier">exclude</span>(:<span class="ruby-identifier">category</span> =<span class="ruby-operator">&gt;</span> [<span class="ruby-string">'ruby'</span>, <span class="ruby-string">'postgres'</span>, <span class="ruby-string">'linux'</span>])&#x000A;<span class="ruby-comment"># WHERE category NOT IN ('ruby', 'postgres', 'linux')</span></pre>
            
            <p>You can also specify a custom WHERE clause using a string:</p>
            
            <pre>posts.where('stamp IS NOT NULL')&#x000A;# WHERE stamp IS NOT NULL</pre>
            
            <p>You can use parameters in your string, as well:</p>
            
            <pre>author_name = 'JKR'&#x000A;posts.where('(stamp &lt; ?) AND (author != ?)', Date.today - 3, author_name)&#x000A;# WHERE (stamp &lt; '2010-07-11') AND (author != 'JKR')</pre>
            
            <p>Datasets can also be used as subqueries:</p>
            
            <pre>DB[:items].where('price &gt; ?', DB[:items].select{avg(price) + 100})&#x000A;# WHERE price &gt; (SELECT avg(price) + 100 FROM items)</pre>
            
            <p>After filtering, you can retrieve the matching records by using any of the
            retrieval methods:</p>
            
            <pre class="ruby"><span class="ruby-identifier">my_posts</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">row</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">row</span>}</pre>
            
            <p>See the <a href="doc/dataset_filtering_rdoc.html">Dataset Filtering</a>
            file for more details.</p>
            
            <h3 id="label-Security">Security</h3>
            
            <p>Designing apps with security in mind is a best practice. Please read the <a
            href="doc/security_rdoc.html">Security Guide</a> for details on security
            issues that you should be aware of when using <a
            href="../classes/Sequel.html">Sequel</a>.</p>
            
            <h3 id="label-Summarizing+Records">Summarizing Records</h3>
            
            <p>Counting records is easy using <code>count</code>:</p>
            
            <pre>posts.where(:category.like('%ruby%')).count&#x000A;# SELECT COUNT(*) FROM posts WHERE category LIKE '%ruby%'</pre>
            
            <p>And you can also query maximum/minimum values via <code>max</code> and
            <code>min</code>:</p>
            
            <pre>max = DB[:history].max(:value)&#x000A;# SELECT max(value) FROM history&#x000A;min = DB[:history].min(:value)&#x000A;# SELECT min(value) FROM history</pre>
            
            <p>Or calculate a sum or average via <code>sum</code> and <code>avg</code>:</p>
            
            <pre>sum = DB[:items].sum(:price)&#x000A;# SELECT sum(price) FROM items&#x000A;avg = DB[:items].avg(:price)&#x000A;# SELECT avg(price) FROM items</pre>
            
            <h3 id="label-Ordering+Records">Ordering Records</h3>
            
            <p>Ordering datasets is simple using <code>order</code>:</p>
            
            <pre>posts.order(:stamp)&#x000A;# ORDER BY stamp&#x000A;posts.order(:stamp, :name)&#x000A;# ORDER BY stamp, name</pre>
            
            <p>Chaining <code>order</code> doesn’t work the same as <code>where</code>:</p>
            
            <pre>posts.order(:stamp).order(:name)&#x000A;# ORDER BY name</pre>
            
            <p>The <code>order_append</code> method chains this way, though:</p>
            
            <pre>posts.order(:stamp).order_append(:name)&#x000A;# ORDER BY stamp, name</pre>
            
            <p>The <code>order_prepend</code> method can be used as well:</p>
            
            <pre>posts.order(:stamp).order_prepend(:name)&#x000A;# ORDER BY name, stamp</pre>
            
            <p>You can also specify descending order:</p>
            
            <pre>posts.reverse_order(:stamp)&#x000A;# ORDER BY stamp DESC&#x000A;posts.order(Sequel.desc(:stamp))&#x000A;# ORDER BY stamp DESC</pre>
            
            <h3 id="label-Core+Extensions">Core Extensions</h3>
            
            <p>Note the use of <code>Sequel.desc(:stamp)</code> in the above example. 
            Much of Sequel’s DSL uses this style, calling methods on the <a
            href="../classes/Sequel.html">Sequel</a> module that return SQL expression
            objects.  <a href="../classes/Sequel.html">Sequel</a> also ships with a <a
            href="doc/core_extensions_rdoc.html">core_extensions extension</a> that
            integrates Sequel’s DSL better into the ruby language, allowing you to
            write:</p>
            
            <pre>:stamp.desc</pre>
            
            <p>instead of:</p>
            
            <pre>Sequel.desc(:stamp)</pre>
            
            <h3 id="label-Selecting+Columns">Selecting Columns</h3>
            
            <p>Selecting specific columns to be returned is also simple using
            <code>select</code>:</p>
            
            <pre>posts.select(:stamp)&#x000A;# SELECT stamp FROM posts&#x000A;posts.select(:stamp, :name)&#x000A;# SELECT stamp, name FROM posts</pre>
            
            <p>Chaining <code>select</code> works like <code>order</code>, not
            <code>where</code>:</p>
            
            <pre>posts.select(:stamp).select(:name)&#x000A;# SELECT name FROM posts</pre>
            
            <p>As you might expect, there is an <code>order_append</code> equivalent for
            <code>select</code> called <code>select_append</code>:</p>
            
            <pre>posts.select(:stamp).select_append(:name)&#x000A;# SELECT stamp, name FROM posts</pre>
            
            <h3 id="label-Deleting+Records">Deleting Records</h3>
            
            <p>Deleting records from the table is done with <code>delete</code>:</p>
            
            <pre>posts.where('stamp &lt; ?', Date.today - 3).delete&#x000A;# DELETE FROM posts WHERE stamp &lt; '2010-07-11'</pre>
            
            <p>Be very careful when deleting, as <code>delete</code> affects all rows in
            the dataset. Call <code>where</code> first and <code>delete</code> second:</p>
            
            <pre># DO THIS:&#x000A;posts.where('stamp &lt; ?', Date.today - 7).delete&#x000A;# NOT THIS:&#x000A;posts.delete.where('stamp &lt; ?', Date.today - 7)</pre>
            
            <h3 id="label-Inserting+Records">Inserting Records</h3>
            
            <p>Inserting records into the table is done with <code>insert</code>:</p>
            
            <pre class="ruby"><span class="ruby-identifier">posts</span>.<span class="ruby-identifier">insert</span>(:<span class="ruby-identifier">category</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'ruby'</span>, :<span class="ruby-identifier">author</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'david'</span>)&#x000A;<span class="ruby-comment"># INSERT INTO posts (category, author) VALUES ('ruby', 'david')</span></pre>
            
            <h3 id="label-Updating+Records">Updating Records</h3>
            
            <p>Updating records in the table is done with <code>update</code>:</p>
            
            <pre class="ruby"><span class="ruby-identifier">posts</span>.<span class="ruby-identifier">where</span>(<span class="ruby-string">'stamp &lt; ?'</span>, <span class="ruby-constant">Date</span>.<span class="ruby-identifier">today</span> <span class="ruby-operator">-</span> <span class="ruby-value">7</span>).<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">state</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'archived'</span>)&#x000A;<span class="ruby-comment"># UPDATE posts SET state = 'archived' WHERE stamp &lt; '2010-07-07'</span></pre>
            
            <p>You can reference table columns when choosing what values to set:</p>
            
            <pre class="ruby"><span class="ruby-identifier">posts</span>.<span class="ruby-identifier">where</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">stamp</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Date</span>.<span class="ruby-identifier">today</span> <span class="ruby-operator">-</span> <span class="ruby-value">7</span>}.<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">backup_number</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-constant">Sequel</span>.<span class="ruby-operator">+</span>(:<span class="ruby-identifier">backup_number</span>, <span class="ruby-value">1</span>))&#x000A;<span class="ruby-comment"># UPDATE posts SET backup_number = backup_number + 1 WHERE stamp &lt; '2010-07-07'</span></pre>
            
            <p>As with <code>delete</code>, <code>update</code> affects all rows in the
            dataset, so <code>where</code> first, <code>update</code> second:</p>
            
            <pre class="ruby"><span class="ruby-comment"># DO THIS:</span>&#x000A;<span class="ruby-identifier">posts</span>.<span class="ruby-identifier">where</span>(<span class="ruby-string">'stamp &lt; ?'</span>, <span class="ruby-constant">Date</span>.<span class="ruby-identifier">today</span> <span class="ruby-operator">-</span> <span class="ruby-value">7</span>).<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">state</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'archived'</span>)&#x000A;<span class="ruby-comment"># NOT THIS:</span>&#x000A;<span class="ruby-identifier">posts</span>.<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">state</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'archived'</span>).<span class="ruby-identifier">where</span>(<span class="ruby-string">'stamp &lt; ?'</span>, <span class="ruby-constant">Date</span>.<span class="ruby-identifier">today</span> <span class="ruby-operator">-</span> <span class="ruby-value">7</span>)</pre>
            
            <h3 id="label-Transactions">Transactions</h3>
            
            <p>You can wrap some code in a database transaction using the
            <code>Database#transaction</code> method:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">transaction</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">posts</span>.<span class="ruby-identifier">insert</span>(:<span class="ruby-identifier">category</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'ruby'</span>, :<span class="ruby-identifier">author</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'david'</span>)&#x000A;  <span class="ruby-identifier">posts</span>.<span class="ruby-identifier">where</span>(<span class="ruby-string">'stamp &lt; ?'</span>, <span class="ruby-constant">Date</span>.<span class="ruby-identifier">today</span> <span class="ruby-operator">-</span> <span class="ruby-value">7</span>).<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">state</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'archived'</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>If the block does not raise an exception, the transaction will be
            committed. If the block does raise an exception, the transaction will be
            rolled back, and the exception will be reraised.  If you want to rollback
            the transaction and not raise an exception outside the block, you can raise
            the <code>Sequel::Rollback</code> exception inside the block:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">transaction</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">posts</span>.<span class="ruby-identifier">insert</span>(:<span class="ruby-identifier">category</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'ruby'</span>, :<span class="ruby-identifier">author</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'david'</span>)&#x000A;  <span class="ruby-keyword">if</span> <span class="ruby-identifier">posts</span>.<span class="ruby-identifier">filter</span>(<span class="ruby-string">'stamp &lt; ?'</span>, <span class="ruby-constant">Date</span>.<span class="ruby-identifier">today</span> <span class="ruby-operator">-</span> <span class="ruby-value">7</span>).<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">state</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'archived'</span>) <span class="ruby-operator">==</span> <span class="ruby-value">0</span>&#x000A;    <span class="ruby-identifier">raise</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Rollback</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-Joining+Tables">Joining Tables</h3>
            
            <p><a href="../classes/Sequel.html">Sequel</a> makes it easy to join tables:</p>
            
            <pre class="ruby"><span class="ruby-identifier">order_items</span> = <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">items</span>].<span class="ruby-identifier">join</span>(:<span class="ruby-identifier">order_items</span>, :<span class="ruby-identifier">item_id</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">id</span>).&#x000A;  <span class="ruby-identifier">where</span>(:<span class="ruby-identifier">order_id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1234</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM items INNER JOIN order_items</span>&#x000A;<span class="ruby-comment"># ON order_items.item_id = items.id </span>&#x000A;<span class="ruby-comment"># WHERE order_id = 1234</span></pre>
            
            <p>The important thing to note here is that item_id is automatically qualified
            with the table being joined, and id is automatically qualified with the
            last table joined.</p>
            
            <p>You can then do anything you like with the dataset:</p>
            
            <pre>order_total = order_items.sum(:price)&#x000A;# SELECT sum(price) FROM items INNER JOIN order_items&#x000A;# ON order_items.item_id = items.id&#x000A;# WHERE order_items.order_id = 1234</pre>
            
            <h2 id="label-Column+references+in+Sequel">Column references in <a href="../classes/Sequel.html">Sequel</a></h2>
            
            <p><a href="../classes/Sequel.html">Sequel</a> expects column names to be
            specified using symbols. In addition, returned hashes always use symbols as
            their keys. This allows you to freely mix literal values and column
            references in many cases. For example, the two following lines produce
            equivalent SQL:</p>
            
            <pre class="ruby"><span class="ruby-identifier">items</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">x</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM items WHERE (x = 1)</span>&#x000A;<span class="ruby-identifier">items</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">1</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">x</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM items WHERE (1 = x)&quot;</span></pre>
            
            <p>Ruby strings are generally treated as SQL strings:</p>
            
            <pre class="ruby"><span class="ruby-identifier">items</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">x</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'x'</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM items WHERE (x = 'x')</span></pre>
            
            <h3 id="label-Qualifying+identifiers+%28column%2Ftable+names%29">Qualifying identifiers (column/table names)</h3>
            
            <p>An identifier in SQL is a name that represents a column, table, or schema.
            Identifiers can be qualified by using the double underscore special
            notation <code>:table__column</code>:</p>
            
            <pre>items.literal(:items__price)&#x000A;# items.price</pre>
            
            <p>Another way to qualify columns is to use the <code>Sequel.qualify</code>
            method:</p>
            
            <pre>items.literal(Sequel.qualify(:items, :price))&#x000A;# items.price</pre>
            
            <p>While it is more common to qualify column identifiers with table
            identifiers, you can also qualify table identifiers with schema identifiers
            to select from a qualified table:</p>
            
            <pre>posts = DB[:some_schema__posts]&#x000A;# SELECT * FROM some_schema.posts</pre>
            
            <h3 id="label-Identifier+aliases">Identifier aliases</h3>
            
            <p>You can also alias identifiers by using the triple undersecore special
            notation <code>:column___alias</code> or
            <code>:table__column___alias</code>:</p>
            
            <pre>items.literal(:price___p)&#x000A;# price AS p&#x000A;items.literal(:items__price___p)&#x000A;# items.price AS p</pre>
            
            <p>Another way to alias columns is to use the <code>Sequel.as</code> method:</p>
            
            <pre>items.literal(Sequel.as(:price, :p))&#x000A;# price AS p</pre>
            
            <p>You can use the <code>Sequel.as</code> method to alias arbitrary
            expressions, not just identifiers:</p>
            
            <pre>items.literal(Sequel.as(DB[:posts].select{max(id)}, :p))&#x000A;# (SELECT max(id) FROM posts) AS p</pre>
            
            <h2 id="label-Sequel+Models"><a href="../classes/Sequel.html">Sequel</a> Models</h2>
            
            <p>A model class wraps a dataset, and an instance of that class wraps a single
            record in the dataset.</p>
            
            <p>Model classes are defined as regular Ruby classes inheriting from
            <code>Sequel::Model</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span> = <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">connect</span>(<span class="ruby-string">'sqlite://blog.db'</span>)&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Post</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>When a model class is created, it parses the schema in the table from the
            database, and automatically sets up accessor methods for all of the columns
            in the table (<a href="../classes/Sequel/Model.html">Sequel::Model</a>
            implements the active record pattern).</p>
            
            <p><a href="../classes/Sequel.html">Sequel</a> model classes assume that the
            table name is an underscored plural of the class name:</p>
            
            <pre class="ruby"><span class="ruby-constant">Post</span>.<span class="ruby-identifier">table_name</span> <span class="ruby-comment">#=&gt; :posts</span></pre>
            
            <p>You can explicitly set the table name or even the dataset used:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Post</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>(:<span class="ruby-identifier">my_posts</span>)&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-comment"># or:</span>&#x000A;<span class="ruby-constant">Post</span>.<span class="ruby-identifier">set_dataset</span> :<span class="ruby-identifier">my_posts</span></pre>
            
            <p>If you call <code>set_dataset</code> with a symbol, it assumes you are
            referring to the table with the same name.  You can also call it with a
            dataset, which will set the defaults for all retrievals for that model:</p>
            
            <pre class="ruby"><span class="ruby-constant">Post</span>.<span class="ruby-identifier">set_dataset</span> <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">my_posts</span>].<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">category</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'ruby'</span>)&#x000A;<span class="ruby-constant">Post</span>.<span class="ruby-identifier">set_dataset</span> <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">my_posts</span>].<span class="ruby-identifier">select</span>(:<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">name</span>).<span class="ruby-identifier">order</span>(:<span class="ruby-identifier">date</span>)</pre>
            
            <h3 id="label-Model+instances">Model instances</h3>
            
            <p>Model instances are identified by a primary key.  In most cases, <a
            href="../classes/Sequel.html">Sequel</a> can query the database to
            determine the primary key, but if not, it defaults to using
            <code>:id</code>. The <code>Model.[]</code> method can be used to fetch
            records by their primary key:</p>
            
            <pre>post = Post[123]</pre>
            
            <p>The <code>pk</code> method is used to retrieve the record’s primary key
            value:</p>
            
            <pre class="ruby"><span class="ruby-identifier">post</span>.<span class="ruby-identifier">pk</span> <span class="ruby-comment">#=&gt; 123</span></pre>
            
            <p><a href="../classes/Sequel.html">Sequel</a> models allow you to use any
            column as a primary key, and even composite keys made from multiple
            columns:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Post</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">set_primary_key</span> [:<span class="ruby-identifier">category</span>, :<span class="ruby-identifier">title</span>]&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-identifier">post</span> = <span class="ruby-constant">Post</span>[<span class="ruby-string">'ruby'</span>, <span class="ruby-string">'hello world'</span>]&#x000A;<span class="ruby-identifier">post</span>.<span class="ruby-identifier">pk</span> <span class="ruby-comment">#=&gt; ['ruby', 'hello world']</span></pre>
            
            <p>You can also define a model class that does not have a primary key via
            <code>no_primary_key</code>, but then you lose the ability to easily update
            and delete records:</p>
            
            <pre>Post.no_primary_key</pre>
            
            <p>A single model instance can also be fetched by specifying a condition:</p>
            
            <pre class="ruby"><span class="ruby-identifier">post</span> = <span class="ruby-constant">Post</span>[:<span class="ruby-identifier">title</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'hello world'</span>]&#x000A;<span class="ruby-identifier">post</span> = <span class="ruby-constant">Post</span>.<span class="ruby-identifier">first</span>{<span class="ruby-identifier">num_comments</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">10</span>}</pre>
            
            <h3 id="label-Acts+like+a+dataset">Acts like a dataset</h3>
            
            <p>A model class forwards many methods to the underlying dataset. This means
            that you can use most of the <code>Dataset</code> API to create customized
            queries that return model instances, e.g.:</p>
            
            <pre class="ruby"><span class="ruby-constant">Post</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">category</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'ruby'</span>).<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">post</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">post</span>}</pre>
            
            <p>You can also manipulate the records in the dataset:</p>
            
            <pre class="ruby"><span class="ruby-constant">Post</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">num_comments</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">7</span>}.<span class="ruby-identifier">delete</span>&#x000A;<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where</span>(<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">like</span>(:<span class="ruby-identifier">title</span>, <span class="ruby-regexp">/ruby/</span>)).<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">category</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'ruby'</span>)</pre>
            
            <h3 id="label-Accessing+record+values">Accessing record values</h3>
            
            <p>A model instance stores its values as a hash with column symbol keys, which
            you can access directly via the <code>values</code> method:</p>
            
            <pre class="ruby"><span class="ruby-identifier">post</span>.<span class="ruby-identifier">values</span> <span class="ruby-comment">#=&gt; {:id =&gt; 123, :category =&gt; 'ruby', :title =&gt; 'hello world'}</span></pre>
            
            <p>You can read the record values as object attributes, assuming the attribute
            names are valid columns in the model’s dataset:</p>
            
            <pre class="ruby"><span class="ruby-identifier">post</span>.<span class="ruby-identifier">id</span> <span class="ruby-comment">#=&gt; 123</span>&#x000A;<span class="ruby-identifier">post</span>.<span class="ruby-identifier">title</span> <span class="ruby-comment">#=&gt; 'hello world'</span></pre>
            
            <p>If the record’s attributes names are not valid columns in the model’s
            dataset (maybe because you used <code>select_append</code> to add a
            computed value column), you can use <code>Model#[]</code> to access the
            values:</p>
            
            <pre class="ruby"><span class="ruby-identifier">post</span>[:<span class="ruby-identifier">id</span>] <span class="ruby-comment">#=&gt; 123</span>&#x000A;<span class="ruby-identifier">post</span>[:<span class="ruby-identifier">title</span>] <span class="ruby-comment">#=&gt; 'hello world'</span></pre>
            
            <p>You can also modify record values using attribute setters or the
            <code>[]=</code> method.</p>
            
            <pre>post.title = 'hey there'&#x000A;post[:title] = 'hey there'</pre>
            
            <p>That will just change the value for the object, it will not update the row
            in the database.  To update the database row, call the <code>save</code>
            method:</p>
            
            <pre>post.save</pre>
            
            <h3 id="label-Mass+assignment">Mass assignment</h3>
            
            <p>You can also set the values for multiple columns in a single method call,
            using one of the mass-assignment methods.  See the <a
            href="doc/mass_assignment_rdoc.html">mass assignment guide</a> for details.
            For example <code>set</code> updates the model’s column values without
            saving:</p>
            
            <pre class="ruby"><span class="ruby-identifier">post</span>.<span class="ruby-identifier">set</span>(:<span class="ruby-identifier">title=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'hey there'</span>, :<span class="ruby-identifier">updated_by=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'foo'</span>)</pre>
            
            <p>and <code>update</code> updates the model’s column values and then saves
            the changes to the database:</p>
            
            <pre class="ruby"><span class="ruby-identifier">post</span>.<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">title</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'hey there'</span>, :<span class="ruby-identifier">updated_by=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'foo'</span>)</pre>
            
            <h3 id="label-Creating+new+records">Creating new records</h3>
            
            <p>New records can be created by calling <code>Model.create</code>:</p>
            
            <pre class="ruby"><span class="ruby-identifier">post</span> = <span class="ruby-constant">Post</span>.<span class="ruby-identifier">create</span>(:<span class="ruby-identifier">title</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'hello world'</span>)</pre>
            
            <p>Another way is to construct a new instance and save it later:</p>
            
            <pre>post = Post.new&#x000A;post.title = 'hello world'&#x000A;post.save</pre>
            
            <p>You can also supply a block to <code>Model.new</code> and
            <code>Model.create</code>:</p>
            
            <pre class="ruby"><span class="ruby-identifier">post</span> = <span class="ruby-constant">Post</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">p</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">p</span>.<span class="ruby-identifier">title</span> = <span class="ruby-string">'hello world'</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-identifier">post</span> = <span class="ruby-constant">Post</span>.<span class="ruby-identifier">create</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">p</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span>.<span class="ruby-identifier">title</span> = <span class="ruby-string">'hello world'</span>}</pre>
            
            <h3 id="label-Hooks">Hooks</h3>
            
            <p>You can execute custom code when creating, updating, or deleting records by
            defining hook methods. The <code>before_create</code> and
            <code>after_create</code> hook methods wrap record creation. The
            <code>before_update</code> and <code>after_update</code> hook methods wrap
            record updating. The <code>before_save</code> and <code>after_save</code>
            hook methods wrap record creation and updating. The
            <code>before_destroy</code> and <code>after_destroy</code> hook methods
            wrap destruction. The <code>before_validation</code> and
            <code>after_validation</code> hook methods wrap validation. Example:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Post</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">after_create</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-identifier">author</span>.<span class="ruby-identifier">increase_post_count</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">after_destroy</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-identifier">author</span>.<span class="ruby-identifier">decrease_post_count</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Note the use of <code>super</code> if you define your own hook methods. 
            Almost all <code>Sequel::Model</code> class and instance methods (not just
            hook methods) can be overridden safely, but you have to make sure to call
            <code>super</code> when doing so, otherwise you risk breaking things.</p>
            
            <p>For the example above, you should probably use a database trigger if you
            can.  Hooks can be used for data integrity, but they will only enforce that
            integrity when you are modifying the database through model instances, and
            even then they are often subject to race conditions.  It’s best to use
            database triggers and constraints to enforce data integrity.</p>
            
            <h3 id="label-Deleting+records">Deleting records</h3>
            
            <p>You can delete individual records by calling <code>delete</code> or
            <code>destroy</code>. The only difference between the two methods is that
            <code>destroy</code> invokes <code>before_destroy</code> and
            <code>after_destroy</code> hook methods, while <code>delete</code> does
            not:</p>
            
            <pre class="ruby"><span class="ruby-identifier">post</span>.<span class="ruby-identifier">delete</span> <span class="ruby-comment"># =&gt; bypasses hooks</span>&#x000A;<span class="ruby-identifier">post</span>.<span class="ruby-identifier">destroy</span> <span class="ruby-comment"># =&gt; runs hooks</span></pre>
            
            <p>Records can also be deleted en-masse by calling <code>delete</code> and
            <code>destroy</code> on the model’s dataset. As stated above, you can
            specify filters for the deleted records:</p>
            
            <pre class="ruby"><span class="ruby-constant">Post</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">category</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">32</span>).<span class="ruby-identifier">delete</span> <span class="ruby-comment"># =&gt; bypasses hooks</span>&#x000A;<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">category</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">32</span>).<span class="ruby-identifier">destroy</span> <span class="ruby-comment"># =&gt; runs hooks</span></pre>
            
            <p>Please note that if <code>destroy</code> is called, each record is deleted 
            separately, but <code>delete</code> deletes all matching records with a
            single  SQL query.</p>
            
            <h3 id="label-Associations">Associations</h3>
            
            <p>Associations are used in order to specify relationships between model
            classes that reflect relationships between tables in the database, which
            are usually specified using foreign keys.  You specify model associations
            via the <code>many_to_one</code>, <code>one_to_one</code>,
            <code>one_to_many</code>, and <code>many_to_many</code> class methods:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Post</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">author</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">comments</span>&#x000A;  <span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">tags</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p><code>many_to_one</code> and <code>one_to_one</code> create a getter and
            setter for each model object:</p>
            
            <pre class="ruby"><span class="ruby-identifier">post</span> = <span class="ruby-constant">Post</span>.<span class="ruby-identifier">create</span>(:<span class="ruby-identifier">name</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'hi!'</span>)&#x000A;<span class="ruby-identifier">post</span>.<span class="ruby-identifier">author</span> = <span class="ruby-constant">Author</span>[:<span class="ruby-identifier">name</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'Sharon'</span>]&#x000A;<span class="ruby-identifier">post</span>.<span class="ruby-identifier">author</span></pre>
            
            <p><code>one_to_many</code> and <code>many_to_many</code> create a getter
            method, a method for adding an object to the association, a method for
            removing an object from the association, and a method for removing all
            associated objects from the association:</p>
            
            <pre class="ruby"><span class="ruby-identifier">post</span> = <span class="ruby-constant">Post</span>.<span class="ruby-identifier">create</span>(:<span class="ruby-identifier">name</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'hi!'</span>)&#x000A;<span class="ruby-identifier">post</span>.<span class="ruby-identifier">comments</span>&#x000A;&#x000A;<span class="ruby-identifier">comment</span> = <span class="ruby-constant">Comment</span>.<span class="ruby-identifier">create</span>(:<span class="ruby-identifier">text=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'hi'</span>)&#x000A;<span class="ruby-identifier">post</span>.<span class="ruby-identifier">add_comment</span>(<span class="ruby-identifier">comment</span>)&#x000A;<span class="ruby-identifier">post</span>.<span class="ruby-identifier">remove_comment</span>(<span class="ruby-identifier">comment</span>)&#x000A;<span class="ruby-identifier">post</span>.<span class="ruby-identifier">remove_all_comments</span>&#x000A;&#x000A;<span class="ruby-identifier">tag</span> = <span class="ruby-constant">Tag</span>.<span class="ruby-identifier">create</span>(:<span class="ruby-identifier">tag=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'interesting'</span>)&#x000A;<span class="ruby-identifier">post</span>.<span class="ruby-identifier">add_tag</span>(<span class="ruby-identifier">tag</span>)&#x000A;<span class="ruby-identifier">post</span>.<span class="ruby-identifier">remove_tag</span>(<span class="ruby-identifier">tag</span>)&#x000A;<span class="ruby-identifier">post</span>.<span class="ruby-identifier">remove_all_tags</span></pre>
            
            <p>Note that the remove_* and remove_all_* methods do not delete the object
            from the database, they merely disassociate the associated object from the
            receiver.</p>
            
            <p>All associations add a dataset method that can be used to further filter or
            reorder the returned objects, or modify all of them:</p>
            
            <pre class="ruby"><span class="ruby-comment"># Delete all of this post's comments from the database</span>&#x000A;<span class="ruby-identifier">post</span>.<span class="ruby-identifier">comments_dataset</span>.<span class="ruby-identifier">destroy</span>&#x000A;&#x000A;<span class="ruby-comment"># Return all tags related to this post with no subscribers, ordered by the tag's name</span>&#x000A;<span class="ruby-identifier">post</span>.<span class="ruby-identifier">tags_dataset</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">subscribers=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">0</span>).<span class="ruby-identifier">order</span>(:<span class="ruby-identifier">name</span>).<span class="ruby-identifier">all</span></pre>
            
            <h3 id="label-Eager+Loading">Eager Loading</h3>
            
            <p>Associations can be eagerly loaded via <code>eager</code> and the
            <code>:eager</code> association option. Eager loading is used when loading
            a group of objects. It loads all associated objects for all of the current
            objects in one query, instead of using a separate query to get the
            associated objects for each current object. Eager loading requires that you
            retrieve all model objects at once via <code>all</code> (instead of
            individually by <code>each</code>). Eager loading can be cascaded, loading
            association’s associated objects.</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Person</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">posts</span>, :<span class="ruby-identifier">eager=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">tags</span>]&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Post</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">person</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">replies</span>&#x000A;  <span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">tags</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Tag</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">posts</span>&#x000A;  <span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">replies</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Reply</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">person</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">post</span>&#x000A;  <span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">tags</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-comment"># Eager loading via .eager</span>&#x000A;<span class="ruby-constant">Post</span>.<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">person</span>).<span class="ruby-identifier">all</span>&#x000A;&#x000A;<span class="ruby-comment"># eager is a dataset method, so it works with filters/orders/limits/etc.</span>&#x000A;<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">topic</span> <span class="ruby-operator">&gt;</span> <span class="ruby-string">'M'</span>}.<span class="ruby-identifier">order</span>(:<span class="ruby-identifier">date</span>).<span class="ruby-identifier">limit</span>(<span class="ruby-value">5</span>).<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">person</span>).<span class="ruby-identifier">all</span>&#x000A;&#x000A;<span class="ruby-identifier">person</span> = <span class="ruby-constant">Person</span>.<span class="ruby-identifier">first</span>&#x000A;<span class="ruby-comment"># Eager loading via :eager (will eagerly load the tags for this person's posts)</span>&#x000A;<span class="ruby-identifier">person</span>.<span class="ruby-identifier">posts</span>&#x000A;&#x000A;<span class="ruby-comment"># These are equivalent</span>&#x000A;<span class="ruby-constant">Post</span>.<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">person</span>, :<span class="ruby-identifier">tags</span>).<span class="ruby-identifier">all</span>&#x000A;<span class="ruby-constant">Post</span>.<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">person</span>).<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">tags</span>).<span class="ruby-identifier">all</span>&#x000A;&#x000A;<span class="ruby-comment"># Cascading via .eager</span>&#x000A;<span class="ruby-constant">Tag</span>.<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">posts=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">replies</span>).<span class="ruby-identifier">all</span>&#x000A;&#x000A;<span class="ruby-comment"># Will also grab all associated posts' tags (because of :eager)</span>&#x000A;<span class="ruby-constant">Reply</span>.<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">person=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">posts</span>).<span class="ruby-identifier">all</span>&#x000A;&#x000A;<span class="ruby-comment"># No depth limit (other than memory/stack), and will also grab posts' tags</span>&#x000A;<span class="ruby-comment"># Loads all people, their posts, their posts' tags, replies to those posts,</span>&#x000A;<span class="ruby-comment"># the person for each reply, the tag for each reply, and all posts and</span>&#x000A;<span class="ruby-comment"># replies that have that tag.  Uses a total of 8 queries.</span>&#x000A;<span class="ruby-constant">Person</span>.<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">posts=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">replies=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">person</span>, {:<span class="ruby-identifier">tags=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">posts</span>, :<span class="ruby-identifier">replies</span>]}]}).<span class="ruby-identifier">all</span></pre>
            
            <p>In addition to using <code>eager</code>, you can also use
            <code>eager_graph</code>, which will use a single query to get the object
            and all associated objects.  This may be necessary if you want to filter or
            order the result set based on columns in associated tables.  It works with
            cascading as well, the API is very similar.  Note that using
            <code>eager_graph</code> to eagerly load multiple <code>*_to_many</code>
            associations will cause the result set to be a cartesian product, so you
            should be very careful with your filters when using it in that case.</p>
            
            <p>You can dynamically customize the eagerly loaded dataset by using using a
            proc.  This proc is passed the dataset used for eager loading, and should
            return a modified copy of that dataset:</p>
            
            <pre class="ruby"><span class="ruby-comment"># Eagerly load only replies containing 'foo'</span>&#x000A;<span class="ruby-constant">Post</span>.<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">replies=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>(<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">like</span>(<span class="ruby-identifier">text</span>, <span class="ruby-string">'%foo%'</span>))}).<span class="ruby-identifier">all</span></pre>
            
            <p>This also works when using <code>eager_graph</code>, in which case the proc
            is called with dataset to graph into the current dataset:</p>
            
            <pre class="ruby"><span class="ruby-constant">Post</span>.<span class="ruby-identifier">eager_graph</span>(:<span class="ruby-identifier">replies=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>(<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">like</span>(<span class="ruby-identifier">text</span>, <span class="ruby-string">'%foo%'</span>))}).<span class="ruby-identifier">all</span></pre>
            
            <p>You can dynamically customize eager loads for both <code>eager</code> and
            <code>eager_graph</code> while also cascading, by making the value a single
            entry hash with the proc as a key, and the cascaded associations as the
            value:</p>
            
            <pre class="ruby"><span class="ruby-comment"># Eagerly load only replies containing 'foo', and the person and tags for those replies</span>&#x000A;<span class="ruby-constant">Post</span>.<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">replies=</span><span class="ruby-operator">&gt;</span>{<span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>(<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">like</span>(<span class="ruby-identifier">text</span>, <span class="ruby-string">'%foo%'</span>))}=<span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">person</span>, :<span class="ruby-identifier">tags</span>]}).<span class="ruby-identifier">all</span></pre>
            
            <h3 id="label-Extending+the+underlying+dataset">Extending the underlying dataset</h3>
            
            <p>The recommended way to implement table-wide logic by defining methods on
            the dataset using <code>dataset_module</code>:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Post</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">dataset_module</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-keyword">def</span> <span class="ruby-identifier">posts_with_few_comments</span>&#x000A;      <span class="ruby-identifier">where</span>{<span class="ruby-identifier">num_comments</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">30</span>}&#x000A;    <span class="ruby-keyword">end</span>&#x000A;&#x000A;    <span class="ruby-keyword">def</span> <span class="ruby-identifier">clean_posts_with_few_comments</span>&#x000A;      <span class="ruby-identifier">posts_with_few_comments</span>.<span class="ruby-identifier">delete</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>This allows you to have access to your model API from filtered datasets as
            well:</p>
            
            <pre class="ruby"><span class="ruby-constant">Post</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">category</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'ruby'</span>).<span class="ruby-identifier">clean_posts_with_few_comments</span></pre>
            
            <p><a href="../classes/Sequel.html">Sequel</a> models also provide a
            <code>subset</code> class method that creates a dataset method with a
            simple filter:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Post</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">subset</span>(:<span class="ruby-identifier">posts_with_few_comments</span>){<span class="ruby-identifier">num_comments</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">30</span>}&#x000A;  <span class="ruby-identifier">subset</span> :<span class="ruby-identifier">invisible</span>, <span class="ruby-constant">Sequel</span>.<span class="ruby-operator">~</span>(:<span class="ruby-identifier">visible</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-Model+Validations">Model Validations</h3>
            
            <p>You can define a <code>validate</code> method for your model, which
            <code>save</code> will check before attempting to save the model in the
            database. If an attribute of the model isn’t valid, you should add a error
            message for that attribute to the model object’s <code>errors</code>. If an
            object has any errors added by the validate method, <code>save</code> will
            raise an error or return false depending on how it is configured (the
            <code>raise_on_save_failure</code> flag).</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Post</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">validate</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-identifier">errors</span>.<span class="ruby-identifier">add</span>(:<span class="ruby-identifier">name</span>, <span class="ruby-string">&quot;can't be empty&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">name</span>.<span class="ruby-identifier">empty?</span>&#x000A;    <span class="ruby-identifier">errors</span>.<span class="ruby-identifier">add</span>(:<span class="ruby-identifier">written_on</span>, <span class="ruby-string">&quot;should be in the past&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">written_on</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
          </div>
          <div id='context'>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
