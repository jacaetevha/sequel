<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>active_record.rdoc</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='file' id='wrapper'>
      <div class='header'>
        <h1 class='name'>active_record.rdoc</h1>
        <div class='paths'>
          doc/active_record.rdoc
        </div>
        <div class='last-update'>
          Last Update:
          <span class='datetime'>2013-11-08 08:08:17 -0500</span>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <h1 id="label-Sequel+for+ActiveRecord+Users"><a href="../../classes/Sequel.html">Sequel</a> for ActiveRecord Users</h1>
            
            <p>This guide is aimed at helping ActiveRecord users transition to <a
            href="../../classes/Sequel.html">Sequel</a>.  It assumes the user is
            familiar with ActiveRecord 2, but if you are familiar with a newer
            ActiveRecord version, the transition should be even easier.</p>
            
            <h2 id="label-Introduction">Introduction</h2>
            
            <p>Both <a href="../../classes/Sequel.html">Sequel</a> and ActiveRecord use
            the active record pattern of database access, where model instances are
            objects that wrap a row in a database table or view, encapsulating the
            database access, and adding domain logic on that data.  Just like
            ActiveRecord, <a href="../../classes/Sequel.html">Sequel</a> supports both
            associations and inheritance, though <a
            href="../../classes/Sequel.html">Sequel</a> does so in a more flexible
            manner than ActiveRecord.</p>
            
            <p>Let’s quickly run through the ActiveRecord <a
            href="../README_rdoc.html">README</a> and show how it applies to <a
            href="../../classes/Sequel.html">Sequel</a>.</p>
            
            <h2 id="label-Automatic+Mapping">Automatic Mapping</h2>
            
            <p>Just like ActiveRecord, <a href="../../classes/Sequel.html">Sequel</a> maps
            classes to tables and automatically creates accessor methods for the
            columns in the table, so if you have an albums table with a primary key
            named “id” and a string/varchar column named “name”, the minimal model
            class is:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> will autogenerate the column
            accessors, so you can do:</p>
            
            <pre>album = Album.new&#x000A;album.name = 'RF'</pre>
            
            <p>If the table name for the class doesn’t match the default one <a
            href="../../classes/Sequel.html">Sequel</a> will choose, you can specify it
            manually:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>(:<span class="ruby-identifier">records</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="label-Associations">Associations</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> supports most of the same
            association types as ActiveRecord, but it uses names that reflect the
            database relationships instead of ones that imply ownership:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">artist</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">tracks</span>&#x000A;  <span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">tags</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="label-Compositions">Compositions</h2>
            
            <p>Sequel’s <code>composition</code> plugin allows you to easily create
            accessor methods that are composed of one or more of the database’s
            columns, similar to ActiveRecord’s <code>composed_of</code>:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">composition</span>&#x000A;  <span class="ruby-identifier">composition</span> :<span class="ruby-identifier">address</span>, :<span class="ruby-identifier">mapping=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">street</span>, :<span class="ruby-identifier">city</span>, :<span class="ruby-identifier">state</span>, :<span class="ruby-identifier">zip</span>]&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="label-Validations">Validations</h2>
            
            <p>Sequel’s <code>validation_class_methods</code> plugin is modeled directly
            on ActiveRecord’s validations, but the recommended approach is to use the
            <code>validation_helpers</code> plugin inside a <code>validate</code>
            instance method:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">validation_helpers</span>&#x000A;&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">validate</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-identifier">validates_presence</span> [:<span class="ruby-identifier">name</span>, :<span class="ruby-identifier">copies_sold</span>]&#x000A;    <span class="ruby-identifier">validates_unique</span> [:<span class="ruby-identifier">name</span>, :<span class="ruby-identifier">artist_id</span>]&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="label-Hooks%2FCallbacks">Hooks/Callbacks</h2>
            
            <p>Sequel’s <code>hook_class_methods</code> plugin is modeled directly on
            ActiveRecord’s callbacks, but the recommended approach is to define your
            hooks/callbacks as instance methods:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">before_create</span>&#x000A;    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">copies_sold</span> <span class="ruby-operator">||=</span> <span class="ruby-value">0</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">after_update</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-constant">AuditLog</span>.<span class="ruby-identifier">create</span>(:<span class="ruby-identifier">log=</span><span class="ruby-operator">&gt;</span><span class="ruby-node">&quot;Updated Album #{id}&quot;</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Observers can be implemented completely by hooks, so <a
            href="../../classes/Sequel.html">Sequel</a> doesn’t offer a separate
            observer class.</p>
            
            <h2 id="label-Inheritance">Inheritance</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> supports both single table
            inheritance and class table inheritance using plugins:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Employee</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">single_table_inheritance</span>, :<span class="ruby-identifier">class_name_column</span>&#x000A;  <span class="ruby-comment"># or</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">class_table_inheritance</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Staff</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Employee</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Manager</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Employee</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Executive</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Manager</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="label-Transactions">Transactions</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> supports transactions via
            the Database object (we recommend using the DB constant for single database
            applications):</p>
            
            <pre>DB.transaction do&#x000A;  album.artist.num_albums -= 1&#x000A;  album.artist.save&#x000A;  album.delete&#x000A;end</pre>
            
            <p>For model classes, you can always access the database via <code>db</code>:</p>
            
            <pre>Album.db.transaction do&#x000A;  album.artist.num_albums -= 1&#x000A;  album.artist.save&#x000A;  album.delete&#x000A;end</pre>
            
            <h2 id="label-Reflection">Reflection</h2>
            
            <p>Just like ActiveRecord, <a href="../../classes/Sequel.html">Sequel</a> has
            full reflection support for columns, associations, and many other things:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">columns</span> <span class="ruby-comment"># =&gt; [:id, :name, :artist_id, :copies_sold]</span>&#x000A;<span class="ruby-identifier">reflection</span> = <span class="ruby-constant">Album</span>.<span class="ruby-identifier">association_reflection</span>(:<span class="ruby-identifier">artist</span>)&#x000A;<span class="ruby-identifier">reflection</span>[:<span class="ruby-identifier">type</span>] <span class="ruby-operator">==</span> :<span class="ruby-identifier">many_to_one</span></pre>
            
            <h2 id="label-Direct+Manipulation">Direct Manipulation</h2>
            
            <p>Just like ActiveRecord, <a href="../../classes/Sequel.html">Sequel</a>
            doesn’t use sessions, it lets you modify objects and have them be saved
            inside the call to <code>save</code>:</p>
            
            <pre>album = Album[1234]&#x000A;# modify album&#x000A;album.save</pre>
            
            <h2 id="label-Database+Abstraction">Database Abstraction</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> supports far more database
            abstractions than ActiveRecord, and setting up the database connection is
            easy:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span> = <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">sqlite</span> <span class="ruby-comment"># memory database</span>&#x000A;<span class="ruby-constant">DB</span> = <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">connect</span>(<span class="ruby-string">'postgres://user:pass@host/database'</span>) <span class="ruby-comment"># connection string</span>&#x000A;<span class="ruby-constant">DB</span> = <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">connect</span>(:<span class="ruby-identifier">adapter=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'postgres'</span>, :<span class="ruby-identifier">user=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'?'</span>, :<span class="ruby-identifier">password=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'?'</span>,&#x000A;  :<span class="ruby-identifier">host=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'?'</span>, :<span class="ruby-identifier">database=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'?'</span>) <span class="ruby-comment"># option hash</span></pre>
            
            <h2 id="label-Logging">Logging</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> supports logging of all
            database queries by allowing multiple loggers for each database:</p>
            
            <pre>DB.loggers &lt;&lt; Logger.new($stdout)</pre>
            
            <h2 id="label-Migrations">Migrations</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> supports migrations and has
            a migrator similar to ActiveRecord:</p>
            
            <pre>Sequel.migration do&#x000A;  change do&#x000A;    create_table(:albums) do&#x000A;      primary_key :id&#x000A;      String :name&#x000A;    end&#x000A;  end&#x000A;end</pre>
            
            <h2 id="label-Differences">Differences</h2>
            
            <p>By now, you should have the idea that <a
            href="../../classes/Sequel.html">Sequel</a> supports most things that
            ActiveRecord supports.  The rest of this guide is going to go over how <a
            href="../../classes/Sequel.html">Sequel</a> differs from ActiveRecord in
            terms of operation.</p>
            
            <h3 id="label-Method+Chaining">Method Chaining</h3>
            
            <p>Unlike ActiveRecord 2 (and similar to ActiveRecord 3+), <a
            href="../../classes/Sequel.html">Sequel</a> uses method chains on datasets
            for retrieving objects, so instead of:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">find</span>(:<span class="ruby-identifier">all</span>, :<span class="ruby-identifier">conditions=</span><span class="ruby-operator">&gt;</span>[<span class="ruby-string">'name &gt; ? AND artist_id = ?'</span>, <span class="ruby-string">'RF'</span>, <span class="ruby-value">1</span>],&#x000A;  :<span class="ruby-identifier">order=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'copies_sold'</span>, :<span class="ruby-identifier">select=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'id, name'</span>)</pre>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> uses:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">name</span> <span class="ruby-operator">&gt;</span> <span class="ruby-string">'RF'</span>}.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">artist_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>).<span class="ruby-identifier">order</span>(:<span class="ruby-identifier">copies_sold</span>).&#x000A;  <span class="ruby-identifier">select</span>(:<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">name</span>).<span class="ruby-identifier">all</span></pre>
            
            <p>Note that the records aren’t retrieved until <code>all</code> is called.</p>
            
            <p>ActiveRecord 3 adopts this method chaining approach, so if you are familiar
            with it, it should be even easier to transition to <a
            href="../../classes/Sequel.html">Sequel</a>.</p>
            
            <h3 id="label-No+Need+for+SQL+String+Fragments">No Need for SQL <a href="../../classes/String.html">String</a> Fragments</h3>
            
            <p>Like the example above, most ActiveRecord code uses SQL string fragments. 
            With <a href="../../classes/Sequel.html">Sequel</a>, you rarely need to. 
            Sequel’s DSL allows you to create complex queries without ever specifying
            SQL string fragments (called literal strings in <a
            href="../../classes/Sequel.html">Sequel</a>).</p>
            
            <p>If you want to use SQL string fragments, <a
            href="../../classes/Sequel.html">Sequel</a> makes it easy by using the
            <code>Sequel.lit</code> method:</p>
            
            <pre>Album.select(Sequel.lit('id, name'))</pre>
            
            <p>This usage is not encouraged, though.  The recommended way is to use
            symbols to represent the columns:</p>
            
            <pre>Album.select(:id, :name)</pre>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> keeps datasets in an
            abstract format, allowing for powerful capabilities.  For example, let's
            say you wanted to join to the artists table.  <a
            href="../../classes/Sequel.html">Sequel</a> can automatically qualify all
            references in the current dataset, so that it can be safely joined:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">select</span>(:<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">name</span>).<span class="ruby-identifier">qualify</span>.<span class="ruby-identifier">join</span>(:<span class="ruby-identifier">artists</span>, :<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artist_id</span>)</pre>
            
            <p>This isn’t possible when you use an SQL string fragment.  Another case
            where using an SQL string fragment hurts you is when the SQL syntax cannot
            handle all cases:</p>
            
            <pre>Album.filter('id NOT IN ?', ids_array)</pre>
            
            <p>That will work fine if <code>ids_array</code> is not empty, but will not
            work correctly if it is empty.  With <a
            href="../../classes/Sequel.html">Sequel</a>, you do:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">exclude</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">ids_array</span>)</pre>
            
            <p>That will handle cases where <code>ids_array</code> is empty correctly.</p>
            
            <p>A third reason to not use SQL string fragments is database independence. 
            For example, if you want a case insensitive search that works on both
            PostgreSQL and MySQL, the following won’t work:</p>
            
            <pre>Album.filter('name LIKE ?', 'A%')</pre>
            
            <p>This is because LIKE is case sensitive on PostgreSQL, but case insensitive
            on MySQL.  With <a href="../../classes/Sequel.html">Sequel</a>, you would
            do:</p>
            
            <pre>Album.filter(Sequel.ilike(:name, 'A%'))</pre>
            
            <p>This will do a case insensitive search on both databases.  If you want a
            case sensitive search on both, you can use <code>like</code> instead of
            <code>ilike</code>.</p>
            
            <p><a href="../../classes/String.html">String</a> concatenation is a similar
            area, where MySQL and PostgreSQL handle things differently.  With <a
            href="../../classes/Sequel.html">Sequel</a>, the same code can work on both
            databases:</p>
            
            <pre>Album.select(Sequel.join([:name, ' - Name']))</pre>
            
            <h2 id="label-Flexible+Overriding">Flexible Overriding</h2>
            
            <p>Unlike ActiveRecord 2, which forces you to alias methods if you want to
            override them, with <a href="../../classes/Sequel.html">Sequel</a> you just
            override the methods and call super:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">after_update</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-constant">AuditLog</span>.<span class="ruby-identifier">create</span>(:<span class="ruby-identifier">log=</span><span class="ruby-operator">&gt;</span><span class="ruby-node">&quot;#{model.name} with primary key #{pk} updated&quot;</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>With that code, you have enabled auditing for all model object updates.</p>
            
            <p>Let’s say you want to override accessor methods.  In <a
            href="../../classes/Sequel.html">Sequel</a>, instead of using
            <code>read_attribute</code> and <code>write_attribute</code>, you can just
            call super:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Track</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-comment"># database holds length in integer seconds,</span>&#x000A;  <span class="ruby-comment"># but you want it in minutes as a float</span>&#x000A;&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">length=</span>(<span class="ruby-identifier">minutes</span>)&#x000A;    <span class="ruby-keyword">super</span>((<span class="ruby-identifier">minutes</span>*<span class="ruby-value">60</span>).<span class="ruby-identifier">to_i</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">length</span>&#x000A;    <span class="ruby-keyword">super</span><span class="ruby-operator">/</span><span class="ruby-value">60.0</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>You can override almost all model class or instance methods this way, just
            remember to call <code>super</code>.</p>
            
            <h2 id="label-method_missing+Missing"><code>method_missing</code> Missing</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> does not use
            <code>method_missing</code> unless it's required that the object respond to
            potentially any method. Neither <code>Sequel::Model</code> nor
            <code>Sequel::Dataset</code> nor <code>Sequel::Database</code> implement
            <code>method_missing</code> at either a class or instance level.  So if you
            call <code>methods</code>, you can see which methods are available, and if
            they aren't listed, then the object won't respond to them.  Among other
            things, this means <a href="../../classes/Sequel.html">Sequel</a> does not
            support dynamic finders.  So instead of:</p>
            
            <pre>Album.find_or_create_by_name(&quot;RF&quot;)</pre>
            
            <p>You just use:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">find_or_create</span>(:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;RF&quot;</span>)</pre>
            
            <p>At the instance level, this means that if you select columns that aren’t in
            the models table, you need to use <code>Model#[]</code> to access them:</p>
            
            <pre class="ruby"><span class="ruby-identifier">album</span> = <span class="ruby-constant">Album</span>.<span class="ruby-identifier">join</span>(:<span class="ruby-identifier">artist</span>, :<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artist_id</span>).&#x000A; <span class="ruby-identifier">select</span>(:<span class="ruby-identifier">albums__id</span>, :<span class="ruby-identifier">albums__name</span>, :<span class="ruby-identifier">artists__name___artist</span>).<span class="ruby-identifier">first</span>&#x000A; <span class="ruby-comment"># SELECT albums.id, albums.name, artists.name AS artist</span>&#x000A;&#x000A;<span class="ruby-identifier">album</span>.<span class="ruby-identifier">artist</span> <span class="ruby-comment"># Error!</span>&#x000A;<span class="ruby-identifier">album</span>[:<span class="ruby-identifier">artist</span>] <span class="ruby-comment"># Works</span></pre>
            
            <h2 id="label-Associations">Associations</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> associations are similar to
            ActiveRecord associations in some ways, and much different in others.  <a
            href="../../classes/Sequel.html">Sequel</a> provides four association
            creation methods that map to ActiveRecord's associations:</p>
            <dl class="rdoc-list note-list"><dt>ActiveRecord 
            <dd>
            <p><a href="../../classes/Sequel.html">Sequel</a></p>
            </dd><dt><code>belongs_to</code> 
            <dd>
            <p><code>many_to_one</code></p>
            </dd><dt><code>has_one</code> 
            <dd>
            <p><code>one_to_one</code></p>
            </dd><dt><code>has_many</code> 
            <dd>
            <p><code>one_to_many</code></p>
            </dd><dt><code>has_and_belongs_to_many</code> 
            <dd>
            <p><code>many_to_many</code></p>
            </dd></dl>
            
            <p>Like ActiveRecord, when you create an association in <a
            href="../../classes/Sequel.html">Sequel</a>, it creates an instance method
            with the same name that returns either the matching object or nil for the
            <code>*_to_one</code> associations, or an array of matching objects for the
            <code>*_to_many</code> associations.</p>
            
            <p>Updating <code>*_to_many</code> associations is very different, however. 
            ActiveRecord makes the association method returns an association proxy that
            looks like an array, but has a bunch of added methods to manipulate the
            associated records.  <a href="../../classes/Sequel.html">Sequel</a> uses
            instance methods on the object instead of a proxy to modify the
            association.  Here’s a basic example:</p>
            
            <pre>Artist.one_to_many :albums&#x000A;Album.many_to_one :artist&#x000A;artist = Artist[1]&#x000A;album = Album[1]&#x000A;&#x000A;artist.albums # array of albums&#x000A;album.artist # Artist instance or nil&#x000A;&#x000A;artist.add_album(album) # associate album to artist&#x000A;artist.remove_album(album) # disassociate album from artist&#x000A;artist.remove_all_albums # disassociate all albums from artist</pre>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> doesn't have a
            <code>has_many :through</code> association, instead you can use a
            <code>many_to_many</code> association in most cases.  <a
            href="../../classes/Sequel.html">Sequel</a> ships with a
            <code>many_through_many</code> plugin that allows you to set up a many to
            many relationship through an arbitrary number of join tables.</p>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> doesn't come with support
            for polymorphic associations.  Using polymorphic associations is generally
            bad from a database design perspective, as it violates referential
            integrity.  If you have an old database and must have polymorphic
            associations, there is an external <code>sequel_polymorphic</code> plugin
            that can handle them, just by using the standard association options
            provided by <a href="../../classes/Sequel.html">Sequel</a>.</p>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> doesn't directly support
            creating a bunch of associated objects and delaying saving them to the
            database until the main object is saved, like you can with the
            <code>association.build</code> methods in ActiveRecord.  You can use
            +before_save or <code>after_save</code> hooks, or the
            <code>nested_attributes</code> or <code>instance_hooks</code> plugins to
            get similar support.</p>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> supports the same basic
            association hooks/callbacks as ActiveRecord.  It also supports
            <code>:after_load</code>, which is run after the associated objects are
            loaded.  For <code>*_to_one</code> associations, it supports
            <code>before_set</code> and <code>after_set</code> hooks, since a setter
            method is used instead of an add/remove method pair.</p>
            
            <p>If you pass a block to an association method, it’s used to return a
            modified dataset used for the association, instead of to create an
            association extension:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">gold_albums</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span>:<span class="ruby-constant">Album</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">copies_sold</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">500000</span>}&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>If you want to create an association extension, you can use the
            <code>:extend</code> association option with a module, which ActiveRecord
            also supports.  In <a href="../../classes/Sequel.html">Sequel</a>, the
            extensions are applied to the association dataset, not to the array of
            associated objects.  You can access the association dataset using the
            <code>association_dataset</code> method:</p>
            
            <pre>artist.albums_dataset&#x000A;album.artist_dataset</pre>
            
            <p>Association datasets are just like any other <a
            href="../../classes/Sequel.html">Sequel</a> dataset, in that you can filter
            them and manipulate them further:</p>
            
            <pre>gold_albums = artist.albums_dataset.where{copies_sold &gt; 500000}.order(:name).all</pre>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> caches associated objects
            similarly to ActiveRecord, and you can skip the cache by passing
            <code>true</code> to the association method, just like ActiveRecord.</p>
            
            <h3 id="label-Eager+Loading">Eager Loading</h3>
            
            <p>ActiveRecord 2 tries to guess whether to use preloading or JOINs for eager
            loading by scanning the SQL string fragments you provide for table names. 
            This is error prone and <a href="../../classes/Sequel.html">Sequel</a>
            avoids it by giving you separate methods.  In <a
            href="../../classes/Sequel.html">Sequel</a>, <code>eager</code> is used for
            preloading and <code>eager_graph</code> is used for JOINs.  Both have the
            same API:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">albums=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">tags</span>, :<span class="ruby-identifier">tracks</span>])&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager_graph</span>(:<span class="ruby-identifier">artist</span>, :<span class="ruby-identifier">tracks</span>)</pre>
            
            <p>With either way of eager loading, you must call <code>all</code> to
            retrieve all records at once.  You cannot use <code>each</code>,
            <code>map</code>, or one of the other Enumerable methods.  Just like
            <code>each</code>, <code>all</code> takes a block that iterates over the
            records:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">albums=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">tags</span>, :<span class="ruby-identifier">tracks</span>]).<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-operator">...</span>} <span class="ruby-comment"># No cookie</span>&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">albums=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">tags</span>, :<span class="ruby-identifier">tracks</span>]).<span class="ruby-identifier">all</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-operator">...</span>} <span class="ruby-comment"># Cookie</span></pre>
            
            <p>Like ActiveRecord, <a href="../../classes/Sequel.html">Sequel</a> supports
            cascading of eager loading for both methods of eager loading.</p>
            
            <p>Unlike ActiveRecord, <a href="../../classes/Sequel.html">Sequel</a> allows
            you to eager load custom associations using the <code>:eager_loader</code>
            and <code>:eager_grapher</code> association options.  See the <a
            href="advanced_associations_rdoc.html">Advanced Associations guide</a> for
            more details.</p>
            
            <p>Table aliasing when eager loading via <code>eager_graph</code> is different
            in <a href="../../classes/Sequel.html">Sequel</a> than ActiveRecord.  <a
            href="../../classes/Sequel.html">Sequel</a> will always attempt to use the
            association name, not the table name, for any associations.  If the
            association name has already been used, <a
            href="../../classes/Sequel.html">Sequel</a> will append _N to it, where N
            starts at 0 and increases by 1.  For example, for a self referential
            association:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Node</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">parent</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-keyword">self</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">children</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-keyword">self</span>, :<span class="ruby-identifier">key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">parent_id</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-constant">Node</span>.<span class="ruby-identifier">eager_graph</span>(:<span class="ruby-identifier">parent=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">parent</span>, :<span class="ruby-identifier">children=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">children=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">children</span>}).<span class="ruby-identifier">all</span>&#x000A;&#x000A;<span class="ruby-comment"># SELECT nodes.id, nodes.parent_id, -- main table</span>&#x000A;<span class="ruby-comment">#  parent.id AS parent_id_0, parent.parent_id AS parent_parent_id, -- parent</span>&#x000A;<span class="ruby-comment">#  parent_0.id AS parent_0_id, parent_0.parent_id AS parent_0_parent_id, -- grandparent</span>&#x000A;<span class="ruby-comment">#  children.id AS children_id, children.parent_id AS children_parent_id, -- children</span>&#x000A;<span class="ruby-comment">#  children_0.id AS children_0_id, children_0.parent_id AS children_0_parent_id, -- grandchildren</span>&#x000A;<span class="ruby-comment">#  children_1.id AS children_1_id, children_1.parent_id AS children_1_parent_id -- great grandchidren</span>&#x000A;<span class="ruby-comment"># FROM nodes -- main table</span>&#x000A;<span class="ruby-comment">#  LEFT OUTER JOIN nodes AS parent ON (parent.id = nodes.parent_id) -- parent</span>&#x000A;<span class="ruby-comment">#  LEFT OUTER JOIN nodes AS parent_0 ON (parent_0.id = parent.parent_id) -- grandparent</span>&#x000A;<span class="ruby-comment">#  LEFT OUTER JOIN nodes AS children ON (children.parent_id = nodes.id) -- children</span>&#x000A;<span class="ruby-comment">#  LEFT OUTER JOIN nodes AS children_0 ON (children_0.parent_id = children.id) -- grandchildren</span>&#x000A;<span class="ruby-comment">#  LEFT OUTER JOIN nodes AS children_1 ON (children_1.parent_id = children_0.id) -- great grandchildren</span></pre>
            
            <p>You can specify aliases on a per join basis, too:</p>
            
            <pre class="ruby"><span class="ruby-constant">Node</span>.<span class="ruby-identifier">eager_graph</span>(:<span class="ruby-identifier">parent=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">as</span>(:<span class="ruby-identifier">parent</span>, :<span class="ruby-identifier">grandparent</span>),&#x000A;  :<span class="ruby-identifier">children=</span><span class="ruby-operator">&gt;</span>{<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">as</span>(:<span class="ruby-identifier">children</span>, :<span class="ruby-identifier">grandchildren</span>)=<span class="ruby-operator">&gt;</span><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">as</span>(:<span class="ruby-identifier">children</span>, :<span class="ruby-identifier">great_grandchildren</span>)}).<span class="ruby-identifier">all</span>&#x000A;&#x000A;<span class="ruby-comment"># SELECT nodes.id, nodes.parent_id,</span>&#x000A;<span class="ruby-comment">#  parent.id AS parent_id_0, parent.parent_id AS parent_parent_id,</span>&#x000A;<span class="ruby-comment">#  grandparent.id AS grandparent_id, grandparent.parent_id AS grandparent_parent_id,</span>&#x000A;<span class="ruby-comment">#  children.id AS children_id, children.parent_id AS children_parent_id,</span>&#x000A;<span class="ruby-comment">#  grandchildren.id AS grandchildren_id, grandchildren.parent_id AS grandchildren_parent_id,</span>&#x000A;<span class="ruby-comment"># great_grandchildren.id AS great_grandchildren_id, great_grandchildren.parent_id AS great_grandchildren_parent_id</span>&#x000A;<span class="ruby-comment"># FROM nodes</span>&#x000A;<span class="ruby-comment">#  LEFT OUTER JOIN nodes AS parent ON (parent.id = nodes.parent_id)</span>&#x000A;<span class="ruby-comment">#  LEFT OUTER JOIN nodes AS grandparent ON (grandparent.id = parent.parent_id)</span>&#x000A;<span class="ruby-comment">#  LEFT OUTER JOIN nodes AS children ON (children.parent_id = nodes.id)</span>&#x000A;<span class="ruby-comment">#  LEFT OUTER JOIN nodes AS grandchildren ON (grandchildren.parent_id = children.id)</span>&#x000A;<span class="ruby-comment">#  LEFT OUTER JOIN nodes AS great_grandchildren ON (great_grandchildren.parent_id = grandchildren.id)</span></pre>
            
            <h3 id="label-Options+">Options </h3>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> supports many more
            association options than ActiveRecord, but here's a mapping of ActiveRecord
            association options to <a href="../../classes/Sequel.html">Sequel</a>
            association options.  Note that when you specify columns in <a
            href="../../classes/Sequel.html">Sequel</a>, you use symbols, not strings. 
            Where ActiveRecord would use an SQL string fragment with embedded commas
            for multiple columns, <a href="../../classes/Sequel.html">Sequel</a> would
            use an array of column symbols.</p>
            
            <h3 id="label-Shared+options">Shared options</h3>
            
            <p>These options are shared by more than one ActiveRecord association.</p>
            <dl class="rdoc-list note-list"><dt>ActiveRecord option 
            <dd>
            <p><a href="../../classes/Sequel.html">Sequel</a> option</p>
            </dd><dt><code>:class_name</code> 
            <dd>
            <p><code>:class</code></p>
            </dd><dt><code>:conditions</code> 
            <dd>
            <p><code>:conditions</code></p>
            </dd><dt><code>:select</code> 
            <dd>
            <p><code>:select</code></p>
            </dd><dt><code>:order</code> 
            <dd>
            <p><code>:order</code></p>
            </dd><dt><code>:extend</code> 
            <dd>
            <p><code>:extend</code></p>
            </dd><dt><code>:limit</code> 
            <dd>
            <p><code>:limit</code></p>
            </dd><dt><code>:offset</code> 
            <dd>
            <p><code>:limit</code> with an array with the second element being the offset</p>
            </dd><dt><code>:uniq</code> 
            <dd>
            <p><code>:uniq</code></p>
            </dd><dt><code>:validate</code> 
            <dd>
            <p><code>:validate</code></p>
            </dd><dt><code>:dependent</code> 
            <dd>
            <p>The <code>associations_dependencies</code> plugin</p>
            </dd><dt><code>:polymorphic</code>, <code>:as</code>, <code>:source_type</code> 
            <dd>
            <p>The <code>sequel_polymorphic</code> external plugin</p>
            </dd><dt><code>:include</code> 
            <dd>
            <p><code>:eager</code>, <code>:eager_graph</code></p>
            </dd><dt><code>:readonly</code> 
            <dd>
            <p>No equivalent, the <a href="../../classes/Sequel.html">Sequel</a>
            <code>:read_only</code> option just means the modification methods are not
            created (it makes the association read only, not records retrieved through
            the association)</p>
            </dd><dt><code>:through</code>, <code>:source</code> 
            <dd>
            <p>Use a <code>many_to_many</code> association, or the
            <code>many_through_many</code> plugin</p>
            </dd><dt><code>:touch</code> 
            <dd>
            <p>The <code>touch</code> plugin</p>
            </dd><dt><code>:autosave</code> 
            <dd>
            <p>A <code>before_save</code> or <code>after_save</code> hook</p>
            </dd><dt><code>:finder_sql</code> 
            <dd>
            <p><code>:dataset</code> to set a custom dataset</p>
            </dd><dt><code>:counter_sql</code> 
            <dd>
            <p>No direct equivalent, but a count on the dataset will use the custom
            dataset specified by <code>:dataset</code></p>
            </dd><dt><code>:group</code> 
            <dd>
            <p>Use the association block to add the group to the dataset</p>
            </dd><dt><code>:having</code> 
            <dd>
            <p>Use the association block to add the having to the dataset</p>
            </dd></dl>
            
            <h3 id="label-belongs_to"><code>belongs_to</code></h3>
            <dl class="rdoc-list note-list"><dt><code>belongs_to</code> option 
            <dd>
            <p><code>many_to_one</code> option</p>
            </dd><dt><code>:foreign_key</code> 
            <dd>
            <p><code>:key</code></p>
            </dd><dt><code>:primary_key</code> 
            <dd>
            <p><code>:primary_key</code></p>
            </dd><dt><code>:counter_cache</code> 
            <dd>
            <p>No equivalent</p>
            </dd></dl>
            
            <h3 id="label-has_one%2C+has_many"><code>has_one</code>, <code>has_many</code></h3>
            <dl class="rdoc-list note-list"><dt><code>has_one</code>, <code>has_many</code> option 
            <dd>
            <p><code>one_to_one</code>, <code>one_to_many</code> option</p>
            </dd><dt><code>:foreign_key</code> 
            <dd>
            <p><code>:key</code></p>
            </dd></dl>
            
            <h3 id="label-has_and_belongs_to_many"><code>has_and_belongs_to_many</code></h3>
            <dl class="rdoc-list note-list"><dt><code>has_and_belongs_to_many</code> option 
            <dd>
            <p><code>many_to_many</code> option</p>
            </dd><dt><code>:foreign_key</code> 
            <dd>
            <p><code>:left_key</code></p>
            </dd><dt><code>:association_foreign_key</code> 
            <dd>
            <p><code>:right_key</code></p>
            </dd><dt><code>:join_table</code> 
            <dd>
            <p><code>:join_table</code></p>
            </dd><dt><code>:delete_sql</code> 
            <dd>
            <p><code>:remover</code></p>
            </dd><dt><code>:insert_sql</code> 
            <dd>
            <p><code>:adder</code></p>
            </dd></dl>
            
            <h2 id="label-Validation+Errors">Validation Errors</h2>
            
            <p>If there are errors when validating an object in <a
            href="../../classes/Sequel.html">Sequel</a>, they are stored in a
            <code>Sequel::Model::Errors</code> instance.  It’s mostly similar to
            <code>ActiveRecord::Errors</code>, so this section will just go over the
            differences.</p>
            
            <p><code>Sequel::Model::Errors</code> is a hash subclass where keys are
            usually column symbols (not required), and values are arrays of error
            messages.  So if you have two error messages on the same column,
            <code>each</code> will only yield once, not twice.</p>
            
            <p>The <code>add_on_blank</code>, <code>add_on_empty</code>,
            <code>add_to_base</code>, <code>each_full</code>,
            <code>generate_message</code>, <code>invalid?</code>, <code>on_base</code>,
            and <code>to_xml</code> methods don’t exist.  <code>[]</code> should not be
            used directly, instead you should use <code>on</code>.</p>
            
            <p>You can think of <code>Sequel::Model::Errors</code> as a subset of
            <code>ActiveRecord::Errors</code> if you stick to <code>on</code>,
            <code>add</code>, and <code>full_messages</code>.</p>
            
            <h2 id="label-Sequel+Configuration+Flags"><a href="../../classes/Sequel.html">Sequel</a> Configuration Flags</h2>
            
            <p>Unlike ActiveRecord, Sequel’s behavior depends on how you configure it.  In
            <a href="../../classes/Sequel.html">Sequel</a>, you can set flags at the
            global, class, and instance level that change the behavior of <a
            href="../../classes/Sequel.html">Sequel</a>.  Here’s a brief description of
            the flags:</p>
            <dl class="rdoc-list note-list"><dt><code>raise_on_save_failure</code> 
            <dd>
            <p>Whether to raise an error instead of returning nil on a failure to
            save/create/save_changes/etc due to a validation failure or a before_* hook
            returning false. By default, an error is raised, when this is set to false,
            nil is returned instead.</p>
            </dd><dt><code>raise_on_typecast_failure</code> 
            <dd>
            <p>Whether to raise an error when unable to typecast data for a column
            (default: true). This should be set to false if you want to use validations
            to display nice error messages to the user (e.g. most web applications).
            You can use the <code>validates_schema_types</code> validation in
            connection with this option to check for typecast failures.</p>
            </dd><dt><code>require_modification</code> 
            <dd>
            <p>Whether to raise an error if an UPDATE or DELETE query related to a model
            instance does not modify exactly 1 row. If set to false, <a
            href="../../classes/Sequel.html">Sequel</a>  will not check the number of
            rows modified (default: true if the database supports it).</p>
            </dd><dt><code>strict_param_setting</code> 
            <dd>
            <p>Whether new/set/update and their variants should raise an error if an
            invalid key is used. A key is invalid if no setter method exists for that
            key or the access to the setter method is restricted (e.g. due to it being
            a primary key field). If set to false, silently skip any key where the
            setter method doesn’t exist or access to it is restricted.</p>
            </dd><dt><code>typecast_empty_string_to_nil</code> 
            <dd>
            <p>Whether to typecast the empty string (”) to nil for columns that are not
            string or blob. In most cases the empty string would be the way to specify
            a NULL SQL value in string form (nil.to_s == ”), and an empty string would
            not usually be typecast correctly for other types, so the default is true.</p>
            </dd><dt><code>typecast_on_assignment</code> 
            <dd>
            <p>Whether to typecast attribute values on assignment (default: true). If set
            to false, no typecasting is done, so it will be left up to the database to
            typecast the value correctly.</p>
            </dd><dt><code>use_transactions</code> 
            <dd>
            <p>Whether to use a transaction by default when saving/deleting records
            (default: true). If you are sending database queries in before or after
            hooks, you shouldn’t change the default setting without a good reason.</p>
            </dd></dl>
            
            <h2 id="label-ActiveRecord+Method+to+Sequel+Method+Mapping+">ActiveRecord Method to <a href="../../classes/Sequel.html">Sequel</a> Method Mapping </h2>
            
            <p>This part of the guide will list <a
            href="../../classes/Sequel.html">Sequel</a> equivalents for ActiveRecord
            methods, hopefully allowing you to convert your existing ActiveRecord code
            to <a href="../../classes/Sequel.html">Sequel</a> code more easily.</p>
            
            <h3 id="label-Class+Methods+with+Significantly+Different+Behavior">Class Methods with Significantly Different Behavior</h3>
            
            <h4 id="label-abstract_class%2C+abstract_class%3D%2C+abstract_class%3F"><code>abstract_class</code>, <code>abstract_class=</code>, <code>abstract_class?</code></h4>
            
            <p>With <a href="../../classes/Sequel.html">Sequel</a>, these methods don’t
            exist because it doesn’t default to using single table inheritance in
            subclasses.  ActiveRecord assumes that subclasses of Model classes use
            single table inheritance, and you have to set <code>abstract_class =&#x000A;true</code> to use an abstract class.  In <a
            href="../../classes/Sequel.html">Sequel</a>, you must use the
            <code>single_table_inheritance</code> or
            <code>class_table_inheritance</code> plugin to configure inheritance in the
            database.</p>
            
            <h4 id="label-all"><code>all</code></h4>
            
            <p>In both <a href="../../classes/Sequel.html">Sequel</a> and ActiveRecord,
            calling <code>all</code> will give you an array of all records.  However,
            while in ActiveRecord you pass options to <code>all</code> to filter or
            order the results, in <a href="../../classes/Sequel.html">Sequel</a> you
            call dataset methods to filter or order the results, and then end the
            method chain with a call to <code>all</code> to return the records.</p>
            
            <h4 id="label-column_names"><code>column_names</code></h4>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> uses symbols for columns, so
            the <code>columns</code> method returns an array of symbols.  If you want
            an array of strings:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">columns</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">to_s</span>}</pre>
            
            <h4 id="label-columns"><code>columns</code></h4>
            
            <p><code>Sequel::Model.columns</code> returns an array of column name symbols.
            The closest similar thing would be to get the database schema hash for each
            column:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">columns</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-constant">Album</span>.<span class="ruby-identifier">db_schema</span>[<span class="ruby-identifier">x</span>]}</pre>
            
            <h4 id="label-composed_of"><code>composed_of</code></h4>
            
            <p>As mentioned earlier, <a href="../../classes/Sequel.html">Sequel</a> uses
            the <code>composition</code> plugin for this:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">composition</span>&#x000A;  <span class="ruby-identifier">composition</span> :<span class="ruby-identifier">address</span>, :<span class="ruby-identifier">mapping=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">street</span>, :<span class="ruby-identifier">city</span>, :<span class="ruby-identifier">state</span>, :<span class="ruby-identifier">zip</span>]&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-connected%3F"><code>connected?</code></h4>
            
            <p><code>Sequel::Model</code> raises an exception if you haven't instantiated
            a <code>Sequel::Database</code> object before loading the model class. 
            However, if you want to test the connection to the database:</p>
            
            <pre>Sequel::Model.db.test_connection</pre>
            
            <p>Note that <code>test_connection</code> will return true if a connection can
            be made, but will probably raise an exception if it cannot be made.</p>
            
            <h4 id="label-connection"><code>connection</code></h4>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> only uses connections for
            the minimum amount of time necessary, checking them out to do a query, and
            returning them as soon as the query finishes.  If you do want direct access
            to the connection object:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>.<span class="ruby-identifier">db</span>.<span class="ruby-identifier">synchronize</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">connection</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-operator">...</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Note that the connection is yielded to the block, and the block ensures it
            is returned to the pool.  <a href="../../classes/Sequel.html">Sequel</a>
            doesn’t have a method that returns a connection, since that would check it
            out with no ability to ensure it is returned to the pool.</p>
            
            <h4 id="label-count_by_sql"><code>count_by_sql</code></h4>
            
            <p>You can call <code>with_sql</code> to set the SQL to use, and the
            <code>single_value</code> to retrieve the result.</p>
            
            <pre>Album.with_sql(&quot;SELECT COUNT(*) ...&quot;).single_value</pre>
            
            <h4 id="label-delete%2C+delete_all"><code>delete</code>, <code>delete_all</code></h4>
            
            <p>You probably want to filter first, then call <code>delete</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">id</span>).<span class="ruby-identifier">delete</span>&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(<span class="ruby-string">&quot;artist_id = ?&quot;</span>, <span class="ruby-value">5</span>).<span class="ruby-identifier">delete</span></pre>
            
            <p>If you really want to delete all rows in the table,call <code>delete</code>
            on the Model’s dataset:</p>
            
            <pre>Album.dataset.delete</pre>
            
            <h4 id="label-destroy%2C+destroy_all"><code>destroy</code>, <code>destroy_all</code></h4>
            
            <p>Similar to <code>delete</code>, you filter first, then
            <code>destroy</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">id</span>).<span class="ruby-identifier">destroy</span>&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(<span class="ruby-string">&quot;artist_id = ?&quot;</span>, <span class="ruby-value">5</span>).<span class="ruby-identifier">destroy</span></pre>
            
            <p>If you really want to destroy all rows in the table,call
            <code>destroy</code> on the Model’s dataset:</p>
            
            <pre>Album.dataset.destroy</pre>
            
            <h4 id="label-establish_connection"><code>establish_connection</code></h4>
            
            <p>If you want to use a specific <code>Sequel::Database</code> object, you can
            use <code>db=</code>:</p>
            
            <pre>BACKUP_DB = Sequel.connect(...)&#x000A;Album.db = BACKUP_DB</pre>
            
            <p>If you want a specific dataset in that database, you can use
            <code>set_dataset</code> or <code>dataset=</code>:</p>
            
            <pre>Album.set_dataset BACKUP_DB[:albums]&#x000A;Album.dataset = BACKUP_DB[:albums]</pre>
            
            <h4 id="label-exists%3F"><code>exists?</code></h4>
            
            <p>You need to filter the dataset first, then call <code>empty?</code> and
            invert the result:</p>
            
            <pre class="ruby"><span class="ruby-operator">!</span><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>).<span class="ruby-identifier">empty?</span></pre>
            
            <h4 id="label-find"><code>find</code></h4>
            
            <p>ActiveRecord’s <code>find</code> can be used for a lot of different things.
            If you are trying to find a single object given a primary key:</p>
            
            <pre>Album[1]</pre>
            
            <p>Note that <a href="../../classes/Sequel.html">Sequel</a> returns nil if no
            record is found, it doesn’t raise an exception.  To raise an exception if
            no record is found:</p>
            
            <pre>Album.with_pk!(1)</pre>
            
            <p>If you want to find multiple objects using an array of primary keys:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]).<span class="ruby-identifier">all</span></pre>
            
            <p>If you are using <code>find(:first, ...)</code>, you use a method chain
            instead of passing the options, and end it with <code>first</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">artist_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>).<span class="ruby-identifier">order</span>(:<span class="ruby-identifier">name</span>).<span class="ruby-identifier">first</span></pre>
            
            <p>If you are using <code>find(:last, ...)</code>, you need to specify an
            order in <a href="../../classes/Sequel.html">Sequel</a>, but the same
            method chain approach is used, which you end with <code>last</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">artist_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>).<span class="ruby-identifier">order</span>(:<span class="ruby-identifier">name</span>).<span class="ruby-identifier">last</span>&#x000A;<span class="ruby-comment"># You could also do:</span>&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">artist_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>).<span class="ruby-identifier">reverse_order</span>(:<span class="ruby-identifier">name</span>).<span class="ruby-identifier">first</span></pre>
            
            <p>If you are using <code>find(:all, ...)</code>, you use a method chain
            instead of passing the options, and end it with <code>all</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">artist_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>).<span class="ruby-identifier">order</span>(:<span class="ruby-identifier">name</span>).<span class="ruby-identifier">all</span></pre>
            
            <p>Here’s a mapping of ActiveRecord <code>find</code> options to
            <code>Sequel::Dataset</code> methods:</p>
            <dl class="rdoc-list note-list"><dt>:conditions 
            <dd>
            <p>filter, where</p>
            </dd><dt>:order 
            <dd>
            <p>order</p>
            </dd><dt>:group 
            <dd>
            <p>group</p>
            </dd><dt>:limit 
            <dd>
            <p>limit</p>
            </dd><dt>:offset 
            <dd>
            <p>offset</p>
            </dd><dt>:joins 
            <dd>
            <p>join, left_join, etc. # many other join methods</p>
            </dd><dt>:include 
            <dd>
            <p>eager, eager_graph # eager does preloading, eager_graph does JOINs</p>
            </dd><dt>:select 
            <dd>
            <p>select</p>
            </dd><dt>:from 
            <dd>
            <p>from</p>
            </dd><dt>:read_only 
            <dd>
            <p># No <a href="../../classes/Sequel.html">Sequel</a> equivalent</p>
            </dd><dt>:lock 
            <dd>
            <p>for_update, lock_style</p>
            </dd></dl>
            
            <h4 id="label-find_by_sql"><code>find_by_sql</code></h4>
            
            <p>Similar to <code>count_by_sql</code>, you use <code>with_sql</code>,
            followed by <code>all</code>:</p>
            
            <pre>Album.with_sql(&quot;SELECT * FROM albums WHERE ...&quot;).all</pre>
            
            <h4 id="label-first"><code>first</code></h4>
            
            <p>Just like with <code>find(:first, ...)</code>, you use a method chain
            instead of passing the options, and end it with <code>first</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">artist_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>).<span class="ruby-identifier">order</span>(:<span class="ruby-identifier">name</span>).<span class="ruby-identifier">first</span></pre>
            
            <h4 id="label-last"><code>last</code></h4>
            
            <p>Just like with <code>find(:last, ...)</code>, you use a method chain
            instead of passing the options, make sure it includes an order, and end it
            with <code>last</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">artist_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>).<span class="ruby-identifier">order</span>(:<span class="ruby-identifier">name</span>).<span class="ruby-identifier">last</span></pre>
            
            <h4 id="label-named_scope"><code>named_scope</code></h4>
            
            <p>For a pure filter, you can use <code>subset</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">subset</span>(:<span class="ruby-identifier">debut</span>, :<span class="ruby-identifier">position</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>)&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">subset</span>(:<span class="ruby-identifier">gold</span>){<span class="ruby-identifier">copies_sold</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">500000</span>}</pre>
            
            <p>For anything more complex, you can use <code>dataset_module</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">dataset_module</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">by_artist</span>(<span class="ruby-identifier">artist_id</span>)&#x000A;    <span class="ruby-identifier">where</span>(:<span class="ruby-identifier">artist_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">artist_id</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">by_release_date</span>&#x000A;    <span class="ruby-identifier">order</span>(:<span class="ruby-identifier">release_date</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-reset_column_information"><code>reset_column_information</code></h4>
            
            <p>If you want to completely reload the schema for the table:</p>
            
            <pre>Album.instance_variable_set(:@db_schema, nil)&#x000A;Album.send(:get_db_schema, true)</pre>
            
            <h4 id="label-serialize%2C+seralized_attributes"><code>serialize</code>, <code>seralized_attributes</code></h4>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> ships with a
            <code>serialization</code> plugin that you can use.</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">serialization</span>, :<span class="ruby-identifier">json</span>, :<span class="ruby-identifier">permissions</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>For <code>serialized_attributes</code>, you can use
            <code>serialization_map</code>, which is also a hash, but keys are column
            symbols and values are callable objects used to serialize the values.</p>
            
            <h4 id="label-set_inheritance_column"><code>set_inheritance_column</code></h4>
            
            <p>This is something that must be specified when you are loading the
            <code>single_table_inheritance</code> plugin:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">single_table_inheritance</span>, :<span class="ruby-identifier">column</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-set_sequence_name"><code>set_sequence_name</code></h4>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> will usually auto discover
            the sequence to use.  However, on Oracle this should be specified by making
            sure the model's dataset includes a sequence:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>(<span class="ruby-constant">ORACLE_DB</span>[:<span class="ruby-identifier">albums</span>].<span class="ruby-identifier">sequence</span>(<span class="ruby-string">'albums_seq'</span>))&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-table_exists%3F"><code>table_exists?</code></h4>
            
            <p>This is a <code>Sequel::Database</code> method:</p>
            
            <pre>Album.db.table_exists?(Album.table_name)</pre>
            
            <p>With the <code>schema</code> plugin, you can use it directly:</p>
            
            <pre>Album.plugin :schema&#x000A;Album.table_exists?</pre>
            
            <h4 id="label-transaction"><code>transaction</code></h4>
            
            <p>As mentioned earlier, <code>transaction</code> is a database method in <a
            href="../../classes/Sequel.html">Sequel</a>, which you can access via the
            <code>db</code> method:</p>
            
            <pre>Album.db.transaction{}</pre>
            
            <h4 id="label-update%2C+update_all"><code>update</code>, <code>update_all</code></h4>
            
            <p>Just like <code>delete</code> and <code>destroy</code>, you filter first,
            then <code>update</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">id</span>).<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'RF'</span>)&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(<span class="ruby-string">&quot;artist_id = ?&quot;</span>, <span class="ruby-value">5</span>).<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">copies_sold=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">0</span>)</pre>
            
            <p>Likewise, to update all rows in the model:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">dataset</span>.<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'RF'</span>)</pre>
            
            <p>Note that <code>update</code> in that case will operate on a dataset, so it
            won’t run model validations or hooks.  If you want those run:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>[<span class="ruby-identifier">id</span>].<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'RF'</span>)&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(<span class="ruby-string">&quot;artist_id = ?&quot;</span>, <span class="ruby-value">5</span>).<span class="ruby-identifier">all</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">copies_sold=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">0</span>)}</pre>
            
            <h4 id="label-with_scope"><code>with_scope</code></h4>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> works a little differently
            than with_scope.  Instead of using nested blocks, you just use a cleaner
            method chain.  <code>with_scope</code> is often used as an around_filter or
            similar construct, where in <a href="../../classes/Sequel.html">Sequel</a>,
            you would just need to assign to a dataset in a before filter, and use that
            dataset in the action.</p>
            
            <h3 id="label-Class+Methods+with+Roughly+the+Same+Behavior">Class Methods with Roughly the Same Behavior</h3>
            
            <p>Note that <a href="../../classes/Sequel.html">Sequel</a> uses symbols
            almost everywhere to represent columns, while ActiveRecord often returns
            columns as strings.</p>
            <dl class="rdoc-list note-list"><dt>ActiveRecord Method 
            <dd>
            <p><a href="../../classes/Sequel.html">Sequel</a> Method</p>
            </dd><dt><code>attr_accessible</code> 
            <dd>
            <p><code>set_allowed_columns</code></p>
            </dd><dt><code>attr_protected</code> 
            <dd>
            <p><code>set_restricted_columns</code></p>
            </dd><dt><code>average</code> 
            <dd>
            <p><code>avg</code></p>
            </dd><dt><code>belongs_to</code> 
            <dd>
            <p><code>many_to_one</code></p>
            </dd><dt><code>columns_hash</code> 
            <dd>
            <p><code>db_schema</code></p>
            </dd><dt><code>count</code> 
            <dd>
            <p><code>count</code></p>
            </dd><dt><code>changed</code> 
            <dd>
            <p><code>changed_columns</code></p>
            </dd><dt><code>create</code> 
            <dd>
            <p><code>create</code></p>
            </dd><dt><code>has_and_belongs_to_many</code> 
            <dd>
            <p><code>many_to_many</code></p>
            </dd><dt><code>has_one</code> 
            <dd>
            <p><code>one_to_one</code></p>
            </dd><dt><code>has_many</code> 
            <dd>
            <p><code>one_to_many</code></p>
            </dd><dt><code>inheritance_column</code> 
            <dd>
            <p><code>sti_key</code></p>
            </dd><dt><code>inspect</code> 
            <dd>
            <p><code>inspect</code></p>
            </dd><dt><code>maximum</code> 
            <dd>
            <p><code>max</code></p>
            </dd><dt><code>minimum</code> 
            <dd>
            <p><code>min</code></p>
            </dd><dt><code>new</code> 
            <dd>
            <p><code>new</code></p>
            </dd><dt><code>primary_key</code> 
            <dd>
            <p><code>primary_key</code></p>
            </dd><dt><code>respond_to?</code> 
            <dd>
            <p><code>respond_to?</code></p>
            </dd><dt><code>set_primary_key</code> 
            <dd>
            <p><code>set_primary_key</code></p>
            </dd><dt><code>sum</code> 
            <dd>
            <p><code>sum</code></p>
            </dd><dt><code>table_name</code> 
            <dd>
            <p><code>table_name</code></p>
            </dd><dt><code>unscoped</code> 
            <dd>
            <p><code>unfiltered</code></p>
            </dd></dl>
            
            <h3 id="label-Class+Methods+without+an+Equivalent">Class Methods without an Equivalent</h3>
            <dl class="rdoc-list note-list"><dt>ActiveRecord Method 
            <dd>
            <p>Notes, Workarounds</p>
            </dd><dt><code>accepts_nested_attributes_for</code> 
            <dd>
            <p>Use the <code>nested_attributes</code> plugin</p>
            </dd><dt><code>attr_readonly</code> 
            <dd>
            <p>Don’t update the columns (duh!), or add a before_update hook that deletes
            them from the values hash</p>
            </dd><dt><code>attribute_method_suffix</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>alias_attribute_with_dirty</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>base_class</code> 
            <dd>
            <p>Not needed internally, you can probably use <code>sti_dataset.model</code>
            if you are using single table inheritance</p>
            </dd><dt><code>benchmark</code> 
            <dd>
            <p>Just use the <code>benchmark</code> library from ruby’s stdlib</p>
            </dd><dt><code>calculate</code> 
            <dd>
            <p>No direct equivalent, just build the query manually and execute it</p>
            </dd><dt><code>cache</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>cache_attribute?</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>cache_attributes</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>cached_attributes</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>changed?</code> 
            <dd>
            <p><code>changed_columns.include?(column)</code></p>
            </dd><dt><code>changes</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>clear_active_connections!</code> 
            <dd>
            <p><a href="../../classes/Sequel.html">Sequel</a> doesn't leak connections
            like ActiveRecord, so you don't need to worry about this</p>
            </dd><dt><code>clear_reloadable_connections!</code> 
            <dd>
            <p><a href="../../classes/Sequel.html">Sequel</a> doesn't leak connections
            like ActiveRecord, so you don't need to worry about this</p>
            </dd><dt><code>content_columns</code> 
            <dd>
            <p>Not needed internally, you can probably do <code>Album.columns.map{|x|&#x000A;x.to_s}.delete_if{|x| x == Album.primary_key || x =~&#x000A;/_(id|count)\z/}</code></p>
            </dd><dt><code>decrement_counter</code> 
            <dd>
            <p><code>Album.where(:id=&gt;:id).update(:counter_name=&gt;Sequel.-(:counter_name,&#x000A;1))</code></p>
            </dd><dt><code>define_attribute_methods</code>, <code>define_read_methods</code> 
            <dd>
            <p><code>def_column_accessor(*columns)</code>, a private method</p>
            </dd><dt><code>descends_from_active_record?</code> 
            <dd>
            <p>Not needed internally, if using single table inheritance,
            <code>Album.sti_dataset.model == Album</code></p>
            </dd><dt><code>find_each</code>, <code>find_in_batches</code> 
            <dd>
            <p>Use the <code>pagination</code> extension</p>
            </dd><dt><code>generated_methods?</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>increment_counter</code> 
            <dd>
            <p><code>Album.where(:id=&gt;:id).update(:counter_name=&gt;Sequel.+(:counter_name,&#x000A;1))</code></p>
            </dd><dt><code>instance_method_already_implemented?</code> 
            <dd>
            <p>No equivalent, <a href="../../classes/Sequel.html">Sequel</a> does not
            create column accessors that override other methods, it just skips them.</p>
            </dd><dt><code>match_attribute_method?</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>readonly_attributes</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>remove_connection</code> 
            <dd>
            <p>Not necessary in <a href="../../classes/Sequel.html">Sequel</a>.  If you
            want to disconnect an existing connection: <code>Album.db.disconnect</code></p>
            </dd><dt><code>require_mysql</code> 
            <dd>
            <p>A public method, really?</p>
            </dd><dt><code>silence</code> 
            <dd>
            <p>No equivalent.  Because the logger is handled at the
            <code>Sequel::Database</code> level, there is no thread-safe way to turn it
            off for specific blocks.</p>
            </dd><dt><code>scopes</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>sti_name</code> 
            <dd>
            <p>No equivalent.</p>
            </dd><dt><code>update_counters</code> 
            <dd>
            <p><code>Album.where(:id=&gt;:id).update(:counter_name=&gt;:counter_name + 1,&#x000A;:other_counter=&gt;:other_counter - 1)</code></p>
            </dd><dt><code>uncached</code> 
            <dd>
            <p>No equivalent</p>
            </dd></dl>
            
            <h3 id="label-Instance+Methods+with+Significantly+Different+Behavior">Instance Methods with Significantly Different Behavior</h3>
            
            <h4 id="label-attribute_names"><code>attribute_names</code></h4>
            
            <p><code>keys</code> returns the columns as unsorted symbols, so:</p>
            
            <pre class="ruby"><span class="ruby-identifier">album</span>.<span class="ruby-identifier">keys</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">to_s</span>}.<span class="ruby-identifier">sort</span></pre>
            
            <h4 id="label-becomes"><code>becomes</code></h4>
            
            <p>Assuming the record already exists in the database:</p>
            
            <pre>gold_album = GoldAlbum[1]&#x000A;album = Album.load(gold_album.values)</pre>
            
            <p>If it is a new record:</p>
            
            <pre class="ruby"><span class="ruby-identifier">gold_album</span> = <span class="ruby-constant">GoldAlbum</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'a'</span>)&#x000A;<span class="ruby-identifier">album</span> = <span class="ruby-constant">Album</span>.<span class="ruby-identifier">new</span>&#x000A;<span class="ruby-identifier">album</span>.<span class="ruby-identifier">send</span>(:<span class="ruby-identifier">set_values</span>, <span class="ruby-identifier">gold_album</span>.<span class="ruby-identifier">values</span>)</pre>
            
            <h4 id="label-column_for_attribute"><code>column_for_attribute</code></h4>
            
            <p>You can access this through the <code>db_schema</code> hash:</p>
            
            <pre>album.db_schema[:column]</pre>
            
            <h4 id="label-connection"><code>connection</code></h4>
            
            <p>Just like in the class method, you have to access it through the database:</p>
            
            <pre class="ruby"><span class="ruby-identifier">album</span>.<span class="ruby-identifier">db</span>.<span class="ruby-identifier">synchronize</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">connection</span><span class="ruby-operator">|</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-decrement%2C+increment"><code>decrement</code>, <code>increment</code></h4>
            
            <p>You can just modify the values hash directly:</p>
            
            <pre>album.values[:column] ||= 0&#x000A;album.values[:column] -= 1 # or += 1 for increment</pre>
            
            <h4 id="label-decrement%21%2C+increment%21"><code>decrement!</code>, <code>increment!</code></h4>
            
            <p>Assuming you want the full behavior of saving just one column without
            validating:</p>
            
            <pre class="ruby"><span class="ruby-identifier">album</span>.<span class="ruby-identifier">values</span>[:<span class="ruby-identifier">column</span>] <span class="ruby-operator">||=</span> <span class="ruby-value">0</span>&#x000A;<span class="ruby-identifier">album</span>.<span class="ruby-identifier">values</span>[:<span class="ruby-identifier">column</span>] <span class="ruby-operator">-=</span> <span class="ruby-value">1</span> <span class="ruby-comment"># or += 1 for increment!</span>&#x000A;<span class="ruby-identifier">album</span>.<span class="ruby-identifier">save</span>(:<span class="ruby-identifier">columns=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">column</span>], :<span class="ruby-identifier">validate=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">false</span>)</pre>
            
            <h4 id="label-has_attribute%3F"><code>has_attribute?</code></h4>
            
            <p>You have to check the values hash:</p>
            
            <pre>album.values.has_key?(:column)</pre>
            
            <h4 id="label-invalid%3F"><code>invalid?</code></h4>
            
            <p>You can use <code>unless valid?</code> or <code>!valid?</code>.</p>
            
            <h4 id="label-save%2C+save%21%2C+save_with_validation%2C+save_with_validation%21"><code>save</code>, <code>save!</code>, <code>save_with_validation</code>, <code>save_with_validation!</code></h4>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> defaults to raising
            exceptions when <code>save</code> fails, but this is configurable behavior
            by setting the <code>raise_on_save_failure</code> flag on the class or
            instance:</p>
            
            <pre>album.raise_on_save_failure = true&#x000A;album.save # raise exception if failure&#x000A;album.raise_on_save_failure = false&#x000A;album.save # return nil if failure</pre>
            
            <p>You can pass the <code>:validate=&gt;false</code> option to not validate
            the object when saving.</p>
            
            <h4 id="label-toggle%2C+toggle"><code>toggle</code>, <code>toggle</code></h4>
            
            <p>No equivalent, but very easy to add:</p>
            
            <pre>album.column = !album.column</pre>
            
            <p>If you want to save just that column:</p>
            
            <pre class="ruby"><span class="ruby-identifier">album</span>.<span class="ruby-identifier">save</span>(:<span class="ruby-identifier">columns=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">column</span>], :<span class="ruby-identifier">validate=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">false</span>)</pre>
            
            <h4 id="label-transaction"><code>transaction</code></h4>
            
            <p>Just like in the class, you can access the transaction method through the
            <code>db</code>:</p>
            
            <pre>album.db.transaction{}</pre>
            
            <h4 id="label-update_attribute"><code>update_attribute</code></h4>
            
            <p>To only set and save a specific column:</p>
            
            <pre class="ruby"><span class="ruby-identifier">album</span>.<span class="ruby-identifier">set</span>(:<span class="ruby-identifier">column</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">value</span>)&#x000A;<span class="ruby-identifier">album</span>.<span class="ruby-identifier">save</span>(:<span class="ruby-identifier">columns=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">column</span>], :<span class="ruby-identifier">validate=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">false</span>)</pre>
            
            <h4 id="label-update_attributes%2C+update_attributes%21"><code>update_attributes</code>, <code>update_attributes!</code></h4>
            
            <p>These would both use <code>update</code>, but see the notes on the
            <code>raise_on_save_failure</code> flag:</p>
            
            <pre class="ruby"><span class="ruby-identifier">album</span>.<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">column1=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">value1</span>, :<span class="ruby-identifier">column2=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">value2</span>)</pre>
            
            <h3 id="label-Instance+Methods+with+Roughly+the+Same+Behavior">Instance Methods with Roughly the Same Behavior</h3>
            
            <p>Note that <a href="../../classes/Sequel.html">Sequel</a> uses symbols
            almost everywhere to represent columns, while ActiveRecord often returns
            columns as strings.</p>
            <dl class="rdoc-list note-list"><dt>ActiveRecord Method 
            <dd>
            <p><a href="../../classes/Sequel.html">Sequel</a> Method</p>
            </dd><dt><code>==</code> 
            <dd>
            <p><code>===</code>, <code>==</code> compares by all values, not just id</p>
            </dd><dt><code>[]</code> 
            <dd>
            <p><code>[]</code></p>
            </dd><dt><code>[]=</code> 
            <dd>
            <p><code>[]=</code></p>
            </dd><dt><code>after_create</code> 
            <dd>
            <p><code>after_create</code></p>
            </dd><dt><code>after_destroy</code> 
            <dd>
            <p><code>after_destroy</code></p>
            </dd><dt><code>after_save</code> 
            <dd>
            <p><code>after_save</code></p>
            </dd><dt><code>after_update</code> 
            <dd>
            <p><code>after_update</code></p>
            </dd><dt><code>after_validation</code> 
            <dd>
            <p><code>after_validation</code></p>
            </dd><dt><code>attributes</code> 
            <dd>
            <p><code>values</code></p>
            </dd><dt><code>attributes=</code> 
            <dd>
            <p><code>set</code></p>
            </dd><dt><code>before_create</code> 
            <dd>
            <p><code>before_create</code></p>
            </dd><dt><code>before_destroy</code> 
            <dd>
            <p><code>before_destroy</code></p>
            </dd><dt><code>before_save</code> 
            <dd>
            <p><code>before_save</code></p>
            </dd><dt><code>before_update</code> 
            <dd>
            <p><code>before_update</code></p>
            </dd><dt><code>before_validation</code> 
            <dd>
            <p><code>before_validation</code></p>
            </dd><dt><code>cache_key</code> 
            <dd>
            <p><code>cache_key</code>, if using the <code>caching</code> plugin</p>
            </dd><dt><code>destroy</code> 
            <dd>
            <p><code>destroy</code></p>
            </dd><dt><code>eql?</code> 
            <dd>
            <p><code>===</code></p>
            </dd><dt><code>errors</code> 
            <dd>
            <p><code>errors</code></p>
            </dd><dt><code>freeze</code> 
            <dd>
            <p><code>freeze</code></p>
            </dd><dt><code>frozen?</code> 
            <dd>
            <p><code>frozen?</code></p>
            </dd><dt><code>hash</code> 
            <dd>
            <p><code>hash</code></p>
            </dd><dt><code>id</code> 
            <dd>
            <p><code>pk</code></p>
            </dd><dt><code>inspect</code> 
            <dd>
            <p><code>inspect</code></p>
            </dd><dt><code>lock!</code> 
            <dd>
            <p><code>lock!</code></p>
            </dd><dt><code>new_record?</code> 
            <dd>
            <p><code>new?</code></p>
            </dd><dt><code>reload_with_autosave_associations</code> 
            <dd>
            <p><code>reload</code></p>
            </dd><dt><code>to_param</code> 
            <dd>
            <p><code>to_param</code>, if using the <code>active_model</code> plugin</p>
            </dd><dt><code>touch</code> 
            <dd>
            <p><code>touch</code>, if using the <code>touch</code> plugin</p>
            </dd><dt><code>valid?</code> 
            <dd>
            <p><code>valid?</code></p>
            </dd></dl>
            
            <h3 id="label-Instance+Methods+without+an+Equivalent">Instance Methods without an Equivalent</h3>
            <dl class="rdoc-list note-list"><dt>ActiveRecord Method 
            <dd>
            <p>Notes, Workarounds</p>
            </dd><dt><code>after_validation_on_create</code>, <code>after_validation_on_update</code> 
            <dd>
            <p>Use <code>after_validation</code> and <code>if new?</code> or <code>unless&#x000A;new?</code></p>
            </dd><dt><code>as_json</code>, <code>from_json</code>, <code>to_json</code> 
            <dd>
            <p>Use the <code>json_serializer</code> plugin</p>
            </dd><dt><code>from_xml</code>, <code>to_xml</code> 
            <dd>
            <p>Use the <code>xml_serializer</code> plugin</p>
            </dd><dt><code>attribute_for_inspect</code> 
            <dd>
            <p><code>album[:column].inspect</code></p>
            </dd><dt><code>attribute_present?</code> 
            <dd>
            <p><code>!album[:column].blank?</code> if using the <code>blank</code>
            extension</p>
            </dd><dt><code>attributes_before_type_cast</code> 
            <dd>
            <p><a href="../../classes/Sequel.html">Sequel</a> typecasts at a low level, so
            model objects never see values before they are type cast</p>
            </dd><dt><code>before_validation_on_create</code>, <code>before_validation_on_update</code> 
            <dd>
            <p>Use <code>before_validation</code> and <code>if new?</code> or <code>unless&#x000A;new?</code></p>
            </dd><dt><code>id=</code> 
            <dd>
            <p><a href="../../classes/Sequel.html">Sequel</a> doesn't have a special
            primary key setter method, but you can use:
            <code>album.send(&quot;#{Album.primary_key}=&quot;, value)</code></p>
            </dd><dt><code>mark_for_destruction</code>, <code>marked_for_destruction?</code> 
            <dd>
            <p>Use a <code>before_save</code> or <code>after_save</code> hook or the
            <code>instance_hooks</code> plugin</p>
            </dd><dt><code>readonly!</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>readonly?</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>rollback_active_record_state!</code> 
            <dd>
            <p>No equivalent</p>
            </dd><dt><code>with_transaction_returning_status</code> 
            <dd>
            <p>No equivalent</p>
            </dd></dl>
          </div>
          <div id='context'>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
