<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>advanced_associations.rdoc</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='file' id='wrapper'>
      <div class='header'>
        <h1 class='name'>advanced_associations.rdoc</h1>
        <div class='paths'>
          doc/advanced_associations.rdoc
        </div>
        <div class='last-update'>
          Last Update:
          <span class='datetime'>2013-11-08 08:08:17 -0500</span>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <h1 id="label-Advanced+Associations">Advanced Associations</h1>
            
            <p><a href="../../classes/Sequel/Model.html">Sequel::Model</a> has the most
            powerful and flexible associations of any ruby ORM.</p>
            
            <h2 id="label-Background%3A+Sequel%3A%3AModel+association+options">Background: <a href="../../classes/Sequel/Model.html">Sequel::Model</a> association options</h2>
            
            <p>There are a bunch of advanced association options that are available to
            handle more complex cases.  First we’ll go over some of the simpler ones:</p>
            
            <p>All associations take a block that can be used to further filter/modify the
            default dataset.  There’s also an :eager_block option if you want to use a
            different block when eager loading via <code>Dataset#eager</code>.
            Association blocks are useful for things like:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">gold_albums</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span>:<span class="ruby-constant">Album</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">copies_sold</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">500000</span>}&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>There are a whole bunch of options for changing how the association is
            eagerly loaded via <code>Dataset#eager_graph</code>:
            <code>:graph_block</code>, <code>:graph_conditions</code>,
            <code>:graph_only_conditions</code>, <code>:graph_join_type</code> (and
            <code>:graph_join_table_*</code> ones for JOINing to the join table in a
            many_to_many association).</p>
            <dl class="rdoc-list note-list"><dt>:graph_join_type 
            <dd>
            <p>The type of join to do (<code>:inner</code>, <code>:left</code>,
            <code>:right</code>)</p>
            </dd><dt>:graph_conditions 
            <dd>
            <p>Additional conditions to put on join (needs to be a hash or array of all
            two pairs).  Automatically assumes unqualified symbols or first element of
            the pair to be columns of the associated model, and unqualified symbols of
            the second element of the pair to be columns of the current model.</p>
            </dd><dt>:graph_block 
            <dd>
            <p>A block passed to <code>join_table</code>, allowing you to specify
            conditions other than equality, or to use OR, or set up any arbitrary
            condition.  The block is passed the associated table alias, current table 
            alias, and an array of previous joins clause objects.</p>
            </dd><dt>:graph_only_conditions 
            <dd>
            <p>Use these conditions instead of the standard association conditions. This
            is necessary when you don’t want to have an equal condition between the
            foreign key and primary key of the tables. You can also use this to have a
            JOIN USING (array of symbols), or a NATURAL or CROSS JOIN (nil, with the
            appropriate <code>:graph_join_type</code>).</p>
            </dd></dl>
            
            <p>These can be used like this:</p>
            
            <pre class="ruby"><span class="ruby-comment"># Makes Artist.eager_graph(:required_albums).all not return artists that</span>&#x000A;<span class="ruby-comment"># don't have any albums</span>&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">required_albums</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span>:<span class="ruby-constant">Album</span>, :<span class="ruby-identifier">graph_join_type=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">inner</span>&#x000A;&#x000A;<span class="ruby-comment"># Makes sure all returned albums have the active flag set</span>&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">active_albums</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span>:<span class="ruby-constant">Album</span>,    :<span class="ruby-identifier">graph_conditions=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">active=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>}&#x000A;&#x000A;<span class="ruby-comment"># Only returns albums that have sold more than 500,000 copies</span>&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">gold_albums</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span>:<span class="ruby-constant">Album</span>,    :<span class="ruby-identifier">graph_block=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">j</span>,<span class="ruby-identifier">lj</span>,<span class="ruby-identifier">js</span><span class="ruby-operator">|</span> <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">qualify</span>(<span class="ruby-identifier">j</span>, :<span class="ruby-identifier">copies_sold</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-value">500000</span>}&#x000A;&#x000A;<span class="ruby-comment"># Handles the case where the tables are associated by a case insensitive name string</span>&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>, :<span class="ruby-identifier">key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artist_name</span>,    :<span class="ruby-identifier">graph_only_conditions=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">nil</span>,    :<span class="ruby-identifier">graph_block=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">j</span>,<span class="ruby-identifier">lj</span>,<span class="ruby-identifier">js</span><span class="ruby-operator">|</span> {<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">function</span>(:<span class="ruby-identifier">lower</span>, <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">qualify</span>(<span class="ruby-identifier">j</span>, :<span class="ruby-identifier">artist_name</span>))=<span class="ruby-operator">&gt;</span><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">function</span>(:<span class="ruby-identifier">lower</span>, <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">qualify</span>(<span class="ruby-identifier">lj</span>, :<span class="ruby-identifier">name</span>))}}&#x000A;&#x000A;<span class="ruby-comment"># Handles the case where both key columns have the name artist_name, and you want to use</span>&#x000A;<span class="ruby-comment"># a JOIN USING</span>&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>, :<span class="ruby-identifier">key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artist_name</span>, :<span class="ruby-identifier">graph_only_conditions=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">artist_name</span>]</pre>
            
            <p>Remember, using <code>eager_graph</code> is generally only necessary when
            you need to filter/order based on columns in an associated table, it is
            recommended to use <code>eager</code> for eager loading if possible.</p>
            
            <p>One advantage of using <code>eager_graph</code> is that you can easily
            filter/order on columns in an associated table on a per-query basis, using
            regular <a href="../../classes/Sequel.html">Sequel</a> dataset methods. 
            For example, if you only want to retrieve artists who have albums that
            start with A, and eager load just those albums, ordered by the albums name,
            you can do:</p>
            
            <pre>albums = Artist.&#x000A;  eager_graph(:albums).&#x000A;  where(Sequel.like(:albums__name, 'A%')).&#x000A;  order(:albums__name).&#x000A;  all</pre>
            
            <p>For lazy loading (e.g. <a target="_top" href="http://1">Model</a>.association), the
            <code>:dataset</code> option can be used to specify an arbitrary dataset
            (one that uses different keys, multiple keys, joins to other tables, etc.).</p>
            
            <p>For eager loading via <code>eager</code>, the <code>:eager_loader</code>
            option can be used to specify how to eagerly load a complex association. 
            This is an extremely powerful option.  Though it can often be verbose
            (compared to other things in <a
            href="../../classes/Sequel.html">Sequel</a>), it allows you complete
            control over how to eagerly load associations for a group of objects.</p>
            
            <p>:eager_loader should be a proc that takes a single hash argument, which
            will have at least the following keys:</p>
            <dl class="rdoc-list note-list"><dt>:id_map 
            <dd>
            <p>A mapping of key values to arrays of current model instances, usage
            described below</p>
            </dd><dt>:rows 
            <dd>
            <p>An array of model objects</p>
            </dd><dt>:associations 
            <dd>
            <p>A hash of dependent associations to eagerly load</p>
            </dd><dt>:self 
            <dd>
            <p>The dataset that is doing the eager loading</p>
            </dd><dt>:eager_block 
            <dd>
            <p>A dynamic callback for this eager load.</p>
            </dd></dl>
            
            <p>Since you are given all of the records, you can do things like filter on
            associations that are specified by multiple keys, or do multiple queries
            depending on the content of the records (which would be necessary for
            polymorphic associations).  Inside the <code>:eager_loader</code> proc, you
            should get the related objects and populate the associations cache for all
            objects in the array of records.  The hash of dependent associations is
            available for you to cascade the eager loading down multiple levels, but it
            is up to you to use it.</p>
            
            <p>The id_map is a performance enhancement that is used by the default
            association loaders and is also available to you.  It is a hash with keys
            foreign/primary key values, and values being arrays of current model
            objects having the foreign/primary key value associated with the key.  This
            may be hard to visualize, so I’ll give an example.  Let’s say you have the
            following associations</p>
            
            <pre>Album.many_to_one :artist&#x000A;Album.one_to_many :tracks</pre>
            
            <p>and the following three albums in the database:</p>
            
            <pre class="ruby"><span class="ruby-identifier">album1</span> = <span class="ruby-constant">Album</span>.<span class="ruby-identifier">create</span>(:<span class="ruby-identifier">artist_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">3</span>) <span class="ruby-comment"># id: 1</span>&#x000A;<span class="ruby-identifier">album2</span> = <span class="ruby-constant">Album</span>.<span class="ruby-identifier">create</span>(:<span class="ruby-identifier">artist_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">3</span>) <span class="ruby-comment"># id: 2</span>&#x000A;<span class="ruby-identifier">album3</span> = <span class="ruby-constant">Album</span>.<span class="ruby-identifier">create</span>(:<span class="ruby-identifier">artist_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">2</span>) <span class="ruby-comment"># id: 3</span></pre>
            
            <p>If you try to eager load this dataset:</p>
            
            <pre>Album.eager(:artist, :tracks).all</pre>
            
            <p>Then the id_map provided to the artist :eager_loader proc would be:</p>
            
            <pre class="ruby">{<span class="ruby-value">3</span>=<span class="ruby-operator">&gt;</span>[<span class="ruby-identifier">album1</span>, <span class="ruby-identifier">album2</span>], <span class="ruby-value">2</span>=<span class="ruby-operator">&gt;</span>[<span class="ruby-identifier">album3</span>]}</pre>
            
            <p>The artist id_map contains a mapping of artist_id values to arrays of album
            objects.  Since both album1 and album2 have the same artist_id, the are
            both in the array related to that key.  album3 has a different artist_id,
            so it is in a different array. Eager loading of artists is done by looking
            for any artist having one of the keys in the hash:</p>
            
            <pre class="ruby"><span class="ruby-identifier">artists</span> = <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">id_map</span>.<span class="ruby-identifier">keys</span>).<span class="ruby-identifier">all</span></pre>
            
            <p>When the artists are retrieved, you can iterate over them, find entries
            with matching keys, and manually associate them to the albums:</p>
            
            <pre class="ruby"><span class="ruby-identifier">artists</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">artist</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-comment"># Find related albums using the artist_id_map</span>&#x000A;  <span class="ruby-keyword">if</span> <span class="ruby-identifier">albums</span> = <span class="ruby-identifier">id_map</span>[<span class="ruby-identifier">artist</span>.<span class="ruby-identifier">id</span>]&#x000A;    <span class="ruby-comment"># Iterate over the albums</span>&#x000A;    <span class="ruby-identifier">albums</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">album</span><span class="ruby-operator">|</span>&#x000A;      <span class="ruby-comment"># Manually set the artist association for each album</span>&#x000A;      <span class="ruby-identifier">album</span>.<span class="ruby-identifier">associations</span>[:<span class="ruby-identifier">artist</span>] = <span class="ruby-identifier">artist</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>The id_map provided to the tracks :eager_loader proc would be:</p>
            
            <pre class="ruby">{<span class="ruby-value">1</span>=<span class="ruby-operator">&gt;</span>[<span class="ruby-identifier">album1</span>], <span class="ruby-value">2</span>=<span class="ruby-operator">&gt;</span>[<span class="ruby-identifier">album2</span>], <span class="ruby-value">3</span>=<span class="ruby-operator">&gt;</span>[<span class="ruby-identifier">album3</span>]}</pre>
            
            <p>Now the id_map contains a mapping of id values to arrays of album objects
            (in this case each array only has a single object, because id is the
            primary key).  So when looking for tracks to eagerly load, you only need to
            look for ones that have an album_id with one of the keys in the hash:</p>
            
            <pre class="ruby"><span class="ruby-identifier">tracks</span> = <span class="ruby-constant">Track</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">album_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">id_map</span>.<span class="ruby-identifier">keys</span>).<span class="ruby-identifier">all</span></pre>
            
            <p>When the tracks are retrieved, you can iterate over them, find entries with
            matching keys, and manually associate them to the albums:</p>
            
            <pre class="ruby"><span class="ruby-identifier">tracks</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">track</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-keyword">if</span> <span class="ruby-identifier">albums</span> = <span class="ruby-identifier">id_map</span>[<span class="ruby-identifier">track</span>.<span class="ruby-identifier">album_id</span>]&#x000A;    <span class="ruby-identifier">albums</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">album</span><span class="ruby-operator">|</span>&#x000A;      <span class="ruby-identifier">album</span>.<span class="ruby-identifier">associations</span>[:<span class="ruby-identifier">tracks</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">track</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-Two+basic+example+eager+loaders">Two basic example eager loaders</h3>
            
            <p>Putting the code in the above examples together, you almost have enough for
            a basic working eager loader.  The main important thing that is missing is
            you need to set initial values for the eagerly loaded associations.  For
            the artist association, you need to initial the values to nil:</p>
            
            <pre class="ruby"><span class="ruby-comment"># rows here is the :rows entry in the hash passed to the eager loader</span>&#x000A;<span class="ruby-identifier">rows</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">album</span><span class="ruby-operator">|</span> <span class="ruby-identifier">album</span>.<span class="ruby-identifier">associations</span>[:<span class="ruby-identifier">artist</span>] = <span class="ruby-keyword">nil</span>}</pre>
            
            <p>For the tracks association, you set the initial value to an empty array:</p>
            
            <pre class="ruby"><span class="ruby-identifier">rows</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">album</span><span class="ruby-operator">|</span> <span class="ruby-identifier">album</span>.<span class="ruby-identifier">associations</span>[:<span class="ruby-identifier">track</span>] = []}</pre>
            
            <p>These are done so that if an album currently being loaded doesn’t have an
            associated artist or any associated tracks, the lack of them will be
            cached, so calling the artist or tracks method on the album will not do
            another database lookup.</p>
            
            <p>So putting everything together, the artist eager loader looks like:</p>
            
            <pre class="ruby">:<span class="ruby-identifier">eager_loader=</span><span class="ruby-operator">&gt;</span>(<span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">eo_opts</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">eo_opts</span>[:<span class="ruby-identifier">rows</span>].<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">album</span><span class="ruby-operator">|</span> <span class="ruby-identifier">album</span>.<span class="ruby-identifier">associations</span>[:<span class="ruby-identifier">artist</span>] = <span class="ruby-keyword">nil</span>}&#x000A;  <span class="ruby-identifier">id_map</span> = <span class="ruby-identifier">eo_opts</span>[:<span class="ruby-identifier">id_map</span>]&#x000A;  <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">id_map</span>.<span class="ruby-identifier">keys</span>).<span class="ruby-identifier">all</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">artist</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-keyword">if</span> <span class="ruby-identifier">albums</span> = <span class="ruby-identifier">id_map</span>[<span class="ruby-identifier">artist</span>.<span class="ruby-identifier">id</span>]&#x000A;      <span class="ruby-identifier">albums</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">album</span><span class="ruby-operator">|</span>&#x000A;        <span class="ruby-identifier">album</span>.<span class="ruby-identifier">associations</span>[:<span class="ruby-identifier">artist</span>] = <span class="ruby-identifier">artist</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span>)</pre>
            
            <p>and the tracks eager loader looks like:</p>
            
            <pre class="ruby">:<span class="ruby-identifier">eager_loader=</span><span class="ruby-operator">&gt;</span>(<span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">eo_opts</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">eo_opts</span>[:<span class="ruby-identifier">rows</span>].<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">album</span><span class="ruby-operator">|</span> <span class="ruby-identifier">album</span>.<span class="ruby-identifier">associations</span>[:<span class="ruby-identifier">tracks</span>] = []}&#x000A;  <span class="ruby-identifier">id_map</span> = <span class="ruby-identifier">eo_opts</span>[:<span class="ruby-identifier">id_map</span>]&#x000A;  <span class="ruby-constant">Track</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">id_map</span>.<span class="ruby-identifier">keys</span>).<span class="ruby-identifier">all</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">tracks</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-keyword">if</span> <span class="ruby-identifier">albums</span> = <span class="ruby-identifier">id_map</span>[<span class="ruby-identifier">track</span>.<span class="ruby-identifier">album_id</span>]&#x000A;      <span class="ruby-identifier">albums</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">album</span><span class="ruby-operator">|</span>&#x000A;        <span class="ruby-identifier">album</span>.<span class="ruby-identifier">associations</span>[:<span class="ruby-identifier">tracks</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">track</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span>)</pre>
            
            <p>Now, these are both overly simplistic eager loaders that don’t respect
            cascaded associations or any of the association options.  But hopefully
            they both provide simple examples that you can more easily build and learn
            from, as  the custom eager loaders described later in this page are more
            complex.</p>
            
            <p>Basically, the eager loading steps can be broken down into:</p>
            <ol><li>
            <p>Set default association values (nil/[]) for each of the current objects</p>
            </li><li>
            <p>Return just related associated objects by filtering the associated class to
            include only rows with keys present in the id_map.</p>
            </li><li>
            <p>Iterating over the returned associated objects, indexing into the id_map
            using the foreign/primary key value in the associated object to get current
            values associated to that specific object.</p>
            </li><li>
            <p>For each of those current values, updating the cached association value to
            include that specific object.</p>
            </li></ol>
            
            <p>Using the :eager_loader proc, you should be able to eagerly load all
            associations that can be eagerly loaded, even if <a
            href="../../classes/Sequel.html">Sequel</a> doesn’t natively support such
            eager loading.</p>
            
            <h2 id="label-ActiveRecord+associations">ActiveRecord associations</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> supports all of associations
            that ActiveRecord supports, though some require different approaches or
            custom <code>:eager_loader</code> options.</p>
            
            <h3 id="label-Association+callbacks">Association callbacks</h3>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> supports the same callbacks
            that ActiveRecord does for <code>one_to_many</code> and
            <code>many_to_many</code> associations: <code>:before_add</code>,
            <code>:before_remove</code>, <code>:after_add</code>, and
            <code>:after_remove</code>. For <code>many_to_one</code> associations and
            <code>one_to_one</code> associations, <a
            href="../../classes/Sequel.html">Sequel</a> supports the
            <code>:before_set</code> and <code>:after_set</code> callbacks.  On all
            associations, <a href="../../classes/Sequel.html">Sequel</a> supports
            <code>:after_load</code>, which is called after the association has been
            loaded.</p>
            
            <p>Each of these options can be a symbol specifying an instance method that
            takes one argument (the associated object), or a proc that takes two
            arguments (the current object and the associated object), or an array of
            symbols and procs.  For <code>:after_load</code> with a *_to_many
            association, the associated object argument is an array of associated
            objects.</p>
            
            <p>If any of the before callbacks return <code>false</code>, the
            adding/removing does not happen and it either raises a
            <code>Sequel::BeforeHookFailed</code> (the default), or returns false (if
            <code>raise_on_save_failure</code> is false).</p>
            
            <h3 id="label-Association+extensions">Association extensions</h3>
            
            <p>All associations come with an <code><em>association</em>_dataset</code>
            method that can be further filtered or otherwise modified:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Author</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">authorships</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-constant">Author</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">authorships_dataset</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">number</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">10</span>}.<span class="ruby-identifier">first</span></pre>
            
            <p>You can extend a dataset with a module using the <code>:extend</code>
            association option.  You can reference the model object that created the
            association dataset via the dataset’s <code>model_object</code> method, and
            the related association reflection via the dataset’s
            <code>association_reflection</code> method:</p>
            
            <pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">FindOrCreate</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">find_or_create</span>(<span class="ruby-identifier">vals</span>)&#x000A;    <span class="ruby-identifier">first</span>(<span class="ruby-identifier">vals</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">model</span>.<span class="ruby-identifier">create</span>(<span class="ruby-identifier">vals</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">association_reflection</span>[:<span class="ruby-identifier">key</span>]=<span class="ruby-operator">&gt;</span><span class="ruby-identifier">model_object</span>.<span class="ruby-identifier">id</span>))&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Author</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">authorships</span>, :<span class="ruby-identifier">extend=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">FindOrCreate</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-constant">Author</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">authorships_dataset</span>.<span class="ruby-identifier">find_or_create</span>(:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'Blah'</span>, :<span class="ruby-identifier">number=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">10</span>)</pre>
            
            <h3 id="label-has_many+%3Athrough+associations"><code>has_many :through</code> associations</h3>
            
            <p><code>many_to_many</code> handles the usual case of a <code>has_many&#x000A;:through</code> with a <code>belongs_to</code> in the associated model.  It
            doesn't break on the case where the join table is a model table, unlike
            ActiveRecord's <code>has_and_belongs_to_many</code>.</p>
            
            <p>ActiveRecord:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Author</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>&#x000A;  <span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">authorships</span>&#x000A;  <span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">books</span>, :<span class="ruby-identifier">through</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">authorships</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Authorship</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>&#x000A;  <span class="ruby-identifier">belongs_to</span> :<span class="ruby-identifier">author</span>&#x000A;  <span class="ruby-identifier">belongs_to</span> :<span class="ruby-identifier">book</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-ivar">@author</span> = <span class="ruby-constant">Author</span>.<span class="ruby-identifier">find</span> :<span class="ruby-identifier">first</span>&#x000A;<span class="ruby-ivar">@author</span>.<span class="ruby-identifier">books</span></pre>
            
            <p>Sequel::Model:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Author</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">authorships</span>&#x000A;  <span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">books</span>, :<span class="ruby-identifier">join_table=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">authorships</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Authorship</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">author</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">book</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-ivar">@author</span> = <span class="ruby-constant">Author</span>.<span class="ruby-identifier">first</span>&#x000A;<span class="ruby-ivar">@author</span>.<span class="ruby-identifier">books</span></pre>
            
            <p>If you use an association other than <code>belongs_to</code> in the
            associated model, such as a <code>has_many</code>, you still use a
            <code>many_to_many</code> association, but you need to use some options:</p>
            
            <p>ActiveRecord:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Firm</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>&#x000A;  <span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">clients</span>&#x000A;  <span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">invoices</span>, :<span class="ruby-identifier">through</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">clients</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Client</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>&#x000A;  <span class="ruby-identifier">belongs_to</span> :<span class="ruby-identifier">firm</span>&#x000A;  <span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">invoices</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Invoice</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>&#x000A;  <span class="ruby-identifier">belongs_to</span> :<span class="ruby-identifier">client</span>&#x000A;  <span class="ruby-identifier">has_one</span> :<span class="ruby-identifier">firm</span>, :<span class="ruby-identifier">through</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">client</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-constant">Firm</span>.<span class="ruby-identifier">find</span>(:<span class="ruby-identifier">first</span>).<span class="ruby-identifier">invoices</span></pre>
            
            <p>Sequel::Model:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Firm</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">clients</span>&#x000A;  <span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">invoices</span>, :<span class="ruby-identifier">join_table=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">clients</span>, :<span class="ruby-identifier">right_key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">right_primary_key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">client_id</span>&#x000A;<span class="ruby-keyword">end</span> &#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Client</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">firm</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">invoices</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Invoice</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">client</span>&#x000A;&#x000A;  <span class="ruby-comment"># has_one :through equivalent 1</span>&#x000A;  <span class="ruby-comment"># eager load with :eager=&gt;:firm option on :client association, and eager loading :client</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">firm</span>&#x000A;    <span class="ruby-identifier">client</span>.<span class="ruby-identifier">firm</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">client</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-comment"># has_one :through equivalent 2</span>&#x000A;  <span class="ruby-comment"># eager load the usual way</span>&#x000A;  <span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">firms</span>, :<span class="ruby-identifier">join_table=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">clients</span>, :<span class="ruby-identifier">left_key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">left_primary_key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">client_id</span>, :<span class="ruby-identifier">right_key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">firm_id</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">firm</span>&#x000A;    <span class="ruby-identifier">firms</span>.<span class="ruby-identifier">first</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-comment"># has_one :through equivalent 3</span>&#x000A;  <span class="ruby-comment"># eager loading requires custom :eager_loader proc</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">firm</span>, :<span class="ruby-identifier">dataset=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-constant">Firm</span>.<span class="ruby-identifier">join</span>(:<span class="ruby-identifier">clients</span>, :<span class="ruby-identifier">firm_id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">client_id</span>).<span class="ruby-identifier">select_all</span>(:<span class="ruby-identifier">firms</span>)}&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-constant">Firm</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">invoices</span></pre>
            
            <h3 id="label-Polymorphic+Associations">Polymorphic Associations</h3>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> discourages the use of
            polymorphic associations, which is the reason they are not supported by
            default.  All polymorphic associations can be made non-polymorphic by using
            additional tables and/or columns instead of having a column containing the
            associated class name as a string.</p>
            
            <p>Polymorphic associations break referential integrity and are significantly
            more complex than non-polymorphic associations, so their use is not
            recommended unless you are stuck with an existing design that uses them.</p>
            
            <p>If you must use them, look for the sequel_polymorphic external plugin, as
            it makes using polymorphic associations in <a
            href="../../classes/Sequel.html">Sequel</a> about as easy as it is in
            ActiveRecord.  However, here’s how they can be done using Sequel’s custom
            associations (the sequel_polymorphic plugin is just a generic version of
            this code):</p>
            
            <p>ActiveRecord:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Asset</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>&#x000A;  <span class="ruby-identifier">belongs_to</span> :<span class="ruby-identifier">attachable</span>, :<span class="ruby-identifier">polymorphic</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Post</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>&#x000A;  <span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">assets</span>, :<span class="ruby-identifier">as</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">attachable</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Note</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>&#x000A;  <span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">assets</span>, :<span class="ruby-identifier">as</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">attachable</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-ivar">@asset</span>.<span class="ruby-identifier">attachable</span> = <span class="ruby-ivar">@post</span>&#x000A;<span class="ruby-ivar">@asset</span>.<span class="ruby-identifier">attachable</span> = <span class="ruby-ivar">@note</span></pre>
            
            <p>Sequel::Model:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Asset</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">attachable</span>, :<span class="ruby-identifier">reciprocal=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">assets</span>,&#x000A;    :<span class="ruby-identifier">setter=</span><span class="ruby-operator">&gt;</span>(<span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">attachable</span><span class="ruby-operator">|</span>&#x000A;      <span class="ruby-keyword">self</span>[:<span class="ruby-identifier">attachable_id</span>] = (<span class="ruby-identifier">attachable</span>.<span class="ruby-identifier">pk</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">attachable</span>)&#x000A;      <span class="ruby-keyword">self</span>[:<span class="ruby-identifier">attachable_type</span>] = (<span class="ruby-identifier">attachable</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">name</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">attachable</span>)&#x000A;    <span class="ruby-keyword">end</span>),&#x000A;    :<span class="ruby-identifier">dataset=</span><span class="ruby-operator">&gt;</span>(<span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span>&#x000A;      <span class="ruby-identifier">klass</span> = <span class="ruby-identifier">attachable_type</span>.<span class="ruby-identifier">constantize</span>&#x000A;      <span class="ruby-identifier">klass</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">klass</span>.<span class="ruby-identifier">primary_key</span>=<span class="ruby-operator">&gt;</span><span class="ruby-identifier">attachable_id</span>)&#x000A;    <span class="ruby-keyword">end</span>),&#x000A;    :<span class="ruby-identifier">eager_loader=</span><span class="ruby-operator">&gt;</span>(<span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">eo</span><span class="ruby-operator">|</span>&#x000A;      <span class="ruby-identifier">id_map</span> = {}&#x000A;      <span class="ruby-identifier">eo</span>[:<span class="ruby-identifier">rows</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">asset</span><span class="ruby-operator">|</span>&#x000A;        <span class="ruby-identifier">asset</span>.<span class="ruby-identifier">associations</span>[:<span class="ruby-identifier">attachable</span>] = <span class="ruby-keyword">nil</span> &#x000A;        ((<span class="ruby-identifier">id_map</span>[<span class="ruby-identifier">asset</span>.<span class="ruby-identifier">attachable_type</span>] <span class="ruby-operator">||=</span> {})[<span class="ruby-identifier">asset</span>.<span class="ruby-identifier">attachable_id</span>] <span class="ruby-operator">||=</span> []) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">asset</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;      <span class="ruby-identifier">id_map</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">klass_name</span>, <span class="ruby-identifier">id_map</span><span class="ruby-operator">|</span>&#x000A;        <span class="ruby-identifier">klass</span> = <span class="ruby-identifier">klass_name</span>.<span class="ruby-identifier">constantize</span>&#x000A;        <span class="ruby-identifier">klass</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">klass</span>.<span class="ruby-identifier">primary_key</span>=<span class="ruby-operator">&gt;</span><span class="ruby-identifier">id_map</span>.<span class="ruby-identifier">keys</span>).<span class="ruby-identifier">all</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">attach</span><span class="ruby-operator">|</span>&#x000A;          <span class="ruby-identifier">id_map</span>[<span class="ruby-identifier">attach</span>.<span class="ruby-identifier">pk</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">asset</span><span class="ruby-operator">|</span>&#x000A;            <span class="ruby-identifier">asset</span>.<span class="ruby-identifier">associations</span>[:<span class="ruby-identifier">attachable</span>] = <span class="ruby-identifier">attach</span>&#x000A;          <span class="ruby-keyword">end</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">end</span>)&#x000A;<span class="ruby-keyword">end</span> &#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Post</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">assets</span>, :<span class="ruby-identifier">key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">attachable_id</span>, :<span class="ruby-identifier">reciprocal=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">attachable</span>, :<span class="ruby-identifier">conditions=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">attachable_type=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'Post'</span>},&#x000A;    :<span class="ruby-identifier">adder=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">asset</span><span class="ruby-operator">|</span> <span class="ruby-identifier">asset</span>.<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">attachable_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">pk</span>, :<span class="ruby-identifier">attachable_type=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'Post'</span>)},&#x000A;    :<span class="ruby-identifier">remover=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">asset</span><span class="ruby-operator">|</span> <span class="ruby-identifier">asset</span>.<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">attachable_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">nil</span>, :<span class="ruby-identifier">attachable_type=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">nil</span>)},&#x000A;    :<span class="ruby-identifier">clearer=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-identifier">assets_dataset</span>.<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">attachable_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">nil</span>, :<span class="ruby-identifier">attachable_type=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">nil</span>)}&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Note</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">assets</span>, :<span class="ruby-identifier">key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">attachable_id</span>, :<span class="ruby-identifier">reciprocal=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">attachable</span>, :<span class="ruby-identifier">conditions=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">attachable_type=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'Note'</span>},&#x000A;    :<span class="ruby-identifier">adder=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">asset</span><span class="ruby-operator">|</span> <span class="ruby-identifier">asset</span>.<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">attachable_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">pk</span>, :<span class="ruby-identifier">attachable_type=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'Note'</span>)},&#x000A;    :<span class="ruby-identifier">remover=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">asset</span><span class="ruby-operator">|</span> <span class="ruby-identifier">asset</span>.<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">attachable_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">nil</span>, :<span class="ruby-identifier">attachable_type=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">nil</span>)},&#x000A;    :<span class="ruby-identifier">clearer=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-identifier">assets_dataset</span>.<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">attachable_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">nil</span>, :<span class="ruby-identifier">attachable_type=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">nil</span>)}&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-ivar">@asset</span>.<span class="ruby-identifier">attachable</span> = <span class="ruby-ivar">@post</span>&#x000A;<span class="ruby-ivar">@asset</span>.<span class="ruby-identifier">attachable</span> = <span class="ruby-ivar">@note</span></pre>
            
            <h2 id="label-Other+advanced+associations">Other advanced associations</h2>
            
            <h3 id="label-Joining+on+multiple+keys">Joining on multiple keys</h3>
            
            <p>Let’s say you have two tables that are associated with each other with
            multiple keys.  This can be handled using Sequel’s built in composite key
            support for associations:</p>
            
            <pre class="ruby"><span class="ruby-comment"># Both of these models have an album_id, number, and disc_number fields.</span>&#x000A;<span class="ruby-comment"># All FavoriteTracks have an associated track, but not all tracks have an</span>&#x000A;<span class="ruby-comment"># associated favorite track</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Track</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">favorite_track</span>, :<span class="ruby-identifier">key=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">disc_number</span>, :<span class="ruby-identifier">number</span>, :<span class="ruby-identifier">album_id</span>], :<span class="ruby-identifier">primary_key=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">disc_number</span>, :<span class="ruby-identifier">number</span>, :<span class="ruby-identifier">album_id</span>]&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">FavoriteTrack</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">one_to_one</span> :<span class="ruby-identifier">tracks</span>, :<span class="ruby-identifier">key=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">disc_number</span>, :<span class="ruby-identifier">number</span>, :<span class="ruby-identifier">album_id</span>], :<span class="ruby-identifier">primary_key=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">disc_number</span>, :<span class="ruby-identifier">number</span>, :<span class="ruby-identifier">album_id</span>]&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-Tree+-+All+Ancestors+and+Descendents">Tree - All Ancestors and Descendents</h3>
            
            <p>Let’s say you want to store a tree relationship in your database, it’s
            pretty simple:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Node</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">parent</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-keyword">self</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">children</span>, :<span class="ruby-identifier">key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">parent_id</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-keyword">self</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>You can easily get a node’s parent with node.parent, and a node’s children
            with node.children.  You can even eager load the relationship up to a
            certain depth:</p>
            
            <pre class="ruby"><span class="ruby-comment"># Eager load three generations of generations of children for a given node </span>&#x000A;<span class="ruby-constant">Node</span>.<span class="ruby-identifier">filter</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>).<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">children=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">children=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">children</span>}).<span class="ruby-identifier">all</span>.<span class="ruby-identifier">first</span>&#x000A;<span class="ruby-comment"># Load parents and grandparents for a group of nodes</span>&#x000A;<span class="ruby-constant">Node</span>.<span class="ruby-identifier">filter</span>{<span class="ruby-identifier">id</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">10</span>}.<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">parent=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">parent</span>).<span class="ruby-identifier">all</span></pre>
            
            <p>What if you want to get all ancestors up to the root node, or all
            descendents, without knowing the depth of the tree?</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Node</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">ancestors</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-keyword">self</span>,&#x000A;   :<span class="ruby-identifier">eager_loader=</span><span class="ruby-operator">&gt;</span>(<span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">eo</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-comment"># Handle cases where the root node has the same parent_id as primary_key</span>&#x000A;    <span class="ruby-comment"># and also when it is NULL</span>&#x000A;    <span class="ruby-identifier">non_root_nodes</span> = <span class="ruby-identifier">eo</span>[:<span class="ruby-identifier">rows</span>].<span class="ruby-identifier">reject</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">n</span><span class="ruby-operator">|</span> &#x000A;      <span class="ruby-keyword">if</span> [<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">n</span>.<span class="ruby-identifier">pk</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">n</span>.<span class="ruby-identifier">parent_id</span>)&#x000A;        <span class="ruby-comment"># Make sure root nodes have their parent association set to nil</span>&#x000A;        <span class="ruby-identifier">n</span>.<span class="ruby-identifier">associations</span>[:<span class="ruby-identifier">parent</span>] = <span class="ruby-keyword">nil</span> &#x000A;        <span class="ruby-keyword">true</span>&#x000A;      <span class="ruby-keyword">else</span>&#x000A;        <span class="ruby-keyword">false</span>&#x000A;      <span class="ruby-keyword">end</span> &#x000A;    <span class="ruby-keyword">end</span> &#x000A;    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">non_root_nodes</span>.<span class="ruby-identifier">empty?</span>&#x000A;      <span class="ruby-identifier">id_map</span> = {}&#x000A;      <span class="ruby-comment"># Create an map of parent_ids to nodes that have that parent id</span>&#x000A;      <span class="ruby-identifier">non_root_nodes</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">n</span><span class="ruby-operator">|</span> (<span class="ruby-identifier">id_map</span>[<span class="ruby-identifier">n</span>.<span class="ruby-identifier">parent_id</span>] <span class="ruby-operator">||=</span> []) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">n</span>}&#x000A;      <span class="ruby-comment"># Doesn't cause an infinte loop, because when only the root node</span>&#x000A;      <span class="ruby-comment"># is left, this is not called.</span>&#x000A;      <span class="ruby-constant">Node</span>.<span class="ruby-identifier">where</span>(<span class="ruby-constant">Node</span>.<span class="ruby-identifier">primary_key</span>=<span class="ruby-operator">&gt;</span><span class="ruby-identifier">id_map</span>.<span class="ruby-identifier">keys</span>).<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">ancestors</span>).<span class="ruby-identifier">all</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">node</span><span class="ruby-operator">|</span>&#x000A;        <span class="ruby-comment"># Populate the parent association for each node</span>&#x000A;        <span class="ruby-identifier">id_map</span>[<span class="ruby-identifier">node</span>.<span class="ruby-identifier">pk</span>].<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">n</span><span class="ruby-operator">|</span> <span class="ruby-identifier">n</span>.<span class="ruby-identifier">associations</span>[:<span class="ruby-identifier">parent</span>] = <span class="ruby-identifier">node</span>}&#x000A;      <span class="ruby-keyword">end</span> &#x000A;    <span class="ruby-keyword">end</span> &#x000A;  <span class="ruby-keyword">end</span>)&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">descendants</span>, :<span class="ruby-identifier">eager_loader=</span><span class="ruby-operator">&gt;</span>(<span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">eo</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">id_map</span> = {}&#x000A;    <span class="ruby-identifier">eo</span>[:<span class="ruby-identifier">rows</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">n</span><span class="ruby-operator">|</span> &#x000A;      <span class="ruby-comment"># Initialize an empty array of child associations for each parent node</span>&#x000A;      <span class="ruby-identifier">n</span>.<span class="ruby-identifier">associations</span>[:<span class="ruby-identifier">children</span>] = []&#x000A;      <span class="ruby-comment"># Populate identity map of nodes</span>&#x000A;      <span class="ruby-identifier">id_map</span>[<span class="ruby-identifier">n</span>.<span class="ruby-identifier">pk</span>] = <span class="ruby-identifier">n</span> &#x000A;    <span class="ruby-keyword">end</span> &#x000A;    <span class="ruby-comment"># Doesn't cause an infinite loop, because the :eager_loader is not called</span>&#x000A;    <span class="ruby-comment"># if no records are returned.  Exclude id = parent_id to avoid infinite loop</span>&#x000A;    <span class="ruby-comment"># if the root note is one of the returned records and it has parent_id = id</span>&#x000A;    <span class="ruby-comment"># instead of parent_id = NULL.</span>&#x000A;    <span class="ruby-constant">Node</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">parent_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">id_map</span>.<span class="ruby-identifier">keys</span>).<span class="ruby-identifier">exclude</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">parent_id</span>).<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">descendants</span>).<span class="ruby-identifier">all</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">node</span><span class="ruby-operator">|</span>&#x000A;      <span class="ruby-comment"># Get the parent from the identity map</span>&#x000A;      <span class="ruby-identifier">parent</span> = <span class="ruby-identifier">id_map</span>[<span class="ruby-identifier">node</span>.<span class="ruby-identifier">parent_id</span>]&#x000A;      <span class="ruby-comment"># Set the child's parent association to the parent </span>&#x000A;      <span class="ruby-identifier">node</span>.<span class="ruby-identifier">associations</span>[:<span class="ruby-identifier">parent</span>] = <span class="ruby-identifier">parent</span>&#x000A;      <span class="ruby-comment"># Add the child association to the array of children in the parent</span>&#x000A;      <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">associations</span>[:<span class="ruby-identifier">children</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">node</span>&#x000A;    <span class="ruby-keyword">end</span> &#x000A;  <span class="ruby-keyword">end</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Note that unlike ActiveRecord, <a
            href="../../classes/Sequel.html">Sequel</a> supports common table
            expressions, which allows you to use recursive queries. The results are not
            the same as in the above case, as all descendents are stored in a single
            association, but all descendants can be both lazy loaded or eager loaded in
            a single query (assuming your database supports recursive common table
            expressions).  <a href="../../classes/Sequel.html">Sequel</a> ships with an
            <code>rcte_tree</code> plugin that makes this easy:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Node</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">rcte_tree</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-Joining+multiple+keys+to+a+single+key%2C+through+a+third+table">Joining multiple keys to a single key, through a third table</h3>
            
            <p>Let’s say you have a database of songs, lyrics, and artists.  Each song may
            or may not have a lyric (most songs are instrumental).  The lyric can be
            associated to an artist in each of four ways: composer, arranger, vocalist,
            or lyricist.  These may all be the same, or they could all be different,
            and none of them are required.  The songs table has a lyric_id field to
            associate it to the lyric, and the lyric table has four fields to associate
            it to the artist (composer_id, arranger_id, vocalist_id, and lyricist_id).</p>
            
            <p>What you want to do is get all songs for a given artist, ordered by the
            song’s name, with no duplicates?</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">songs</span>, :<span class="ruby-identifier">order=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">songs__name</span>,      :<span class="ruby-identifier">dataset=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-constant">Song</span>.<span class="ruby-identifier">select_all</span>(:<span class="ruby-identifier">songs</span>).<span class="ruby-identifier">join</span>(<span class="ruby-constant">Lyric</span>, :<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">lyric_id</span>, <span class="ruby-identifier">id</span>=<span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">composer_id</span>, :<span class="ruby-identifier">arranger_id</span>, :<span class="ruby-identifier">vocalist_id</span>, :<span class="ruby-identifier">lyricist_id</span>])},      :<span class="ruby-identifier">eager_loader=</span><span class="ruby-operator">&gt;</span>(<span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">eo</span><span class="ruby-operator">|</span>&#x000A;      <span class="ruby-identifier">h</span> = <span class="ruby-identifier">eo</span>[:<span class="ruby-identifier">id_map</span>]&#x000A;      <span class="ruby-identifier">ids</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">keys</span>&#x000A;      <span class="ruby-identifier">eo</span>[:<span class="ruby-identifier">rows</span>].<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">associations</span>[:<span class="ruby-identifier">songs</span>] = []}&#x000A;      <span class="ruby-constant">Song</span>.<span class="ruby-identifier">select_all</span>(:<span class="ruby-identifier">songs</span>).&#x000A;        <span class="ruby-identifier">select_append</span>(:<span class="ruby-identifier">lyrics__composer_id</span>, :<span class="ruby-identifier">lyrics__arranger_id</span>, :<span class="ruby-identifier">lyrics__vocalist_id</span>, :<span class="ruby-identifier">lyrics__lyricist_id</span>).&#x000A;        <span class="ruby-identifier">join</span>(<span class="ruby-constant">Lyric</span>, :<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">lyric_id</span>){<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">or</span>(:<span class="ruby-identifier">composer_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">ids</span>, :<span class="ruby-identifier">arranger_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">ids</span>, :<span class="ruby-identifier">vocalist_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">ids</span>, :<span class="ruby-identifier">lyricist_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">ids</span>)}.&#x000A;        <span class="ruby-identifier">order</span>(:<span class="ruby-identifier">songs__name</span>).<span class="ruby-identifier">all</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">song</span><span class="ruby-operator">|</span>&#x000A;        [:<span class="ruby-identifier">composer_id</span>, :<span class="ruby-identifier">arranger_id</span>, :<span class="ruby-identifier">vocalist_id</span>, :<span class="ruby-identifier">lyricist_id</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span>&#x000A;          <span class="ruby-identifier">recs</span> = <span class="ruby-identifier">h</span>[<span class="ruby-identifier">song</span>.<span class="ruby-identifier">values</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">x</span>)]&#x000A;          <span class="ruby-identifier">recs</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">associations</span>[:<span class="ruby-identifier">songs</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">song</span>} <span class="ruby-keyword">if</span> <span class="ruby-identifier">recs</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;      <span class="ruby-identifier">eo</span>[:<span class="ruby-identifier">rows</span>].<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">associations</span>[:<span class="ruby-identifier">songs</span>].<span class="ruby-identifier">uniq!</span>}&#x000A;    <span class="ruby-keyword">end</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-Statistics+Associations+%28Sum+of+Associated+Table+Column%29">Statistics Associations (Sum of Associated Table Column)</h3>
            
            <p>In addition to getting associated records, you can use Sequel’s association
            support to get aggregate information for columns in associated tables
            (sums, averages, etc.).</p>
            
            <p>Let’s say you have a database with projects and tickets.  A project can
            have many tickets, and each ticket has a number of hours associated with
            it.  You can use the association support to create a Project association
            that gives the sum of hours for all associated tickets.</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Project</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">tickets</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">ticket_hours</span>, :<span class="ruby-identifier">read_only=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>, :<span class="ruby-identifier">key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">id</span>,&#x000A;   :<span class="ruby-identifier">dataset=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-constant">Ticket</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">project_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">id</span>).<span class="ruby-identifier">select</span>{<span class="ruby-identifier">sum</span>(<span class="ruby-identifier">hours</span>).<span class="ruby-identifier">as</span>(<span class="ruby-identifier">hours</span>)}},&#x000A;   :<span class="ruby-identifier">eager_loader=</span><span class="ruby-operator">&gt;</span>(<span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">eo</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">eo</span>[:<span class="ruby-identifier">rows</span>].<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">p</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span>.<span class="ruby-identifier">associations</span>[:<span class="ruby-identifier">ticket_hours</span>] = <span class="ruby-keyword">nil</span>}&#x000A;    <span class="ruby-constant">Ticket</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">project_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">eo</span>[:<span class="ruby-identifier">id_map</span>].<span class="ruby-identifier">keys</span>).&#x000A;     <span class="ruby-identifier">select_group</span>(:<span class="ruby-identifier">project_id</span>).&#x000A;     <span class="ruby-identifier">select_append</span>{<span class="ruby-identifier">sum</span>(<span class="ruby-identifier">hours</span>).<span class="ruby-identifier">as</span>(<span class="ruby-identifier">hours</span>)}.&#x000A;     <span class="ruby-identifier">all</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">t</span><span class="ruby-operator">|</span>&#x000A;      <span class="ruby-identifier">p</span> = <span class="ruby-identifier">eo</span>[:<span class="ruby-identifier">id_map</span>][<span class="ruby-identifier">t</span>.<span class="ruby-identifier">values</span>.<span class="ruby-identifier">delete</span>(:<span class="ruby-identifier">project_id</span>)].<span class="ruby-identifier">first</span>&#x000A;      <span class="ruby-identifier">p</span>.<span class="ruby-identifier">associations</span>[:<span class="ruby-identifier">ticket_hours</span>] = <span class="ruby-identifier">t</span>&#x000A;     <span class="ruby-keyword">end</span>&#x000A;   <span class="ruby-keyword">end</span>)&#x000A;  <span class="ruby-comment"># The association method returns a Ticket object with a single aggregate</span>&#x000A;  <span class="ruby-comment"># sum-of-hours value, but you want it to return an Integer/Float of just the</span>&#x000A;  <span class="ruby-comment"># sum of hours, so you call super and return just the sum-of-hours value.</span>&#x000A;  <span class="ruby-comment"># This works for both lazy loading and eager loading.</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">ticket_hours</span>&#x000A;    <span class="ruby-keyword">if</span> <span class="ruby-identifier">s</span> = <span class="ruby-keyword">super</span>&#x000A;      <span class="ruby-identifier">s</span>[:<span class="ruby-identifier">hours</span>]&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Ticket</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">project</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Note that it is often better to use a sum cache instead of this approach. 
            You can implement a sum cache using <code>after_create</code> and
            <code>after_delete</code> hooks, or preferrably using a database trigger.</p>
          </div>
          <div id='context'>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
