<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>association_basics.rdoc</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='file' id='wrapper'>
      <div class='header'>
        <h1 class='name'>association_basics.rdoc</h1>
        <div class='paths'>
          doc/association_basics.rdoc
        </div>
        <div class='last-update'>
          Last Update:
          <span class='datetime'>2013-11-08 08:08:17 -0500</span>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <h1 id="label-Association+Basics">Association Basics</h1>
            
            <p>This guide is based on <a
            href="http://guides.rubyonrails.org/association_basics.html">guides.rubyonrails.org/association_basics.html</a></p>
            
            <h2 id="label-Why+Associations%3F">Why Associations?</h2>
            
            <p>Associations exist to simplify code that deals with related rows in
            separate database tables.  Without associations, if you had classes such
            as:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>And you wanted to get all of the albums for a given artist (assuming each
            album was associated with only one artist):</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">filter</span>(:<span class="ruby-identifier">artist_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-ivar">@artist</span>.<span class="ruby-identifier">id</span>).<span class="ruby-identifier">all</span></pre>
            
            <p>Or maybe you want to add an album for a given artist:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">create</span>(:<span class="ruby-identifier">artist_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-ivar">@artist</span>.<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'RF'</span>)</pre>
            
            <p>With Associations, you can make the above code simpler, by setting up
            associations between the two models:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">artist</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Then, the code to retrieve albums related to the artist is simpler:</p>
            
            <pre>@artist.albums</pre>
            
            <p>As is the code to add a related album to an artist:</p>
            
            <pre class="ruby"><span class="ruby-ivar">@artist</span>.<span class="ruby-identifier">add_album</span>(:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'RF'</span>)</pre>
            
            <h2 id="label-The+Types+of+Associations">The Types of Associations</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> has four different
            association types built in:</p>
            <ul><li>
            <p>many_to_one</p>
            </li><li>
            <p>one_to_many</p>
            </li><li>
            <p>one_to_one</p>
            </li><li>
            <p>many_to_many</p>
            </li></ul>
            
            <h3 id="label-many_to_one">many_to_one</h3>
            
            <p>The many_to_one association is used when the table for the current class
            contains a foreign key that references the primary key in the table for the
            associated class.  It is named because there can be many rows in the
            current table for each row in the associated table.</p>
            
            <pre class="ruby"><span class="ruby-comment"># Database schema:</span>&#x000A;<span class="ruby-comment">#  albums             artists</span>&#x000A;<span class="ruby-comment">#   :id           /--&gt; :id</span>&#x000A;<span class="ruby-comment">#   :artist_id --/     :name</span>&#x000A;<span class="ruby-comment">#   :name</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span>&#x000A;  <span class="ruby-comment"># Uses singular form of associated model name</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">artist</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-one_to_many">one_to_many</h3>
            
            <p>The one_to_many association is used when the table for the associated class
            contains a foreign key that references the primary key in the table for the
            current class.  It is named because for each row in the current table there
            can be many rows in the associated table:</p>
            
            <pre class="ruby"><span class="ruby-comment"># Database schema:</span>&#x000A;<span class="ruby-comment">#  artists            albums</span>&#x000A;<span class="ruby-comment">#   :id   &lt;----\       :id</span>&#x000A;<span class="ruby-comment">#   :name       \----- :artist_id </span>&#x000A;<span class="ruby-comment">#                      :name</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span>&#x000A;  <span class="ruby-comment"># Uses plural form of associated model name</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-one_to_one">one_to_one</h3>
            
            <p>The one_to_one association can be thought of as a subset of the one_to_many
            association, but where there can only be either 0 or 1 records in the
            associated table. It is the least frequently used of the four associations.
            If you assume each artist cannot be associated with more than one album:</p>
            
            <pre class="ruby"><span class="ruby-comment"># Database schema:</span>&#x000A;<span class="ruby-comment">#  artists            albums</span>&#x000A;<span class="ruby-comment">#   :id   &lt;----\       :id</span>&#x000A;<span class="ruby-comment">#   :name       \----- :artist_id </span>&#x000A;<span class="ruby-comment">#                      :name</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span>&#x000A;  <span class="ruby-comment"># Uses singular form of associated model name</span>&#x000A;  <span class="ruby-identifier">one_to_one</span> :<span class="ruby-identifier">album</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-many_to_many">many_to_many</h3>
            
            <p>The many_to_many association allows each row in the current table to be
            associated to many rows in the associated table, and each row in the
            associated table to many rows in the current table, by using a join table
            to associate the two tables. If you assume each artist can have multiple
            albums and each album can have multiple artists:</p>
            
            <pre class="ruby"><span class="ruby-comment"># Database schema:</span>&#x000A;<span class="ruby-comment">#  albums </span>&#x000A;<span class="ruby-comment">#   :id   &lt;----\ </span>&#x000A;<span class="ruby-comment">#   :name       \     albums_artists</span>&#x000A;<span class="ruby-comment">#                \---- :album_id</span>&#x000A;<span class="ruby-comment">#  artists       /---- :artist_id</span>&#x000A;<span class="ruby-comment">#   :id   &lt;-----/</span>&#x000A;<span class="ruby-comment">#   :name</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span>&#x000A;  <span class="ruby-comment"># Uses plural form of associated model name</span>&#x000A;  <span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">albums</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span>&#x000A;  <span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">artists</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-Differences+Between+many_to_one+and+one_to_one">Differences Between many_to_one and one_to_one</h3>
            
            <p>If you want to setup a 1-1 relationship between two models, you have to use
            many_to_one in one model, and one_to_one in the other model.  How do you
            know which to use in which model?</p>
            
            <p>The simplest way to remember is that the model whose table has the foreign
            key uses many_to_one, and the other model uses one_to_one:</p>
            
            <pre class="ruby"><span class="ruby-comment"># Database schema:</span>&#x000A;<span class="ruby-comment">#  artists            albums</span>&#x000A;<span class="ruby-comment">#   :id   &lt;----\       :id</span>&#x000A;<span class="ruby-comment">#   :name       \----- :artist_id </span>&#x000A;<span class="ruby-comment">#                      :name</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span>&#x000A;  <span class="ruby-identifier">one_to_one</span> :<span class="ruby-identifier">album</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">artist</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="label-Most+Common+Options">Most Common Options</h2>
            
            <h3 id="label-%3Akey">:key</h3>
            
            <p>The :key option must be used if the default column symbol that <a
            href="../../classes/Sequel.html">Sequel</a> would use is not the correct
            column.  For example:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span>&#x000A;  <span class="ruby-comment"># Assumes :key is :artist_id, based on association name of :artist</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">artist</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span>&#x000A;  <span class="ruby-comment"># Assumes :key is :artist_id, based on class name of Artist</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>However, if your schema looks like:</p>
            
            <pre># Database schema:&#x000A;#  artists            albums&#x000A;#   :id   &lt;----\       :id&#x000A;#   :name       \----- :artistid # Note missing underscore&#x000A;#                      :name</pre>
            
            <p>Then the default :key option will not be correct.  To fix this, you need to
            specify an explicit :key option:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">artist</span>, :<span class="ruby-identifier">key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artistid</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albumst</span>, :<span class="ruby-identifier">key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artistid</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>For many_to_many associations, the :left_key and :right_key options can be
            used to specify the column names in the join table, and the :join_table
            option can be used to specify the name of the join table:</p>
            
            <pre class="ruby"><span class="ruby-comment"># Database schema:</span>&#x000A;<span class="ruby-comment">#  albums </span>&#x000A;<span class="ruby-comment">#   :id   &lt;----\ </span>&#x000A;<span class="ruby-comment">#   :name       \     albumsartists</span>&#x000A;<span class="ruby-comment">#                \---- :albumid</span>&#x000A;<span class="ruby-comment">#  artists       /---- :artistid</span>&#x000A;<span class="ruby-comment">#   :id   &lt;-----/</span>&#x000A;<span class="ruby-comment">#   :name</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span>&#x000A;  <span class="ruby-comment"># Note that :left_key refers to the foreign key pointing to the</span>&#x000A;  <span class="ruby-comment"># current table, and :right_key the foreign key pointing to the</span>&#x000A;  <span class="ruby-comment"># associated table.</span>&#x000A;  <span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">albums</span>, :<span class="ruby-identifier">left_key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artistid</span>, :<span class="ruby-identifier">right_key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">albumid</span>,&#x000A;    :<span class="ruby-identifier">join_table=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">albumsartists</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span>&#x000A;  <span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">artists</span>, :<span class="ruby-identifier">left_key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">albumid</span>, :<span class="ruby-identifier">right_key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artistid</span>,&#x000A;    :<span class="ruby-identifier">join_table=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">albumsartists</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-%3Aclass">:class</h3>
            
            <p>If the class of the association can not be guessed directly by looking at
            the association name, you need to specify it via the :class option.  For
            example, if you have two separate foreign keys in the albums table that
            both point to the artists table, maybe to indicate one artist is the
            vocalist and one is the composer, you’d have to use the :class option:</p>
            
            <pre class="ruby"><span class="ruby-comment"># Database schema:</span>&#x000A;<span class="ruby-comment">#  artists            albums</span>&#x000A;<span class="ruby-comment">#   :id   &lt;----\       :id</span>&#x000A;<span class="ruby-comment">#   :name       \----- :vocalist_id</span>&#x000A;<span class="ruby-comment">#                \---- :composer_id</span>&#x000A;<span class="ruby-comment">#                      :name</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">vocalist</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span>:<span class="ruby-constant">Artist</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">composer</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span>:<span class="ruby-constant">Artist</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">vocalist_albums</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span>:<span class="ruby-constant">Album</span>, :<span class="ruby-identifier">key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">vocalist_id</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">composer_albums</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span>:<span class="ruby-constant">Album</span>, :<span class="ruby-identifier">key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">composer_id</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="label-Self-referential+Associations">Self-referential Associations</h2>
            
            <p>Self-referential associations are easy to handle in <a
            href="../../classes/Sequel.html">Sequel</a>.  The simplest example is a
            tree structure:</p>
            
            <pre class="ruby"><span class="ruby-comment"># Database schema:</span>&#x000A;<span class="ruby-comment">#  nodes</span>&#x000A;<span class="ruby-comment">#   :id        &lt;--\ </span>&#x000A;<span class="ruby-comment">#   :parent_id ---/</span>&#x000A;<span class="ruby-comment">#   :name</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Node</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">parent</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-keyword">self</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">children</span>, :<span class="ruby-identifier">key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">parent_id</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-keyword">self</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>For many_to_many self_referential associations, it’s fairly similar. 
            Here’s an example of a directed graph:</p>
            
            <pre class="ruby"><span class="ruby-comment"># Database schema:</span>&#x000A;<span class="ruby-comment">#  nodes              edges</span>&#x000A;<span class="ruby-comment">#   :id   &lt;----------- :successor_id</span>&#x000A;<span class="ruby-comment">#   :name       \----- :predecessor_id</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Node</span>&#x000A;  <span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">direct_successors</span>, :<span class="ruby-identifier">left_key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">successor_id</span>,&#x000A;    :<span class="ruby-identifier">right_key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">predecessor_id</span>, :<span class="ruby-identifier">join_table=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">edges</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-keyword">self</span>&#x000A;  <span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">direct_predecessors</span>, :<span class="ruby-identifier">right_key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">successor_id</span>,&#x000A;    :<span class="ruby-identifier">left_key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">predecessor_id</span>, :<span class="ruby-identifier">join_table=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">edges</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-keyword">self</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="label-Methods+Added">Methods Added</h2>
            
            <p>When you create an association, it’s going to add instance methods to the
            class related to the association.</p>
            
            <p>All associations are going to have an instance method added with the same
            name as the association:</p>
            
            <pre>@artist.albums&#x000A;@album.artists</pre>
            
            <p>many_to_one and one_to_one associations will also have a setter method
            added to change the associated object:</p>
            
            <pre class="ruby"><span class="ruby-ivar">@album</span>.<span class="ruby-identifier">artist</span> = <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">create</span>(:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'YJM'</span>)</pre>
            
            <p>many_to_many and one_to_many associations will have three methods added:</p>
            <ul><li>
            <p>add_* to associate an object to the current object</p>
            </li><li>
            <p>remove_* to disassociate an object from the current object</p>
            </li><li>
            <p>remove_all_* to dissociate all currently associated objects</p>
            </li></ul>
            
            <p>Examples:</p>
            
            <pre>@artist.add_album(@album)&#x000A;@artist.remove_album(@album)&#x000A;@artist.remove_all_albums</pre>
            
            <h2 id="label-Caching">Caching</h2>
            
            <p>Associations are cached after being retrieved:</p>
            
            <pre>@artist.album # Not cached - Database Query&#x000A;@artist.album # Cached - No Database Query&#x000A;@album.artists # Not cached - Database Query&#x000A;@album.artists # Cached - No Database Query</pre>
            
            <p>You can choose to ignore the cached versions and do a database query to
            retrieve results by passing a true argument to the association method:</p>
            
            <pre>@album.artists # Not cached - Database Query&#x000A;@album.artists # Cached - No Database Query&#x000A;@album.artists(true) # Ignore cache - Database Query</pre>
            
            <p>If you reload/refresh the object, it will automatically clear the
            associations cache for the object:</p>
            
            <pre>@album.artists # Not cached - Database Query&#x000A;@album.artists # Cached - No Database Query&#x000A;@album.reload&#x000A;@album.artists # Not Cached - Database Query</pre>
            
            <p>If you want direct access to the associations cache, use the associations
            instance method:</p>
            
            <pre>@album.associations # {}&#x000A;@album.associations[:artists] # nil&#x000A;@album.artists # [&lt;Artist ...&gt;, ...]&#x000A;@album.associations[:artists] # [&lt;Artist ...&gt;, ...]</pre>
            
            <h2 id="label-Dataset+Method">Dataset Method</h2>
            
            <p>In addition to the above methods, associations also add a instance method
            ending in <code>_dataset</code> that returns a dataset representing the
            objects in the associated table:</p>
            
            <pre>@album.artist_id&#x000A;# 10&#x000A;@album.artist_dataset&#x000A;# SELECT * FROM artists WHERE (id = 10)&#x000A;@artist.id&#x000A;# 20&#x000A;@artist.albums_dataset&#x000A;# SELECT * FROM albums WHERE (artist_id = 20)</pre>
            
            <p>The association dataset is just like any other <a
            href="../../classes/Sequel.html">Sequel</a> dataset, in that it can be
            further filtered, ordered, etc.:</p>
            
            <pre>@artist.albums_dataset.&#x000A; where(Sequel.like(:name, 'A%')).&#x000A; order(:copies_sold).&#x000A; limit(10)&#x000A;# SELECT * FROM albums&#x000A;# WHERE ((artist_id = 20) AND (name LIKE 'A%'))&#x000A;# ORDER BY copies_sold LIMIT 10</pre>
            
            <p>Records retrieved using the <code>_dataset</code> method are not cached in
            the associations cache.</p>
            
            <pre>@album.artists_dataset.all # [&lt;Artist ...&gt;, ...]&#x000A;@album.associations[:artists] # nil</pre>
            
            <h2 id="label-Dynamic+Association+Modification">Dynamic Association Modification</h2>
            
            <p>Similar to the <code>_dataset</code> method, you can provide a block to the
            association method to customize the dataset that will be used to retrieve
            the records.  So you can apply a filter in either of these two ways:</p>
            
            <pre class="ruby"><span class="ruby-ivar">@artist</span>.<span class="ruby-identifier">albums_dataset</span>.<span class="ruby-identifier">where</span>(<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">like</span>(:<span class="ruby-identifier">name</span>, <span class="ruby-string">'A%'</span>))&#x000A;<span class="ruby-ivar">@artist</span>.<span class="ruby-identifier">albums</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>(<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">like</span>(:<span class="ruby-identifier">name</span>, <span class="ruby-string">'A%'</span>))}</pre>
            
            <p>While they both apply the same filter, using the <code>_dataset</code>
            method does not apply any of the association callbacks or handle
            association reciprocals (see below for details about callbacks and
            reciprocals).  Using a block instead handles all those things, and also
            caches its results in the associations cache (ignoring any previously
            cached value).</p>
            
            <h2 id="label-Filtering+By+Associations">Filtering By Associations</h2>
            
            <p>In addition to using the association method to get associated objects, you
            can also use associated objects in filters.  For example, to get all albums
            for a given artist, you would usually do:</p>
            
            <pre>@artist.albums&#x000A;# or @artist.albums_dataset for a dataset</pre>
            
            <p>You can also do the following:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">artist=</span><span class="ruby-operator">&gt;</span><span class="ruby-ivar">@artist</span>).<span class="ruby-identifier">all</span>&#x000A;<span class="ruby-comment"># or leave off the .all for a dataset</span></pre>
            
            <p>For filtering by a single association, this isn’t very useful.  However,
            unlike using the association method, using a filter allows you to filter by
            multiple associations:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">artist=</span><span class="ruby-operator">&gt;</span><span class="ruby-ivar">@artist</span>, :<span class="ruby-identifier">publisher=</span><span class="ruby-operator">&gt;</span><span class="ruby-ivar">@publisher</span>)</pre>
            
            <p>This will return all albums by that artist and published by that publisher.
            This isn’t possible using just the association method approach, though you
            can combine the approaches:</p>
            
            <pre class="ruby"><span class="ruby-ivar">@artist</span>.<span class="ruby-identifier">albums_dataset</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">publisher=</span><span class="ruby-operator">&gt;</span><span class="ruby-ivar">@publisher</span>)</pre>
            
            <p>This doesn’t just work for <code>many_to_one</code> associations, it also
            works for <code>one_to_one</code>, <code>one_to_many</code>, and
            <code>many_to_many</code> associations:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">one_to_one</span> :<span class="ruby-identifier">album_info</span>&#x000A;<span class="ruby-comment"># The album related to that AlbumInfo instance</span>&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">album_info=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">AlbumInfo</span>[<span class="ruby-value">2</span>])&#x000A;&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">tracks</span>&#x000A;<span class="ruby-comment"># The album related to that Track instance</span>&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">tracks=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">Track</span>[<span class="ruby-value">3</span>])&#x000A;&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">tags</span>&#x000A;<span class="ruby-comment"># All albums related to that Tag instance</span>&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">tags=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">Tag</span>[<span class="ruby-value">4</span>])</pre>
            
            <p>Note that for <code>one_to_many</code> and <code>many_to_many</code>
            associations, you still use the plural form even though only a single model
            object is given.</p>
            
            <p>You can also exclude by associations:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">exclude</span>(:<span class="ruby-identifier">artist=</span><span class="ruby-operator">&gt;</span><span class="ruby-ivar">@artist</span>).<span class="ruby-identifier">all</span></pre>
            
            <p>This will return all albums not by that artist.</p>
            
            <p>You can also provide an array with multiple model objects:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">artist=</span><span class="ruby-operator">&gt;</span>[<span class="ruby-ivar">@artist1</span>, <span class="ruby-ivar">@artist2</span>]).<span class="ruby-identifier">all</span></pre>
            
            <p>Similar to using an array of integers or strings, this will return all
            albums whose artist is one of those two artists.  You can also use
            <code>exclude</code> if you want all albums not by either of those artists:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">exclude</span>(:<span class="ruby-identifier">artist=</span><span class="ruby-operator">&gt;</span>[<span class="ruby-ivar">@artist1</span>, <span class="ruby-ivar">@artist2</span>]).<span class="ruby-identifier">all</span></pre>
            
            <p>If you are using a <code>one_to_many</code> or <code>many_to_many</code>
            association, you may want to return records where the records matches all
            of multiple records, instead of matching any of them.  For example:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">tags=</span><span class="ruby-operator">&gt;</span>[<span class="ruby-ivar">@tag1</span>, <span class="ruby-ivar">@tag2</span>])</pre>
            
            <p>This matches albums that are associated with either @tag1 or @tag2 or both.
            If you only want ones that you are associated with both, you can use
            separate filter calls:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">tags=</span><span class="ruby-operator">&gt;</span><span class="ruby-ivar">@tag1</span>).<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">tags=</span><span class="ruby-operator">&gt;</span><span class="ruby-ivar">@tag2</span>)</pre>
            
            <p>Or the array form of condition specifiers:</p>
            
            <pre>Album.where([[:tags, @tag1], [:tags, @tag2]])</pre>
            
            <p>These will return albums associated with both @tag1 and @tag2.</p>
            
            <p>You can also provide a dataset value when filtering by associations:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">artist=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">like</span>(:<span class="ruby-identifier">name</span>, <span class="ruby-string">'A%'</span>))).<span class="ruby-identifier">all</span></pre>
            
            <p>This will return all albums whose artist starts with ‘A’. Like the other
            forms, this can be inverted:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">exclude</span>(:<span class="ruby-identifier">artist=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">like</span>(:<span class="ruby-identifier">name</span>, <span class="ruby-string">'A%'</span>))).<span class="ruby-identifier">all</span></pre>
            
            <p>This will return all albums whose artist does not start with ‘A’.</p>
            
            <p>Filtering by associations even works for associations that have conditions
            added via the :conditions option or a block:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">popular_tags</span>, :<span class="ruby-identifier">clone=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">tags</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">times_used</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1000</span>}&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">popular_tags=</span><span class="ruby-operator">&gt;</span>[<span class="ruby-ivar">@tag1</span>, <span class="ruby-ivar">@tag2</span>])</pre>
            
            <p>This will return all albums that whose popular tags would include at least
            one of those tags.</p>
            
            <p>Note that filtering by associations does not work for associations that use
            blocks with instance-specific code, or associations that have a limit or
            offset. This includes many_to_one/one_to_one associations that would return
            multiple values if they were not limited to a single value.</p>
            
            <h2 id="label-Name+Collisions">Name Collisions</h2>
            
            <p>Because associations create instance methods, it’s possible to override
            existing instance methods if you name an association the same as an
            existing method.  For example, <code>values</code> and
            <code>associations</code> would be bad association names.</p>
            
            <h2 id="label-Database+Schema">Database Schema</h2>
            
            <p>Creating an association doesn’t modify the database schema.  <a
            href="../../classes/Sequel.html">Sequel</a> assumes your associations
            reflect the existing database schema.  If not, you should modify your
            schema before creating the associations.</p>
            
            <h3 id="label-many_to_one%2Fone_to_many">many_to_one/one_to_many</h3>
            
            <p>For example, for the following model code:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">artist</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>You probably want the following database schema:</p>
            
            <pre>#  albums             artists&#x000A;#   :id           /--&gt; :id&#x000A;#   :artist_id --/     :name&#x000A;#   :name</pre>
            
            <p>Which could be created using the following <a
            href="../../classes/Sequel.html">Sequel</a> code:</p>
            
            <pre>DB.create_table(:artists) do&#x000A;  # Primary key must be set explicitly&#x000A;  primary_key :id&#x000A;  String :name&#x000A;end&#x000A;DB.create_table(:albums) do&#x000A;  primary_key :id&#x000A;  # Table that foreign key references needs to be set explicitly&#x000A;  # for a database foreign key reference to be created.&#x000A;  foreign_key :artist_id, :artists&#x000A;  String :name&#x000A;end</pre>
            
            <p>If you already had a schema such as:</p>
            
            <pre># Database schema:&#x000A;#  albums             artists&#x000A;#   :id                :id&#x000A;#   :name              :name</pre>
            
            <p>Then you just need to add the column:</p>
            
            <pre>DB.alter_table(:albums) do&#x000A;  add_foreign_key :artist_id, :artists&#x000A;end</pre>
            
            <h3 id="label-many_to_many">many_to_many</h3>
            
            <p>With many_to_many associations, the default join table for the association
            uses the sorted underscored names of both model classes.  For example, with
            the following model code:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span>&#x000A;  <span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">artists</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span>&#x000A;  <span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">albums</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>The default join table name would be <code>albums_artists</code>, not
            <code>artists_albums</code>, because:</p>
            
            <pre>[&quot;artists&quot;, &quot;albums&quot;].sort.join('_')&#x000A;# &quot;albums_artists&quot;</pre>
            
            <p>Assume you already had the albums and artists tables created, and you just
            wanted to add an albums_artists join table to create the following schema:</p>
            
            <pre># Database schema:&#x000A;#  albums &#x000A;#   :id   &lt;----\ &#x000A;#   :name       \     albums_artists&#x000A;#                \---- :album_id&#x000A;#  artists       /---- :artist_id&#x000A;#   :id   &lt;-----/&#x000A;#   :name</pre>
            
            <p>You could use the following <a href="../../classes/Sequel.html">Sequel</a>
            code:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_join_table</span>(:<span class="ruby-identifier">album_id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">albums</span>, :<span class="ruby-identifier">artist_id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artists</span>)&#x000A;<span class="ruby-comment"># or</span>&#x000A;<span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">albums_artists</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">foreign_key</span> :<span class="ruby-identifier">album_id</span>, :<span class="ruby-identifier">albums</span>&#x000A;  <span class="ruby-identifier">foreign_key</span> :<span class="ruby-identifier">artist_id</span>, :<span class="ruby-identifier">artists</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="label-Association+Scope">Association Scope</h2>
            
            <p>If you nest your <a
            href="../../classes/Sequel/Model.html">Sequel::Model</a> classes inside
            modules, then you should know that <a
            href="../../classes/Sequel.html">Sequel</a> will only look in the same
            module for associations by default. So the following code will work fine:</p>
            
            <pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">App</span>&#x000A;  <span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;    <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;    <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">artist</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>However, if you enclose your model classes inside two different modules,
            things will not work by default:</p>
            
            <pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">App1</span>&#x000A;  <span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;    <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">module</span> <span class="ruby-constant">App2</span>&#x000A;  <span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;    <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">artist</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>To fix this, you need to specify the full model class name using the :class
            option:</p>
            
            <pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">App1</span>&#x000A;  <span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;    <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;App2::Album&quot;</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">module</span> <span class="ruby-constant">App2</span>&#x000A;  <span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;    <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">artist</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;App1::Artist&quot;</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>If both classes are in the same module, but the default class name used is
            not correct, you need to specify the full class name with the :class
            option:</p>
            
            <pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">App1</span>&#x000A;  <span class="ruby-keyword">class</span> <span class="ruby-constant">AlbumArtist</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;    <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;    <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">artist</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;App1::AlbumArtist&quot;</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="label-Method+Details">Method Details</h2>
            
            <p>In all of these methods, <em>association</em> is replaced by the symbol you
            pass to the association.</p>
            
            <h3 id="label-association%28reload+%3D+false%29+%28e.g.+albums%29"><em>association</em>(reload = false) (e.g. albums)</h3>
            
            <p>For <code>many_to_one</code> and <code>one_to_one</code> associations, the
            <em>association</em> method returns either the single object associated, or
            nil if no object is associated.</p>
            
            <pre>@artist = @album.artist</pre>
            
            <p>For <code>one_to_many</code> and <code>many_to_many</code> associations,
            the <em>association</em> method returns an array of associated objects,
            which may be empty if no objects are currently associated.</p>
            
            <pre>@albums = @artist.albums</pre>
            
            <h3 id="label-association%3D%28object_to_associate%29+%28e.g.+artist%3D%29+%5Bmany_to_one+and+one_to_one%5D"><em>association</em>=(object_to_associate) (e.g. artist=) [<code>many_to_one</code> and <code>one_to_one</code>]</h3>
            
            <p>The <em>association</em>= method sets up an association of the passed
            object to the current object.  For <code>many_to_one</code> associations,
            this sets the foreign key for the current object to point to the associated
            object’s primary key.</p>
            
            <pre>@album.artist = @artist</pre>
            
            <p>For <code>one_to_one</code> associations, this sets the foreign key of the
            associated object to the primary key value of the current object.</p>
            
            <p>For <code>many_to_one</code> associations, this does not save the current
            object. For <code>one_to_one</code> associations, this does save the
            associated object.</p>
            
            <h3 id="label-add_association%28object_to_associate%29+%28e.g.+add_album%29+%5Bone_to_many+and+many_to_many%5D">add_<em>association</em>(object_to_associate) (e.g. add_album) [<code>one_to_many</code> and <code>many_to_many</code>]</h3>
            
            <p>The add_<em>association</em> method associates the passed object to the
            current object.  For <code>one_to_many</code> associations, it sets the
            foreign key of the associated object to the primary key value of the
            current object, and saves the associated object.  For
            <code>many_to_many</code> associations, this inserts a row into the join
            table with the foreign keys set to the primary key values of the current
            and associated objects.  Note that the singular form of the association
            name is used in this method.</p>
            
            <pre>@artist.add_album(@album)</pre>
            
            <p>In addition to passing an actual associated object, you can pass a hash,
            and a new associated object will be created from them:</p>
            
            <pre class="ruby"><span class="ruby-ivar">@artist</span>.<span class="ruby-identifier">add_album</span>(:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'RF'</span>) <span class="ruby-comment"># creates Album object</span></pre>
            
            <p>The add_<em>association</em> method returns the now associated object:</p>
            
            <pre class="ruby"><span class="ruby-ivar">@album</span> = <span class="ruby-ivar">@artist</span>.<span class="ruby-identifier">add_album</span>(:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'RF'</span>)</pre>
            
            <h3 id="label-remove_association%28object_to_disassociate%29+%28e.g.+remove_album%29+%5Bone_to_many+and+many_to_many%5D">remove_<em>association</em>(object_to_disassociate) (e.g. remove_album) [<code>one_to_many</code> and <code>many_to_many</code>]</h3>
            
            <p>The remove_<em>association</em> method disassociates the passed object from
            the current object.  For <code>one_to_many</code> associations, it sets the
            foreign key of the associated object to NULL, and saves the associated
            object.  For <code>many_to_many</code> associations, this deletes the
            matching row in the join table. Similar to the add_<em>association</em>
            method, the singular form of the association name is used in this method.</p>
            
            <pre>@artist.remove_album(@album)</pre>
            
            <p>Note that this does not delete <code>@album</code> from the database, it
            only disassociates it from the <code>@artist</code>.  To delete
            <code>@album</code> from the database:</p>
            
            <pre>@album.destroy</pre>
            
            <p>The add_<em>association</em> and remove_<em>association</em> methods should
            be thought of as adding and removing from the association, not from the
            database.</p>
            
            <p>In addition to passing the object directly to remove_<em>association</em>,
            you can also pass the associated object’s primary key:</p>
            
            <pre>@artist.remove_album(10)</pre>
            
            <p>This will look up the associated object using the key, and remove that
            album.</p>
            
            <p>The remove_<em>association</em> method returns the now disassociated
            object:</p>
            
            <pre>@album = @artist.remove_album(10)</pre>
            
            <h3 id="label-remove_all_association+%28e.g.+remove_all_albums%29+%5Bone_to_many+and+many_to_many%5D">remove_all_<em>association</em> (e.g. remove_all_albums) [<code>one_to_many</code> and <code>many_to_many</code>]</h3>
            
            <p>The remove_all_<em>association</em> method disassociates all currently
            associated objects.  For <code>one_to_many</code> associations, it sets the
            foreign key of all associated objects to NULL in a single query.  For
            <code>many_to_many</code> associations, this deletes all matching rows in
            the join table. Unlike the add_<em>association</em> and
            remove_<em>association</em> method, the plural form of the association name
            is used in this method. The remove_all_<em>association</em> method returns
            the number of rows updated for <code>one_to_many</code> associations and
            the number of rows deleted for <code>many_to_many</code> associations:</p>
            
            <pre>@rows_modified = @artist.remove_all_albums</pre>
            
            <h3 id="label-association_dataset+%28e.g.+albums_dataset%29"><em>association</em>_dataset (e.g. albums_dataset)</h3>
            
            <p>The <em>association</em>_dataset method returns a dataset that represents
            all associated objects.  This dataset is like any other <a
            href="../../classes/Sequel.html">Sequel</a> dataset, in that it can be
            filtered, ordered, etc.:</p>
            
            <pre>ds = @artist.albums_dataset.where(Sequel.like(:name, 'A%')).order(:copies_sold)</pre>
            
            <p>Unlike most other <a href="../../classes/Sequel.html">Sequel</a> datasets,
            association datasets have a couple of added methods:</p>
            
            <pre>ds.model_object # @artist&#x000A;ds.association_reflection # same as Artist.association_reflection(:albums)</pre>
            
            <p>For a more info on Sequel’s reflection capabilities see the <a
            href="reflection_rdoc.html">Reflection page</a></p>
            
            <h2 id="label-Overriding+Method+Behavior">Overriding Method Behavior</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> is designed to be very
            flexible.  If the default behavior of the association modification methods
            isn't what you desire, you can override the methods in your classes. 
            However, you should be aware that for each of the association modification
            methods described, there is a private method that is preceeded by an
            underscore that does the actual modification.  The public method without
            the underscore handles caching and callbacks, and shouldn't be overridden
            by the user.</p>
            
            <p>In addition to overriding the private method in your class, you can also
            use association options to change which method <a
            href="../../classes/Sequel.html">Sequel</a> defines.  The only difference
            between the two is that if you use an association option to change the
            method <a href="../../classes/Sequel.html">Sequel</a> defines, you cannot
            call super to get the default behavior.</p>
            
            <h3 id="label-_association%3D+%28%3Asetter+option%29">_<em>association</em>= (:setter option)</h3>
            
            <p>Let’s say you want to set a specific field whenever associating an object
            using the association setter method.  For example, let’s say you have a
            file_under column for each album to tell you where to file it.  If the
            album is associated with an artist, it should be filed under the artist’s
            name and the album’s name, otherwise it should just use the album’s name.</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">artist</span>&#x000A;&#x000A;  <span class="ruby-identifier">private</span>&#x000A;&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">_artist=</span>(<span class="ruby-identifier">artist</span>)&#x000A;    <span class="ruby-keyword">if</span> <span class="ruby-identifier">artist</span>&#x000A;      <span class="ruby-keyword">self</span>.<span class="ruby-identifier">artist_id</span> = <span class="ruby-identifier">artist</span>.<span class="ruby-identifier">id</span>&#x000A;      <span class="ruby-keyword">self</span>.<span class="ruby-identifier">file_under</span> = <span class="ruby-node">&quot;#{artist.name}-#{name}&quot;</span>&#x000A;    <span class="ruby-keyword">else</span>&#x000A;      <span class="ruby-keyword">self</span>.<span class="ruby-identifier">artist_id</span> = <span class="ruby-keyword">nil</span>&#x000A;      <span class="ruby-keyword">self</span>.<span class="ruby-identifier">file_under</span> = <span class="ruby-identifier">name</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>The above example is contrived, as you would generally use a before_save
            model hook to handle such a modification.  However, if you only modify the
            album’s artist using the artist= method, this approach may perform better.</p>
            
            <h3 id="label-_add_association+%28%3Aadder+option%29">_add_<em>association</em> (:adder option)</h3>
            
            <p>Continuing with the same example, here’s how would you handle the same case
            if you also wanted to handle the Artist#add_album method:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>&#x000A;&#x000A;  <span class="ruby-identifier">private</span>&#x000A;&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">_add_album</span>(<span class="ruby-identifier">album</span>)&#x000A;    <span class="ruby-identifier">album</span>.<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">artist_id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">id</span>, :<span class="ruby-identifier">file_under=</span><span class="ruby-operator">&gt;</span><span class="ruby-node">&quot;#{name}-#{album.name}&quot;</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-_remove_association+%28%3Aremover+option%29">_remove_<em>association</em> (:remover option)</h3>
            
            <p>Continuing with the same example, here’s how would you handle the same case
            if you also wanted to handle the Artist#remove_album method:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>&#x000A;&#x000A;  <span class="ruby-identifier">private</span>&#x000A;&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">_remove_album</span>(<span class="ruby-identifier">album</span>)&#x000A;    <span class="ruby-identifier">album</span>.<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">artist_id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">nil</span>, :<span class="ruby-identifier">file_under=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">album</span>.<span class="ruby-identifier">name</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-_remove_all_association+%28%3Aclearer+option%29">_remove_all_<em>association</em> (:clearer option)</h3>
            
            <p>Continuing with the same example, here’s how would you handle the same case
            if you also wanted to handle the Artist#remove_all_albums method:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>&#x000A;&#x000A;  <span class="ruby-identifier">private</span>&#x000A;&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">_remove_all_albums</span>&#x000A;    <span class="ruby-comment"># This is Dataset#update, not Model#update, so the :file_under=&gt;:name</span>&#x000A;    <span class="ruby-comment"># ends up being &quot;SET file_under = name&quot; in SQL.</span>&#x000A;    <span class="ruby-identifier">albums_dataset</span>.<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">artist_id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">nil</span>, :<span class="ruby-identifier">file_under=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">name</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="label-Association+Options">Association Options</h2>
            
            <p>Sequel’s associations mostly share the same options.  For ease of
            understanding, they are grouped here by section</p>
            
            <h3 id="label-Association+Dataset+Modification+Options">Association Dataset Modification Options</h3>
            
            <h4 id="label-block">block</h4>
            
            <p>All association defining methods take a block that is passed the default
            dataset and should return a modified copy of the dataset to use for the
            association.  For example, if you wanted an association that returns all
            albums of an artist that went gold (sold at least 500,000 copies):</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">gold_albums</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span>:<span class="ruby-constant">Album</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">copies_sold</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">500000</span>}&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-%3Aclass">:class</h4>
            
            <p>This is the class of the associated objects that will be used.  It’s one of
            the most commonly used options.  If it is not given, it guesses based on
            the name of the association.  If a *_to_many association is used, uses the
            singular form of the association name.  For example:</p>
            
            <pre>Album.many_to_one :artist # guesses Artist&#x000A;Artist.one_to_many :albums # guesses Album</pre>
            
            <p>However, for more complex associations, especially ones that add additional
            filters beyond the foreign/primary key relationships, the default class
            guessed will be wrong:</p>
            
            <pre class="ruby"><span class="ruby-comment"># guesses GoldAlbum</span>&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">gold_albums</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">copies_sold</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">500000</span>}&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>You can specify the :class option using the class itself, a <a
            href="../../classes/Symbol.html">Symbol</a>, or a String:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">artist</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-constant">Artist</span> <span class="ruby-comment"># Class</span>&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">artist</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span>:<span class="ruby-constant">Artist</span> <span class="ruby-comment"># Symbol</span>&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">artist</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;Artist&quot;</span> <span class="ruby-comment"># String</span></pre>
            
            <h4 id="label-%3Akey">:key</h4>
            
            <p>For <code>many_to_one</code> associations, is the foreign_key in current
            model’s table that references associated model’s primary key, as a symbol. 
            Defaults to :<em>association</em>_id.  Can use an array of symbols for a
            composite key association.</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">artist</span> <span class="ruby-comment"># :key=&gt;:artist_id</span></pre>
            
            <p>For <code>one_to_one</code> and <code>one_to_many</code> associations, is
            the foreign key in associated model’s table that references current model’s
            primary key, as a symbol.  Defaults to :“#{self.name.underscore}_id”.</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span> <span class="ruby-comment"># :key=&gt;:artist_id</span></pre>
            
            <p>In both cases an array of symbols can be used for a composite key
            association:</p>
            
            <pre class="ruby"><span class="ruby-constant">Apartment</span>.<span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">building</span> <span class="ruby-comment"># :key=&gt;[:city, :address]</span></pre>
            
            <h4 id="label-%3Aconditions">:conditions</h4>
            
            <p>The conditions to use to filter the association, can be any argument passed
            to <code>where</code>. If you use a hash or an array of two element arrays,
            this will also be used as a filter when using eager_graph to load the
            association.</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">good_albums</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span>:<span class="ruby-constant">Album</span>, :<span class="ruby-identifier">conditions=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">good=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>}&#x000A;<span class="ruby-ivar">@artist</span>.<span class="ruby-identifier">good_albums</span>&#x000A;<span class="ruby-comment"># SELECT * FROM albums WHERE ((artist_id = 1) AND (good IS TRUE))</span></pre>
            
            <h4 id="label-%3Aorder">:order</h4>
            
            <p>The column(s) by which to order the association dataset.  Can be a singular
            column or an array.</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums_by_name</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span>:<span class="ruby-constant">Album</span>,&#x000A; :<span class="ruby-identifier">order=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">name</span>&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums_by_num_tracks</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span>:<span class="ruby-constant">Album</span>,&#x000A; :<span class="ruby-identifier">order=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">num_tracks</span>, :<span class="ruby-identifier">name</span>]</pre>
            
            <h4 id="label-%3Aselect">:select</h4>
            
            <p>The columns to SELECT when loading the association.  For most associations,
            it defaults to nil, so * is used.  For <code>many_to_many</code>
            associations, it defaults to the associated class’s table_name.*, which
            means it doesn’t include the columns from the join table.  This is to
            prevent the common issue where the join table includes columns with the
            same name as columns in the associated table, in which case the joined
            table’s columns would usually end up clobbering the values in the
            associated table. If you want to include the join table attributes, you can
            use this option, but beware that the join table columns can clash with
            columns from the associated table, so you should alias any columns that
            have the same name in both the join table and the associated table. 
            Example:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>, :<span class="ruby-identifier">select=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">name</span>]&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">tags</span>, :<span class="ruby-identifier">select=</span><span class="ruby-operator">&gt;</span>[<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">expr</span>(:<span class="ruby-identifier">tags</span>).*, :<span class="ruby-identifier">albums_tags__number</span>]</pre>
            
            <h4 id="label-%3Alimit">:limit</h4>
            
            <p>Limit the number of records to the provided value:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">best_selling_albums</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span>:<span class="ruby-constant">Album</span>,&#x000A;:<span class="ruby-identifier">order=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">copies_sold</span>, :<span class="ruby-identifier">limit=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">5</span> <span class="ruby-comment"># LIMIT 5</span></pre>
            
            <p>Use an array with two arguments for the value to specify a limit and an
            offset.</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">next_best_selling_albums</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span>:<span class="ruby-constant">Album</span>,&#x000A; :<span class="ruby-identifier">order=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">copies_sold</span>, :<span class="ruby-identifier">limit=</span><span class="ruby-operator">&gt;</span>[<span class="ruby-value">10</span>, <span class="ruby-value">5</span>] <span class="ruby-comment"># LIMIT 10 OFFSET 5</span></pre>
            
            <p>This probably doesn’t make a lot of sense for *_to_one associations, though
            you could use it to specify an offset.</p>
            
            <h4 id="label-%3Ajoin_table+%5Bmany_to_many%5D">:join_table [<code>many_to_many</code>]</h4>
            
            <p>Name of table that includes the foreign keys to both the current model and
            the associated model, as a symbol.  Defaults to the name of current model
            and name of associated model, pluralized, underscored, sorted, and joined
            with ‘_’. Here’s an example of the defaults:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">albums</span> <span class="ruby-comment"># :join_table=&gt;:albums_artists</span>&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">artists</span> <span class="ruby-comment"># :join_table=&gt;:albums_artists</span>&#x000A;<span class="ruby-constant">Person</span>.<span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">colleges</span> <span class="ruby-comment"># :join_table=&gt;:colleges_people</span></pre>
            
            <h4 id="label-%3Aleft_key+%5Bmany_to_many%5D">:left_key [<code>many_to_many</code>]</h4>
            
            <p>Foreign key in join table that points to current model’s primary key, as a
            symbol.  Defaults to :“#{model_name.underscore}_id”.</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">tags</span> <span class="ruby-comment"># :left_key=&gt;:album_id</span></pre>
            
            <p>Can use an array of symbols for a composite key association.</p>
            
            <h4 id="label-%3Aright_key+%5Bmany_to_many%5D">:right_key [<code>many_to_many</code>]</h4>
            
            <p>Foreign key in join table that points to associated model’s primary key, as
            a symbol.  Defaults to :“#{association_name.singularize}_id”.</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">tags</span> <span class="ruby-comment"># :right_key=&gt;:tag_id</span></pre>
            
            <p>Can use an array of symbols for a composite key association.</p>
            
            <h4 id="label-%3Adistinct">:distinct</h4>
            
            <p>Use the DISTINCT clause when selecting associating object, both when lazy
            loading and eager loading via eager (but not when using eager_graph).</p>
            
            <p>This is most useful for many_to_many associations that use join tables that
            contain more than just the foreign keys, where you are storing additional
            information.  For example, if you have a database of people, degree types,
            and colleges, and you want to return all people from a given college, you
            may want to use :distinct so that if a person has two separate degrees from
            the same college, they won’t show up twice.</p>
            
            <h4 id="label-%3Aclone">:clone</h4>
            
            <p>The :clone option clones an existing association, taking the options you
            specified for that association, and making a copy of them for this
            association.  Other options provided by this association are then merged
            into the cloned options.</p>
            
            <p>This is commonly used if you have a bunch of similar associations that you
            want to DRY up:</p>
            
            <pre class="ruby"><span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">english_verses</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span>:<span class="ruby-constant">LyricVerse</span>, :<span class="ruby-identifier">key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">lyricsongid</span>,&#x000A;  :<span class="ruby-identifier">order=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">number</span>, :<span class="ruby-identifier">conditions=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">languageid=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>}&#x000A;<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">romaji_verses</span>, :<span class="ruby-identifier">clone=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">english_verses</span>, :<span class="ruby-identifier">conditions=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">languageid=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">2</span>}&#x000A;<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">japanese_verses</span>, :<span class="ruby-identifier">clone=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">english_verses</span>, :<span class="ruby-identifier">conditions=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">languageid=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">3</span>}</pre>
            
            <p>Note that for the final two asociations, you didn’t have to specify the
            :class, :key, or :order options, as they were copied by the :clone option. 
            By specifying the :conditions option for the final two associations, it
            overrides the :conditions option of the first association, it doesn’t
            attempt to merge them.</p>
            
            <p>In addition to the options hash, the :clone option will copy a block
            argument from the existing situation.  If you want a cloned association to
            not have the same block as the association you are cloning from, specify
            the :block=&gt;nil option in additon to the :clone option.</p>
            
            <h4 id="label-%3Adataset">:dataset</h4>
            
            <p>This is generally only specified for custom associations that aren’t based
            on primary/foreign key relationships.  It should be a proc that is
            instance_execed to get the base dataset to use before the other options are
            applied.</p>
            
            <p>If the proc accepts an argument, it is passed the related association
            reflection. For best performance, it’s recommended that custom associations
            call the <code>associated_dataset</code> method on the association
            reflection as the starting point for the dataset to return.  The
            <code>associated_dataset</code> method will return a dataset based on the
            associated class with most of the association options already applied, and
            the proc should return a modified copy of this dataset.</p>
            
            <p>Here’s an example of an association of songs to artists through lyrics,
            where the artist can perform any one of four tasks for the lyric:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">songs</span>, :<span class="ruby-identifier">dataset=</span><span class="ruby-operator">&gt;</span>(<span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">associated_dataset</span>.<span class="ruby-identifier">select_all</span>(:<span class="ruby-identifier">songs</span>).&#x000A;   <span class="ruby-identifier">join</span>(<span class="ruby-constant">Lyric</span>, :<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">lyricid</span>,&#x000A;    <span class="ruby-identifier">id</span>=<span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">composer_id</span>, :<span class="ruby-identifier">arranger_id</span>, :<span class="ruby-identifier">vocalist_id</span>, :<span class="ruby-identifier">lyricist_id</span>])&#x000A;<span class="ruby-keyword">end</span>)&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">songs_dataset</span>&#x000A;<span class="ruby-comment"># SELECT songs.* FROM songs</span>&#x000A;<span class="ruby-comment"># INNER JOIN lyrics ON</span>&#x000A;<span class="ruby-comment">#  lyrics.id = songs.lyric_id AND</span>&#x000A;<span class="ruby-comment">#  1 IN (composer_id, arranger_id, vocalist_id, lyricist_id)</span></pre>
            
            <h4 id="label-%3Aextend">:extend</h4>
            
            <p>A module or array of modules to extend the dataset with.  These are used to
            set up association extensions.  For more information , please see the <a
            href="advanced_associations_rdoc.html">Advanced Associations page</a></p>
            
            <h4 id="label-%3Aprimary_key">:primary_key</h4>
            
            <p>The column that the :key option references, as a symbol. For
            <code>many_to_one</code> associations, this column is in the associated
            table. For <code>one_to_one</code> and <code>one_to_many</code>
            associations, this column is in the current table.  In both cases, it
            defaults to the primary key of the table. Can use an array of symbols for a
            composite key association.</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">set_primary_key</span> :<span class="ruby-identifier">arid</span>&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span> <span class="ruby-comment"># :primary_key=&gt;:arid</span>&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">artist</span> <span class="ruby-comment"># :primary_key=&gt;:arid</span></pre>
            
            <h4 id="label-%3Aleft_primary_key+%5Bmany_to_many%5D">:left_primary_key [<code>many_to_many</code>]</h4>
            
            <p>Column in current table that :left_key option points to, as a symbol.
            Defaults to primary key of current table.</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">set_primary_key</span> :<span class="ruby-identifier">alid</span>&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">tags</span> <span class="ruby-comment"># :left_primary_key=&gt;:alid</span></pre>
            
            <p>Can use an array of symbols for a composite key association.</p>
            
            <h4 id="label-%3Aright_primary_key+%5Bmany_to_many%5D">:right_primary_key [<code>many_to_many</code>]</h4>
            
            <p>Column in associated table that :right_key points to, as a symbol. Defaults
            to primary key of the associated table.</p>
            
            <pre class="ruby"><span class="ruby-constant">Tag</span>.<span class="ruby-identifier">set_primary_key</span> :<span class="ruby-identifier">tid</span>&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">tags</span> <span class="ruby-comment"># :right_primary_key=&gt;:tid</span></pre>
            
            <p>Can use an array of symbols for a composite key association.</p>
            
            <h4 id="label-%3Ajoin_table_block+%5Bmany_to_many%5D">:join_table_block [<code>many_to_many</code>]</h4>
            
            <p>A proc that can be used to modify the dataset used in the
            add/remove/remove_all methods.  It’s separate from the association block,
            as that is called on a join of the join table and the associated table,
            whereas this option just applies to the join table.  It can be used to make
            sure that filters are used when deleting.</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">lead_guitar_albums</span>, :<span class="ruby-identifier">join_table_block=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">instrument_id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">5</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-Callback+Options">Callback Options</h3>
            
            <p>All callbacks can be specified as a <a
            href="../../classes/Symbol.html">Symbol</a>, Proc, or array of both/either
            specifying a callback to call.  Symbols are interpreted as instance methods
            that are called with the associated object.  Procs are called with the
            receiver as the first argument and the associated object as the second
            argument.  If an array is given, all of them are called in order.</p>
            
            <p>Before callbacks are often used to check preconditions, they can return
            false to signal <a href="../../classes/Sequel.html">Sequel</a> to abort the
            modification.  If any before callback returns false, the remaining before
            callbacks are not called and modification is aborted.  Before callbacks are
            also commonly used to modify the current object or the associated object.</p>
            
            <p>After callbacks are often used for notification (logging, email) after a
            successful modification has been made.</p>
            
            <h4 id="label-%3Abefore_add+%5Bone_to_many%2C+many_to_many%5D">:before_add [<code>one_to_many</code>, <code>many_to_many</code>]</h4>
            
            <p>Called before adding an object to the association:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span>&#x000A;  <span class="ruby-comment"># Don't allow adding an album to an artist if it has no tracks</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>, :<span class="ruby-identifier">before_add=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ar</span>, <span class="ruby-identifier">al</span><span class="ruby-operator">|</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">al</span>.<span class="ruby-identifier">num_tracks</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>}&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-%3Aafter_add+%5Bone_to_many%2C+many_to_many%5D">:after_add [<code>one_to_many</code>, <code>many_to_many</code>]</h4>
            
            <p>Called after adding an object to the association:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span>&#x000A;  <span class="ruby-comment"># Log all associations of albums to an audit logging table</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>, :<span class="ruby-identifier">after_add=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">log_add_album</span>&#x000A;&#x000A;  <span class="ruby-identifier">private</span>&#x000A;&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">log_add_album</span>(<span class="ruby-identifier">album</span>)&#x000A;    <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">audit_logs</span>].<span class="ruby-identifier">insert</span>(:<span class="ruby-identifier">log=</span><span class="ruby-operator">&gt;</span><span class="ruby-node">&quot;Album #{album.inspect} associated to #{inspect}&quot;</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-%3Abefore_remove+%5Bone_to_many%2C+many_to_many%5D">:before_remove [<code>one_to_many</code>, <code>many_to_many</code>]</h4>
            
            <p>Called before removing an object from the association:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span>&#x000A;  <span class="ruby-comment"># Don't allow removing a self-titled album</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>, :<span class="ruby-identifier">before_remove=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ar</span>, <span class="ruby-identifier">al</span><span class="ruby-operator">|</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">al</span>.<span class="ruby-identifier">name</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">ar</span>.<span class="ruby-identifier">name</span>}&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-%3Aafter_remove+%5Bone_to_many%2C+many_to_many%5D">:after_remove [<code>one_to_many</code>, <code>many_to_many</code>]</h4>
            
            <p>Called after removing an object from the association:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span>&#x000A;  <span class="ruby-comment"># Log all disassociations of albums to an audit logging table</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>, :<span class="ruby-identifier">after_remove=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">log_remove_album</span>&#x000A;&#x000A;  <span class="ruby-identifier">private</span>&#x000A;&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">log_remove_album</span>(<span class="ruby-identifier">album</span>)&#x000A;    <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">audit_logs</span>].<span class="ruby-identifier">insert</span>(:<span class="ruby-identifier">log=</span><span class="ruby-operator">&gt;</span><span class="ruby-node">&quot;Album #{album.inspect} disassociated from #{inspect}&quot;</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-%3Abefore_set+%5Bmany_to_one%2C+one_to_one%5D">:before_set [<code>many_to_one</code>, <code>one_to_one</code>]</h4>
            
            <p>Called before the _<em>association</em>= method is called to modify the
            objects:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span>&#x000A;  <span class="ruby-comment"># Don't associate the album with an artist if the year the album was</span>&#x000A;  <span class="ruby-comment"># released is less than the year the artist/band started.</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">artist</span>, :<span class="ruby-identifier">before_set=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">al</span>, <span class="ruby-identifier">ar</span><span class="ruby-operator">|</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">al</span>.<span class="ruby-identifier">year</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">ar</span>.<span class="ruby-identifier">year_started</span>}&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-%3Aafter_set+%5Bmany_to_one%2C+one_to_one%5D">:after_set [<code>many_to_one</code>, <code>one_to_one</code>]</h4>
            
            <p>Called after the _<em>association</em>= method is called to modify the
            objects:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span>&#x000A;  <span class="ruby-comment"># Log all disassociations of albums to an audit logging table</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">artist</span>, :<span class="ruby-identifier">after_set=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">log_artist_set</span>&#x000A;&#x000A;  <span class="ruby-identifier">private</span>&#x000A;&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">log_artist_set</span>(<span class="ruby-identifier">artist</span>)&#x000A;    <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">audit_logs</span>].<span class="ruby-identifier">insert</span>(:<span class="ruby-identifier">log=</span><span class="ruby-operator">&gt;</span><span class="ruby-node">&quot;Artist for album #{inspect} set to #{artist.inspect}&quot;</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-%3Aafter_load">:after_load</h4>
            
            <p>Called after retrieving the associated records from the database.</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span>&#x000A;  <span class="ruby-comment"># Cache all album names to a single string when retrieving the</span>&#x000A;  <span class="ruby-comment"># albums.</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>, :<span class="ruby-identifier">after_load=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">cache_album_names</span>&#x000A;&#x000A;  <span class="ruby-identifier">attr_reader</span> :<span class="ruby-identifier">album_names</span>&#x000A;&#x000A;  <span class="ruby-identifier">private</span>&#x000A;&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">cache_album_names</span>(<span class="ruby-identifier">albums</span>)&#x000A;    <span class="ruby-ivar">@album_names</span> = <span class="ruby-identifier">albums</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">name</span>}.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;, &quot;</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Generally used if you know you will always want a certain action done when
            retrieving the association.</p>
            
            <p>For <code>one_to_many</code> and <code>many_to_many</code> associations,
            both the argument to symbol callbacks and the second argument to proc
            callbacks will be an array of associated objects instead of a single
            object.</p>
            
            <h4 id="label-%3Auniq+%5Bmany_to_many%5D">:uniq [<code>many_to_many</code>]</h4>
            
            <p>Adds a after_load callback that makes the array of objects unique. In many
            cases, using the :distinct option is a better approach.</p>
            
            <h3 id="label-Eager+Loading+via+eager+%28query+per+association%29+Options">Eager Loading via eager (query per association) Options</h3>
            
            <h4 id="label-%3Aeager">:eager</h4>
            
            <p>The associations to eagerly load via eager when loading the associated
            object(s). This is useful for example if you always want to eagerly load
            dependent associations when loading this association.</p>
            
            <p>For example, if you know that any time that you want to load an artist’s
            albums, you are also going to want access to the album’s tracks as well:</p>
            
            <pre class="ruby"><span class="ruby-comment"># Eager load tracks when loading the albums</span>&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>, :<span class="ruby-identifier">eager=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">tracks</span></pre>
            
            <p>You can also use a hash or array to specify multiple dependent associations
            to eagerly load:</p>
            
            <pre class="ruby"><span class="ruby-comment"># Eager load the albums' tracks and the tracks' tags when loading the albums</span>&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>, :<span class="ruby-identifier">eager=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">tracks=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">tags</span>}&#x000A;<span class="ruby-comment"># Eager load the albums' tags and tracks when loading the albums</span>&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>, :<span class="ruby-identifier">eager=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">tags</span>, :<span class="ruby-identifier">tracks</span>]&#x000A;<span class="ruby-comment"># Eager load the albums' tags, tracks, and tracks' tags when loading the albums</span>&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>, :<span class="ruby-identifier">eager=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">tags</span>, {:<span class="ruby-identifier">tracks=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">tags</span>}]</pre>
            
            <h4 id="label-%3Aeager_loader">:eager_loader</h4>
            
            <p>A custom loader to use when eagerly load associated objects via eager. For
            many details and examples of custom eager loaders, please see the <a
            href="advanced_associations_rdoc.html">Advanced Associations guide</a></p>
            
            <h4 id="label-%3Aeager_loader_key">:eager_loader_key</h4>
            
            <p>A symbol for the key column to use to populate the key hash for the eager
            loader.  Generally does not need to be set manually, defaults to the key
            method used.  Can be set to nil to not populate the key hash (better for
            performance if a custom eager loader does not use the key_hash).</p>
            
            <h4 id="label-%3Aeager_block">:eager_block</h4>
            
            <p>If given, should be a proc to use instead of the association method block
            when eagerly loading.  To not use a block when eager loading when one is
            used normally, should to nil.  It’s very uncommon to need this option.</p>
            
            <h3 id="label-Eager+Loading+via+eager_graph+%28one+query+with+joins%29+Options">Eager Loading via eager_graph (one query with joins) Options</h3>
            
            <h4 id="label-%3Aeager_graph">:eager_graph</h4>
            
            <p>The associations to eagerly load via eager_graph when loading the
            associated object(s). This is useful for example if you always want to
            eagerly load dependent associations when loading this association, but you
            want to filter or order the association based on dependent associations:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums_with_short_tracks</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span>:<span class="ruby-constant">Album</span>,&#x000A; :<span class="ruby-identifier">eager_graph=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">tracks</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">tracks__seconds</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">120</span>}&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums_by_track_name</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span>:<span class="ruby-constant">Album</span>,&#x000A; :<span class="ruby-identifier">eager_graph=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">tracks</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">order</span>(:<span class="ruby-identifier">tracks__name</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>You can also use a hash or array of arguments for :eager_graph, similar to
            what the :eager option accepts.</p>
            
            <h4 id="label-%3Agraph_conditions">:graph_conditions</h4>
            
            <p>The additional conditions to use on the SQL join when eagerly loading the
            association via eager_graph.  Should be a hash or an array of two element
            arrays.  If not specified, the :conditions option is used if it is a hash
            or array of two element arrays.</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">active_albums</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span>:<span class="ruby-constant">Album</span>,&#x000A;  :<span class="ruby-identifier">graph_conditions=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">active=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>}</pre>
            
            <p>Note that these conditions on the association are in addition to the
            default conditions specified by the foreign/primary keys.  If you want to
            replace the conditions specified by the foreign/primary keys, you need the
            :graph_only_conditions options.</p>
            
            <h4 id="label-%3Agraph_block">:graph_block</h4>
            
            <p>The block to pass to Dataset#join_table when eagerly loading the
            association via eager_graph.  This is useful to specify conditions that
            can’t be specified in a hash or array of two element arrays.</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">gold_albums</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span>:<span class="ruby-constant">Album</span>,&#x000A;  :<span class="ruby-identifier">graph_block=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">j</span>,<span class="ruby-identifier">lj</span>,<span class="ruby-identifier">js</span><span class="ruby-operator">|</span> <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">qualify</span>(<span class="ruby-identifier">j</span>, :<span class="ruby-identifier">copies_sold</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-value">500000</span>}</pre>
            
            <h4 id="label-%3Agraph_join_type">:graph_join_type</h4>
            
            <p>The type of SQL join to use when eagerly loading the association via
            eager_graph.  Defaults to :left_outer.  This is useful if you want to
            ensure that only artists that have albums are returned:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>, :<span class="ruby-identifier">graph_join_type=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">inner</span>&#x000A;<span class="ruby-comment"># Will exclude artists without an album</span>&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager_graph</span>(:<span class="ruby-identifier">albums</span>).<span class="ruby-identifier">all</span></pre>
            
            <h4 id="label-%3Agraph_select">:graph_select</h4>
            
            <p>A column or array of columns to select from the associated table when
            eagerly loading the association via eager_graph. Defaults to all columns in
            the associated table.</p>
            
            <h4 id="label-%3Agraph_only_conditions">:graph_only_conditions</h4>
            
            <p>The conditions to use on the SQL join when eagerly loading the association
            via eager_graph, instead of the default conditions specified by the
            foreign/primary keys.  This option causes the :graph_conditions option to
            be ignored.  This can be useful if the keys you are using are strings and
            you want to do a case insensitive comparison.  For example, let’s say that
            instead of integer keys, you used string keys based on the album or artist
            name, and that the album was associated to the artist by name.  However,
            you weren’t enforcing case sensitivity between the keys, so you still want
            to return albums where the artist’s name differs in case:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>, :<span class="ruby-identifier">key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artist_name</span>, &#x000A;  :<span class="ruby-identifier">graph_only_conditions=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">nil</span>, &#x000A;  :<span class="ruby-identifier">graph_block=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">j</span>,<span class="ruby-identifier">lj</span>,<span class="ruby-identifier">js</span><span class="ruby-operator">|</span> {<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">function</span>(:<span class="ruby-identifier">lower</span>, <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">qualify</span>(<span class="ruby-identifier">j</span>, :<span class="ruby-identifier">artist_name</span>))=<span class="ruby-operator">&gt;</span>&#x000A;    <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">function</span>(:<span class="ruby-identifier">lower</span>, <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">qualify</span>(<span class="ruby-identifier">lj</span>, :<span class="ruby-identifier">name</span>))}}</pre>
            
            <p>Note how :graph_only_conditions is set to nil to ignore any existing
            conditions, and :graph_block is used to set up the case insensitive
            comparison.</p>
            
            <p>Another case where :graph_only_conditions may be used is if you want to use
            a JOIN USING or NATURAL JOIN for the graph:</p>
            
            <pre class="ruby"><span class="ruby-comment"># JOIN USING</span>&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>, :<span class="ruby-identifier">key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artist_name</span>,&#x000A; :<span class="ruby-identifier">graph_only_conditions=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">artist_name</span>]&#x000A;&#x000A;<span class="ruby-comment"># NATURAL JOIN</span>&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>, :<span class="ruby-identifier">key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artist_name</span>,&#x000A; :<span class="ruby-identifier">graph_only_conditions=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">nil</span>, :<span class="ruby-identifier">graph_join_type=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">natural</span></pre>
            
            <h4 id="label-%3Agraph_alias_base">:graph_alias_base</h4>
            
            <p>The base name to use for the table alias when eager graphing.  Defaults to
            the name of the association.  If the alias name has already been used in
            the query, <a href="../../classes/Sequel.html">Sequel</a> will create a
            unique alias by appending a numeric suffix (e.g. alias_0, alias_1, …) until
            the alias is unique.</p>
            
            <p>This is mostly useful if you have associations with the same name in many
            models, and you want to be able to easily tell which table alias
            corresponds to which association when eagerly graphing multiple
            associations with the same name.</p>
            
            <p>You can override this option on a per-graph basis by specifying the
            association as an SQL::AliasedExpression instead of a symbol:</p>
            
            <pre>Album.eager_graph(Sequel.as(:artist, :a))</pre>
            
            <h4 id="label-%3Aeager_grapher">:eager_grapher</h4>
            
            <p>Sets up a custom grapher to use when eager loading the objects via
            eager_graph. This is the eager_graph analogue to the :eager_loader option.
            This isn’t generally needed, as one of the other eager_graph related
            association options is usually sufficient.</p>
            
            <p>If specified, should be a proc that accepts a single hash argument, which
            will contain at least the following keys:</p>
            <dl class="rdoc-list note-list"><dt>:self 
            <dd>
            <p>The dataset that is doing the eager loading</p>
            </dd><dt>:table_alias 
            <dd>
            <p>An alias to use for the table to graph for this association.</p>
            </dd><dt>:implicit_qualifier 
            <dd>
            <p>The alias that was used for the current table (since you can cascade
            associations).</p>
            </dd><dt>:callback 
            <dd>
            <p>A callback proc used to dynamically modify the dataset to graph into the
            current dataset, before such graphing is done. This is nil if no callback
            proc is used.</p>
            </dd></dl>
            
            <p>Example:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">self_title_albums</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span>:<span class="ruby-constant">Album</span>,&#x000A; :<span class="ruby-identifier">eager_grapher=</span><span class="ruby-operator">&gt;</span>(<span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">eo</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">eo</span>[:<span class="ruby-keyword">self</span>].<span class="ruby-identifier">graph</span>(<span class="ruby-constant">Album</span>, {:<span class="ruby-identifier">artist_id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">name</span>},&#x000A;    :<span class="ruby-identifier">table_alias=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">eo</span>[:<span class="ruby-identifier">table_alias</span>], :<span class="ruby-identifier">implicit_qualifier=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">eo</span>[:<span class="ruby-identifier">implicit_qualifier</span>])&#x000A;<span class="ruby-keyword">end</span>)</pre>
            
            <h4 id="label-%3Aorder_eager_graph">:order_eager_graph</h4>
            
            <p>Whether to add the order to the dataset’s order when graphing via
            eager_graph. Defaults to true, so set to false to disable.</p>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> has to do some guess work
            when attempting to add the association's order to an eager_graphed dataset.
            In most cases it does so correctly, but if it has problems, you'll probably
            want to set this option to false.</p>
            
            <h4 id="label-%3Agraph_join_table_conditions+%5Bmany_to_many%5D">:graph_join_table_conditions [<code>many_to_many</code>]</h4>
            
            <p>The additional conditions to use on the SQL join for the join table when
            eagerly loading the association via eager_graph. Should be a hash or an
            array of two element arrays.</p>
            
            <p>Let’s say you have a database of people, colleges, and a table called
            degrees_received that includes a string field specifying the name of the
            degree, and you want to eager load all colleges for people where the person
            has received a specific degree:</p>
            
            <pre class="ruby"><span class="ruby-constant">Person</span>.<span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">bs_degree_colleges</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span>:<span class="ruby-constant">College</span>,&#x000A;  :<span class="ruby-identifier">join_table=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">degrees_received</span>, &#x000A;  :<span class="ruby-identifier">graph_join_table_conditions=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">degree=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'BS'</span>}</pre>
            
            <h4 id="label-%3Agraph_join_table_block+%5Bmany_to_many%5D">:graph_join_table_block [<code>many_to_many</code>]</h4>
            
            <p>The block to pass to join_table for the join table when eagerly loading the
            association via eager_graph.  This is used for similar reasons as
            :graph_block, but is only used for <code>many_to_many</code> associations
            when graphing the join table into the dataset.  It’s used in the same place
            as :graph_join_table_conditions but like :graph_block, is needed for
            situations where the conditions can’t be specified as a hash or array of
            two element arrays.</p>
            
            <p>Let’s say you have a database of people, colleges, and a table called
            degrees_received that includes a string field specifying the name of the
            degree, and you want to eager load all colleges for people where the person
            has received a bachelor’s degree (degree starting with B):</p>
            
            <pre class="ruby"><span class="ruby-constant">Person</span>.<span class="ruby-identifier">many_to_many</span> :<span class="ruby-identifier">bachelor_degree_colleges</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span>:<span class="ruby-constant">College</span>,&#x000A;  :<span class="ruby-identifier">join_table=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">degrees_received</span>,&#x000A;  :<span class="ruby-identifier">graph_join_table_block=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">j</span>,<span class="ruby-identifier">lj</span>,<span class="ruby-identifier">js</span><span class="ruby-operator">|</span> <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">qualify</span>(<span class="ruby-identifier">j</span>, :<span class="ruby-identifier">degree</span>).<span class="ruby-identifier">like</span>(<span class="ruby-string">'B%'</span>)}</pre>
            
            <p>This should be done when graphing the join table, instead of when graphing
            the final table, as :degree is a column of the join table.</p>
            
            <h4 id="label-%3Agraph_join_table_join_type+%5Bmany_to_many%5D">:graph_join_table_join_type [<code>many_to_many</code>]</h4>
            
            <p>The type of SQL join to use for the join table when eagerly loading the
            association via eager_graph.  Defaults to the :graph_join_type option or
            :left_outer.  This exists mainly for consistency in the unlikely case that
            you want to use a different join type when JOINing to the join table then
            you want to use for JOINing to the final table</p>
            
            <h4 id="label-%3Agraph_join_table_only_conditions+%5Bmany_to_many%5D">:graph_join_table_only_conditions [<code>many_to_many</code>]</h4>
            
            <p>The conditions to use on the SQL join for the join table when eagerly
            loading the association via eager_graph, instead of the default conditions
            specified by the foreign/primary keys.  This option causes the
            :graph_join_table_conditions option to be ignored.  This is only useful if
            you want to replace the default foreign/primary key conditions that <a
            href="../../classes/Sequel.html">Sequel</a> would use when eagerly
            graphing.</p>
            
            <h3 id="label-Column+Naming+Conflict+Options">Column Naming Conflict Options</h3>
            
            <p>Sequel’s association support historically called methods on model objects
            to get primary key or foreign key values instead of accessing the column
            values directly, in order to allow advanced features such as associations
            based on virtual column keys.  Unfortunately, that causes issues if columns
            are used with names that clash with existing method names, which can happen
            if you want to name the association the same name as an existing column, or
            if the column has the same name as an already defined method such as
            <code>object_id</code>.</p>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> has added the following
            options that allow you to work around the issue by either specifying the
            column name symbol or the method name symbol to use.  In most cases, these
            methods are designed to be used with column aliases defined with
            <code>Model.def_column_alias</code>:</p>
            
            <pre class="ruby"><span class="ruby-comment"># Example schema:</span>&#x000A;<span class="ruby-comment">#  albums           artists</span>&#x000A;<span class="ruby-comment">#   :id        /--&gt;  :id</span>&#x000A;<span class="ruby-comment">#   :artist --/      :name</span>&#x000A;<span class="ruby-comment">#   :name</span>&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">def_column_alias</span>(:<span class="ruby-identifier">artist_id</span>, :<span class="ruby-identifier">artist</span>)&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">artist</span>, :<span class="ruby-identifier">key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artist_id</span>, :<span class="ruby-identifier">key_column=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artist</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-comment"># Example schema:</span>&#x000A;<span class="ruby-comment">#  things              objs</span>&#x000A;<span class="ruby-comment">#   :id           /--&gt;  :id</span>&#x000A;<span class="ruby-comment">#   :object_id --/      :name</span>&#x000A;<span class="ruby-comment">#   :name</span>&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Thing</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">def_column_alias</span>(:<span class="ruby-identifier">obj_id</span>, :<span class="ruby-identifier">object_id</span>)&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Obj</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">things</span>, :<span class="ruby-identifier">key=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">object_id</span>, :<span class="ruby-identifier">key_method=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">obj_id</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-%3Akey_column+%5Bmany_to_one%5D">:key_column [<code>many_to_one</code>]</h4>
            
            <p>Like the :key option, but :key references the method name, while
            :key_column references the underlying column.</p>
            
            <h4 id="label-%3Aprimary_key_method+%5Bmany_to_one%5D">:primary_key_method [<code>many_to_one</code>]</h4>
            
            <p>Like the :primary_key option, but :primary_key references the column name,
            while :primary_key_method references the method name.</p>
            
            <h4 id="label-%3Aprimary_key_column+%5Bone_to_many%2C+one_to_one%5D">:primary_key_column [<code>one_to_many</code>, <code>one_to_one</code>]</h4>
            
            <p>Like the :primary_key option, but :primary_key references the method name,
            while :primary_key_column references the underlying column.</p>
            
            <h4 id="label-%3Akey_method+%5Bone_to_many%2C+one_to_one%5D">:key_method [<code>one_to_many</code>, <code>one_to_one</code>]</h4>
            
            <p>Like the :key option, but :key references the column name, while
            :key_method references the method name.</p>
            
            <h4 id="label-%3Aleft_primary_key_column+%5Bmany_to_many%5D">:left_primary_key_column [<code>many_to_many</code>]</h4>
            
            <p>Like the :left_primary_key option, but :left_primary_key references the
            method name, while :left_primary_key_column references the underlying
            column.</p>
            
            <h4 id="label-%3Aright_primary_key_method+%5Bmany_to_many%5D">:right_primary_key_method [<code>many_to_many</code>]</h4>
            
            <p>Like the :right_primary_key option, but :right_primary_key references the
            column name, while :right_primary_key_method references the method name.</p>
            
            <h3 id="label-Private+Method+Overriding+Options">Private Method Overriding Options</h3>
            
            <p>These options override the private methods that <a
            href="../../classes/Sequel.html">Sequel</a> defines to do the actual work
            of associating and deassociating objects.</p>
            
            <h4 id="label-%3Asetter+%5B%2A_to_one+associations%5D">:setter [*_to_one associations]</h4>
            
            <p>This overrides the default behavior when you call an association setter
            method.  Let’s say you want to set a specific field whenever associating an
            object using the association setter method.</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">many_to_one</span> :<span class="ruby-identifier">artist</span>, :<span class="ruby-identifier">setter=</span><span class="ruby-operator">&gt;</span>(<span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">artist</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-keyword">if</span> <span class="ruby-identifier">artist</span>&#x000A;      <span class="ruby-keyword">self</span>.<span class="ruby-identifier">artist_id</span> = <span class="ruby-identifier">artist</span>.<span class="ruby-identifier">id</span>&#x000A;      <span class="ruby-keyword">self</span>.<span class="ruby-identifier">file_under</span> = <span class="ruby-node">&quot;#{artist.name}-#{name}&quot;</span>&#x000A;    <span class="ruby-keyword">else</span>&#x000A;      <span class="ruby-keyword">self</span>.<span class="ruby-identifier">artist_id</span> = <span class="ruby-keyword">nil</span>&#x000A;      <span class="ruby-keyword">self</span>.<span class="ruby-identifier">file_under</span> = <span class="ruby-identifier">name</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-%3Aadder+%5B%2A_to_many+associations%5D">:adder [*_to_many associations]</h4>
            
            <p>Continuing with the same example, here’s how would you handle the same case
            if you also wanted to handle the Artist#add_album method:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>, :<span class="ruby-identifier">adder=</span><span class="ruby-operator">&gt;</span>(<span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">album</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">album</span>.<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">artist_id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">id</span>, :<span class="ruby-identifier">file_under=</span><span class="ruby-operator">&gt;</span><span class="ruby-node">&quot;#{name}-#{album.name}&quot;</span>)&#x000A;  <span class="ruby-keyword">end</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-%3Aremover+%5B%2A_to_many+associations%5D">:remover [*_to_many associations]</h4>
            
            <p>Continuing with the same example, here’s how would you handle the same case
            if you also wanted to handle the Artist#remove_album method:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>, :<span class="ruby-identifier">remover=</span><span class="ruby-operator">&gt;</span>(<span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">album</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">album</span>.<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">artist_id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">nil</span>, :<span class="ruby-identifier">file_under=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">album</span>.<span class="ruby-identifier">name</span>)&#x000A;  <span class="ruby-keyword">end</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-%3Aclearer+%5B%2A_to_many+associations%5D">:clearer [*_to_many associations]</h4>
            
            <p>Continuing with the same example, here’s how would you handle the same case
            if you also wanted to handle the Artist#remove_all_albums method:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Artist</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>, :<span class="ruby-identifier">clearer=</span><span class="ruby-operator">&gt;</span>(<span class="ruby-identifier">proc</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">albums_dataset</span>.<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">artist_id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">nil</span>, :<span class="ruby-identifier">file_under=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">name</span>)&#x000A;  <span class="ruby-keyword">end</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-Advanced+Options">Advanced Options</h3>
            
            <h4 id="label-%3Areciprocal">:reciprocal</h4>
            
            <p>The symbol name of the reciprocal association, if it exists.  By default,
            <a href="../../classes/Sequel.html">Sequel</a> will try to determine it by
            looking at the associated model’s associations for a association that
            matches the current association’s key(s). Set to nil to not use a
            reciprocal.</p>
            
            <p>Reciprocals are used in <a href="../../classes/Sequel.html">Sequel</a> to
            modify the matching cached associations in associated objects when calling
            association methods on the current object. For example, when you retrieve
            objects in a one_to_many association, it’ll automatically set the matching
            many_to_one association in the associated objects.  The result of this is
            that code that does this:</p>
            
            <pre class="ruby"><span class="ruby-ivar">@artist</span>.<span class="ruby-identifier">albums</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">album</span><span class="ruby-operator">|</span> <span class="ruby-identifier">album</span>.<span class="ruby-identifier">artist</span>.<span class="ruby-identifier">name</span>}</pre>
            
            <p>only does one database query, because when the @artist’s albums are
            retrieved, the cached artist association for each album is set to @artist.</p>
            
            <p>In addition to the one_to_many retrieval case, the association modification
            methods affect the reciprocals as well:</p>
            
            <pre># Sets the cached artist association for @album to @artist&#x000A;@artist.add_album(@album)&#x000A;# Sets the cached artist association for @album to nil&#x000A;@artist.remove_album(@album)&#x000A;&#x000A;# Sets the cached artist association to nil for the @artist's&#x000A;# cached albums association&#x000A;@artist.remove_all_albums&#x000A;&#x000A;# Remove @album from the artist1's cached albums association, and add @album&#x000A;# to @artist2's cached albums association.&#x000A;@album.artist # @artist1&#x000A;@album.artist = @artist2</pre>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> can usually guess the
            correct reciprocal, but if you have multiple associations to the same
            associated class that use the same keys, you may want to specify the
            :reciprocal option manually to ensure the correct one is used.</p>
            
            <h4 id="label-%3Aread_only">:read_only</h4>
            
            <p>For <code>many_to_one</code> and <code>one_to_one</code> associations, do
            not add a setter method. For <code>one_to_many</code> and
            <code>many_to_many</code>, do not add the add_<em>association</em>,
            remove_<em>association</em>, or remove_all_<em>association</em> methods.</p>
            
            <p>If the default modification methods would not do what you want, and you
            don’t plan on overriding the internal modification methods to do what you
            want, it may be best to set this option to true.</p>
            
            <h4 id="label-%3Avalidate">:validate</h4>
            
            <p>Set to false to not validate when implicitly saving any associated object.
            When using the <code>one_to_many</code> association modification methods,
            the <code>one_to_one</code> setter method, or creating a new object by
            passing a hash to the add_<em>association</em> method, <a
            href="../../classes/Sequel.html">Sequel</a> will automatically save the
            object. If you don’t want to validate objects when these implicit saves are
            done, the validate option should be set to false.</p>
            
            <h4 id="label-%3Aallow_eager">:allow_eager</h4>
            
            <p>If set to false, you cannot load the association eagerly via eager or
            eager_graph.</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">one_to_many</span> :<span class="ruby-identifier">albums</span>, :<span class="ruby-identifier">allow_eager=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">false</span>&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager</span>(:<span class="ruby-identifier">albums</span>) <span class="ruby-comment"># Raises Sequel::Error</span></pre>
            
            <p>This is usually used if the association dataset depends on specific values
            in model instance that would not be valid when eager loading for multiple
            instances.</p>
            
            <h4 id="label-%3Acartesian_product_number+">:cartesian_product_number </h4>
            
            <p>The number of joins completed by this association that could cause more
            than one row for each row in the current table (default: 0 for *_to_one
            associations, 1 for *_to_many associations).</p>
            
            <p>This should only be modified in specific cases.  For example, if you have a
            one_to_one association that can actually return more than one row (where
            the default association method will just return the first), or a
            many_to_many association where there is a unique index in the join table so
            that you know only one object will ever be associated through the
            association.</p>
            
            <h4 id="label-%3Amethods_module">:methods_module</h4>
            
            <p>The module that the methods created by the association will be placed into.
            Defaults to the module containing the model’s columns.  This is not
            included in the model’s class, so you are responsible for doing that
            manually.</p>
            
            <p>This is only useful in rare cases, such as when a plugin that adds
            associations depends on another plugin that defines instance methods of the
            same name.  In that case, the instance methods of the dependent plugin
            would override the association methods created by the main plugin.</p>
            
            <h4 id="label-%3Aeager_limit_strategy">:eager_limit_strategy</h4>
            
            <p>This setting determines what strategy to use for loading the associations
            that use the :limit setting to limit the number of returned records. You
            can’t use LIMIT directly, since you want a limit for each group of
            associated records, not a LIMIT on the total number of records returned by
            the dataset.</p>
            
            <p>By default, if a *_to_many association uses a limit or offset, or a
            one_to_one association uses an offset, <a
            href="../../classes/Sequel.html">Sequel</a> will choose to use an eager
            limit strategy.  The default strategy depends on the database being used. 
            For databases which support window functions, a window function will be
            used.  Other databases will just have an ruby array slice done on the
            entire record set.</p>
            
            <p>For one_to_one associations without offsets, no strategy is used by default
            because none is needed for a true one_to_one association (since there is
            only one associated record per current record).  However, if you are using
            a one_to_one association where the relationship is really one_to_many, and
            using an order to pick the first matching row, then if you don’t specify an
            :eager_limit_strategy option, you’ll be loading all related rows just to
            have <a href="../../classes/Sequel.html">Sequel</a> ignore all rows after
            the first.  By using a strategy to change the query to only return one
            associated record per current record, you can get much better database
            performance.</p>
            
            <p>In general, <a href="../../classes/Sequel.html">Sequel</a> picks an
            appropriate strategy, so it is not usually necessary to specify a specific
            strategy.  The exception is for one_to_one associations where there is more
            than one associated record per current record.  For those, you should
            probably specify true to this option to have <a
            href="../../classes/Sequel.html">Sequel</a> pick an appropriate strategy.</p>
            
            <p>You can also specify a symbol to manually choose a strategy.  The available
            strategies are:</p>
            <dl class="rdoc-list note-list"><dt>:distinct_on 
            <dd>
            <p>Uses DISTINCT ON to ensure only the first matching record is loaded (only
            used for one_to_one associations without offsets on PostgreSQL).</p>
            </dd><dt>:window_function 
            <dd>
            <p>Uses a ROW_NUMBER window functions to ensure the correctly limited/offset
            records are returned.</p>
            </dd><dt>:ruby 
            <dd>
            <p>Uses ruby array slicing to emulate database limiting/offsetting.</p>
            </dd></dl>
          </div>
          <div id='context'>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
