<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>postgresql.rdoc</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='file' id='wrapper'>
      <div class='header'>
        <h1 class='name'>postgresql.rdoc</h1>
        <div class='paths'>
          doc/postgresql.rdoc
        </div>
        <div class='last-update'>
          Last Update:
          <span class='datetime'>2013-11-08 08:08:17 -0500</span>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <h1 id="label-PostgreSQL-specific+Support+in+Sequel">PostgreSQL-specific Support in <a href="../../classes/Sequel.html">Sequel</a></h1>
            
            <p>Sequel’s core database and dataset functions are designed to support the
            features shared by most common SQL database implementations.  However,
            Sequel’s database adapters extend the core support to include support for
            database-specific features.</p>
            
            <p>By far the most extensive database-specific support in <a
            href="../../classes/Sequel.html">Sequel</a> is for PostgreSQL. This support
            is roughly broken into the following areas:</p>
            <ul><li>
            <p>Database Types</p>
            </li><li>
            <p>DDL Support</p>
            </li><li>
            <p>DML Support</p>
            </li><li>
            <p>sequel_pg</p>
            </li></ul>
            
            <p>Note that while this guide is extensive, it is not exhaustive.  There are
            additional rarely used PostgreSQL features that <a
            href="../../classes/Sequel.html">Sequel</a> supports which are not
            mentioned here.</p>
            
            <h2 id="label-Adapter%2FDriver+Specific+Support">Adapter/Driver Specific Support</h2>
            
            <p>Some of this this support depends on the specific adapter or underlying
            driver in use.</p>
            
            <p><code>postgres only</code> will denote support specific to the postgres
            adapter (i.e. not available when connecting to PostgreSQL via the jdbc, do,
            or swift adapters). <code>postgres/pg only</code> will denote support
            specific to the postgres adapter when pg is used as the underlying driver
            (i.e. not available when using the postgres-pr or postgres drivers).</p>
            
            <h2 id="label-PostgreSQL-specific+Database+Type+Support">PostgreSQL-specific Database Type Support</h2>
            
            <p>Sequel’s default support on PostgreSQL only includes common database types.
            However, <a href="../../classes/Sequel.html">Sequel</a> ships with support
            for many PostgreSQL-specific types via extensions.  In general, you load
            these extensions via <code>Database#extension</code>.  For example, to load
            support for arrays, you would do:</p>
            
            <pre>DB.extension :pg_array</pre>
            
            <p>The following PostgreSQL-specific type extensions are available:</p>
            <dl class="rdoc-list note-list"><dt>pg_array 
            <dd>
            <p>arrays (single and multidimensional, for any scalar type), as a ruby
            Array-like object</p>
            </dd><dt>pg_hstore 
            <dd>
            <p>hstore, as a ruby Hash-like object</p>
            </dd><dt>pg_inet 
            <dd>
            <p>inet/cidr, as ruby IPAddr objects</p>
            </dd><dt>pg_interval 
            <dd>
            <p>interval, as ActiveSupport::Duration objects</p>
            </dd><dt>pg_json 
            <dd>
            <p>json, as either ruby Array-like or Hash-like objects</p>
            </dd><dt>pg_range 
            <dd>
            <p>ranges (for any scalar type), as a ruby Range-like object</p>
            </dd><dt>pg_row 
            <dd>
            <p>row-valued/composite types, as a ruby Hash-like or <a
            href="../../classes/Sequel/Model.html">Sequel::Model</a> object</p>
            </dd></dl>
            
            <p>In general, these extensions just add support for Database objects to
            return retrieved column values as the appropriate type (<code>postgres&#x000A;only</code>), and support for literalizing the objects correctly for use in
            an SQL string, or using them as bound variable values (<code>postgres/pg&#x000A;only</code>).</p>
            
            <p>There are also type-specific extensions that make it easy to use database
            functions and operators related to the type.  These extensions are:</p>
            <dl class="rdoc-list note-list"><dt>pg_array_ops 
            <dd>
            <p>array-related functions and operators</p>
            </dd><dt>pg_hstore_ops 
            <dd>
            <p>hstore-related functions and operators</p>
            </dd><dt>pg_range_ops 
            <dd>
            <p>range-related functions and operators</p>
            </dd><dt>pg_row_ops 
            <dd>
            <p>row-valued/composite type syntax support</p>
            </dd></dl>
            
            <h2 id="label-PostgreSQL-specific+DDL+Support">PostgreSQL-specific DDL Support</h2>
            
            <h3 id="label-Exclusion+Constraints">Exclusion Constraints</h3>
            
            <p>In <code>create_table</code> blocks, you can use the <code>exclude</code>
            method to set up exclusion constraints:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">table</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">daterange</span> :<span class="ruby-identifier">during</span>&#x000A;  <span class="ruby-identifier">exclude</span>([[:<span class="ruby-identifier">during</span>, <span class="ruby-string">'&amp;&amp;'</span>]], :<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">table_during_excl</span>)&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-comment"># CREATE TABLE &quot;table&quot; (&quot;during&quot; daterange,</span>&#x000A;<span class="ruby-comment">#   CONSTRAINT &quot;table_during_excl&quot; EXCLUDE USING gist (&quot;during&quot; WITH &amp;&amp;))</span></pre>
            
            <p>You can also add exclusion constraints in <code>alter_table</code> blocks
            using add_exclusion_constraint:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">alter_table</span>(:<span class="ruby-identifier">table</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">add_exclusion_constraint</span>([[:<span class="ruby-identifier">during</span>, <span class="ruby-string">'&amp;&amp;'</span>]], :<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">table_during_excl</span>)&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-comment"># ALTER TABLE &quot;table&quot; ADD CONSTRAINT &quot;table_during_excl&quot; EXCLUDE USING gist (&quot;during&quot; WITH &amp;&amp;)</span></pre>
            
            <h3 id="label-Adding+Foreign+Key+Constraints+Without+Initial+Validation">Adding Foreign Key Constraints Without Initial Validation</h3>
            
            <p>You can add a <code>:not_valid=&gt;true</code> option when adding
            constraints to existing tables so that it doesn’t check if all current rows
            are valid:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">alter_table</span>(:<span class="ruby-identifier">table</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-comment"># Assumes t_id column already exists</span>&#x000A;  <span class="ruby-identifier">add_foreign_key</span>([:<span class="ruby-identifier">t_id</span>], :<span class="ruby-identifier">table</span>, :<span class="ruby-identifier">not_valid=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>, :<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">table_fk</span>)&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-comment"># ALTER TABLE &quot;table&quot; ADD CONSTRAINT &quot;table_fk&quot; FOREIGN KEY (&quot;t_id&quot;) REFERENCES &quot;table&quot; NOT VALID</span></pre>
            
            <p>Such constraints will be enforced for newly inserted and updated rows, but
            not for existing rows. After all existing rows have been fixed, you can
            validate the constraint:</p>
            
            <pre>DB.alter_table(:table) do&#x000A;  validate_constraint(:table_fk)&#x000A;end&#x000A;# ALTER TABLE &quot;table&quot; VALIDATE CONSTRAINT &quot;table_fk&quot;</pre>
            
            <h3 id="label-Creating+Indexes+Concurrently">Creating Indexes Concurrently</h3>
            
            <p>You can create indexes concurrently using the
            <code>:concurrently=&gt;true</code> option:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">add_index</span>(:<span class="ruby-identifier">table</span>, :<span class="ruby-identifier">t_id</span>, :<span class="ruby-identifier">concurrently=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>)&#x000A;<span class="ruby-comment"># CREATE INDEX CONCURRENTLY &quot;table_t_id_index&quot; ON &quot;table&quot; (&quot;t_id&quot;)</span></pre>
            
            <p>Similarly, you can drop indexes concurrently as well:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">drop_index</span>(:<span class="ruby-identifier">table</span>, :<span class="ruby-identifier">t_id</span>, :<span class="ruby-identifier">concurrently=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>)&#x000A;<span class="ruby-comment"># DROP INDEX CONCURRENTLY &quot;table_t_id_index&quot;</span></pre>
            
            <h3 id="label-Specific+Conversions+When+Altering+Column+Types">Specific Conversions When Altering Column Types</h3>
            
            <p>When altering a column type, PostgreSQL allows the user to specify how to
            do the conversion via a USING clause, and <a
            href="../../classes/Sequel.html">Sequel</a> supports this using the
            <code>:using</code> option:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">alter_table</span>(:<span class="ruby-identifier">table</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-comment"># Assume unix_time column is stored as an integer, and you want to change it to timestamp</span>&#x000A;  <span class="ruby-identifier">set_column_type</span> :<span class="ruby-identifier">unix_time</span>, <span class="ruby-constant">Time</span>, :<span class="ruby-identifier">using=</span><span class="ruby-operator">&gt;</span>(<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-string">'epoch'</span>, <span class="ruby-constant">Time</span>) <span class="ruby-operator">+</span> <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-string">'1 second'</span>, :<span class="ruby-identifier">interval</span>) * :<span class="ruby-identifier">unix_time</span>)&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-comment"># ALTER TABLE &quot;table&quot; ALTER COLUMN &quot;unix_time&quot; TYPE timestamp</span>&#x000A;<span class="ruby-comment">#   USING (CAST('epoch' AS timestamp) + (CAST('1 second' AS interval) * &quot;unix_time&quot;))</span></pre>
            
            <h3 id="label-Creating+Unlogged+Tables">Creating Unlogged Tables</h3>
            
            <p>PostgreSQL allows users to create unlogged tables, which are faster but not
            crash safe.  <a href="../../classes/Sequel.html">Sequel</a> allows you do
            create an unlogged table by specifying the <code>:unlogged=&gt;true</code>
            option to <code>create_table</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">table</span>, :<span class="ruby-identifier">unlogged=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>){<span class="ruby-constant">Integer</span> :<span class="ruby-identifier">i</span>}&#x000A;<span class="ruby-comment"># CREATE UNLOGGED TABLE &quot;table&quot; (&quot;i&quot; integer)</span></pre>
            
            <h3 id="label-Creating%2FDropping+Schemas%2C+Languages%2C+Functions%2C+and+Triggers">Creating/Dropping Schemas, Languages, Functions, and Triggers</h3>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> has built in support for
            creating and dropping PostgreSQL schemas, procedural languages, functions,
            and triggers:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_schema</span>(:<span class="ruby-identifier">s</span>)&#x000A;<span class="ruby-comment"># CREATE SCHEMA &quot;s&quot;</span>&#x000A;<span class="ruby-constant">DB</span>.<span class="ruby-identifier">drop_schema</span>(:<span class="ruby-identifier">s</span>)&#x000A;<span class="ruby-comment"># DROP SCHEMA &quot;s&quot;</span>&#x000A;&#x000A;<span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_language</span>(:<span class="ruby-identifier">plperl</span>)&#x000A;<span class="ruby-comment"># CREATE LANGUAGE plperl</span>&#x000A;<span class="ruby-constant">DB</span>.<span class="ruby-identifier">drop_language</span>(:<span class="ruby-identifier">plperl</span>)&#x000A;<span class="ruby-comment"># DROP LANGUAGE plperl</span>&#x000A;&#x000A;<span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_function</span>(:<span class="ruby-identifier">set_updated_at</span>, <span class="ruby-string">&quot;  BEGIN&#x000A;    NEW.updated_at := CURRENT_TIMESTAMP;&#x000A;    RETURN NEW;&#x000A;  END;&#x000A;&quot;</span>, :<span class="ruby-identifier">language=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">plpgsql</span>, :<span class="ruby-identifier">returns=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">trigger</span>)&#x000A;<span class="ruby-comment"># CREATE FUNCTION set_updated_at() RETURNS trigger LANGUAGE plpgsql AS '</span>&#x000A;<span class="ruby-comment">#  BEGIN</span>&#x000A;<span class="ruby-comment">#    NEW.updated_at := CURRENT_TIMESTAMP;</span>&#x000A;<span class="ruby-comment">#    RETURN NEW;</span>&#x000A;<span class="ruby-comment">#  END;'</span>&#x000A;<span class="ruby-constant">DB</span>.<span class="ruby-identifier">drop_function</span>(:<span class="ruby-identifier">set_updated_at</span>)&#x000A;<span class="ruby-comment"># DROP FUNCTION set_updated_at()</span>&#x000A;&#x000A;<span class="ruby-constant">DB</span>.<span class="ruby-identifier">create_trigger</span>(:<span class="ruby-identifier">table</span>, :<span class="ruby-identifier">trg_updated_at</span>, :<span class="ruby-identifier">set_updated_at</span>, :<span class="ruby-identifier">events=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">insert</span>, :<span class="ruby-identifier">update</span>], :<span class="ruby-identifier">each_row=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>)&#x000A;<span class="ruby-comment"># CREATE TRIGGER trg_updated_at BEFORE INSERT OR UPDATE ON &quot;table&quot; FOR EACH ROW EXECUTE PROCEDURE set_updated_at()</span>&#x000A;<span class="ruby-constant">DB</span>.<span class="ruby-identifier">drop_trigger</span>(:<span class="ruby-identifier">table</span>, :<span class="ruby-identifier">trg_updated_at</span>)&#x000A;<span class="ruby-comment"># DROP TRIGGER trg_updated_at ON &quot;table&quot;</span></pre>
            
            <h2 id="label-PostgreSQL-specific+DML+Support">PostgreSQL-specific DML Support</h2>
            
            <h3 id="label-Returning+Rows+From+Insert%2C+Update%2C+and+Delete+Statements">Returning Rows From Insert, Update, and Delete Statements</h3>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> supports the ability to
            return rows from insert, update, and delete statements, via
            <code>Dataset#returning</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">returning</span>.<span class="ruby-identifier">insert</span>&#x000A;<span class="ruby-comment"># INSERT INTO &quot;table&quot; DEFAULT VALUES RETURNING *</span>&#x000A;&#x000A;<span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">returning</span>(:<span class="ruby-identifier">id</span>).<span class="ruby-identifier">delete</span>&#x000A;<span class="ruby-comment"># DELETE FROM &quot;table&quot; RETURNING &quot;id&quot;</span>&#x000A;&#x000A;<span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">returning</span>(:<span class="ruby-identifier">id</span>, <span class="ruby-constant">Sequel</span>.*(:<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">id</span>).<span class="ruby-identifier">as</span>(:<span class="ruby-identifier">idsq</span>)).<span class="ruby-identifier">update</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">2</span>)&#x000A;<span class="ruby-comment"># UPDATE &quot;table&quot; SET &quot;id&quot; = 2 RETURNING &quot;id&quot;, (&quot;id&quot; * &quot;id&quot;) AS &quot;idsq&quot;</span></pre>
            
            <p>When returning is used, instead of returning the number of rows affected
            (for updated/delete) or the serial primary key value (for insert), it will
            return an array of hashes with the returned results.</p>
            
            <h3 id="label-Distinct+On+Specific+Columns">Distinct On Specific Columns</h3>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> allows passing columns to
            <code>Dataset#distinct</code>, which will make the dataset return rows that
            are distinct on just those columns:</p>
            
            <pre>DB[:table].distinct(:id).all&#x000A;# SELECT DISTINCT ON (&quot;id&quot;) * FROM &quot;table&quot;</pre>
            
            <h3 id="label-Using+a+Cursor+to+Process+Large+Datasets+postgres+only">Using a Cursor to Process Large Datasets <code>postgres only</code></h3>
            
            <p>The postgres adapter offers a <code>Dataset#use_cursor</code> method to
            process large result sets without keeping all rows in memory:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">use_cursor</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">row</span><span class="ruby-operator">|</span> }&#x000A;<span class="ruby-comment"># BEGIN;</span>&#x000A;<span class="ruby-comment"># DECLARE sequel_cursor NO SCROLL CURSOR WITHOUT HOLD FOR SELECT * FROM &quot;table&quot;;</span>&#x000A;<span class="ruby-comment"># FETCH FORWARD 1000 FROM sequel_cursor</span>&#x000A;<span class="ruby-comment"># FETCH FORWARD 1000 FROM sequel_cursor</span>&#x000A;<span class="ruby-comment"># ...</span>&#x000A;<span class="ruby-comment"># FETCH FORWARD 1000 FROM sequel_cursor</span>&#x000A;<span class="ruby-comment"># CLOSE sequel_cursor</span>&#x000A;<span class="ruby-comment"># COMMIT</span></pre>
            
            <h3 id="label-Truncate+Modifiers">Truncate Modifiers</h3>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> supports PostgreSQL-specific
            truncate options:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">truncate</span>(:<span class="ruby-identifier">cascade</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>, :<span class="ruby-identifier">only=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>, :<span class="ruby-identifier">restart=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>)&#x000A;<span class="ruby-comment"># TRUNCATE TABLE ONLY &quot;table&quot; RESTART IDENTITY CASCADE</span></pre>
            
            <h3 id="label-COPY+Support+postgres%2Fpg+and+jdbc%2Fpostgres+only+">COPY Support <code>postgres/pg and jdbc/postgres only</code> </h3>
            
            <p>PostgreSQL’s COPY feature is pretty much the fastest way to get data in or
            out of the database. <a href="../../classes/Sequel.html">Sequel</a>
            supports getting data out of the database via
            <code>Database#copy_table</code>, either for a specific table or for an
            arbitrary dataset:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">copy_table</span>(:<span class="ruby-identifier">table</span>, :<span class="ruby-identifier">format=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">csv</span>)&#x000A;<span class="ruby-comment"># COPY &quot;table&quot; TO STDOUT (FORMAT csv)</span>&#x000A;<span class="ruby-constant">DB</span>.<span class="ruby-identifier">copy_table</span>(<span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>], :<span class="ruby-identifier">format=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">csv</span>)&#x000A;<span class="ruby-comment"># COPY (SELECT * FROM &quot;table&quot;) TO STDOUT (FORMAT csv)</span></pre>
            
            <p>It supports putting data into the database via
            <code>Database#copy_into</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">copy_into</span>(:<span class="ruby-identifier">table</span>, :<span class="ruby-identifier">format=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">csv</span>, :<span class="ruby-identifier">columns=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">column1</span>, :<span class="ruby-identifier">column2</span>], :<span class="ruby-identifier">data=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;1,2\n2,3\n&quot;</span>)&#x000A;<span class="ruby-comment"># COPY &quot;table&quot;(&quot;column1&quot;, &quot;column2&quot;) FROM STDIN (FORMAT csv)</span></pre>
            
            <h3 id="label-Anonymous+Function+Execution">Anonymous Function Execution</h3>
            
            <p>You can execute anonymous functions using a database procedural language
            via <code>Database#do</code> (the plpgsql language is the default):</p>
            
            <pre>DB.do &lt;&lt;-SQL&#x000A;  DECLARE r record;&#x000A;  BEGIN&#x000A;   FOR r IN SELECT table_schema, table_name FROM information_schema.tables&#x000A;     WHERE table_type = 'VIEW' AND table_schema = 'public'&#x000A;   LOOP&#x000A;     EXECUTE 'GRANT ALL ON ' || quote_ident(r.table_schema) || '.' || quote_ident(r.table_name) || ' TO webuser';&#x000A;   END LOOP;&#x000A;  END;&#x000A;SQL</pre>
            
            <h3 id="label-Listening+On+and+Notifying+Channels">Listening On and Notifying Channels</h3>
            
            <p>You can use <code>Database#notify</code> to send notification to channels:</p>
            
            <pre>DB.notify(:channel)&#x000A;# NOTIFY &quot;channel&quot;</pre>
            
            <p><code>postgres/pg only</code> You can listen on channels via
            <code>Database#listen</code>.  Note that this blocks until the listening
            thread is notified:</p>
            
            <pre>DB.listen(:channel)&#x000A;# LISTEN &quot;channel&quot;&#x000A;# after notification received:&#x000A;# UNLISTEN *</pre>
            
            <p>Note that <code>listen</code> by default only listens for a single
            notification.  If you want to loop and process notifications:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">listen</span>(:<span class="ruby-identifier">channel</span>, :<span class="ruby-identifier">loop=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>){<span class="ruby-operator">|</span><span class="ruby-identifier">channel</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">channel</span>}</pre>
            
            <h3 id="label-Locking+Tables">Locking Tables</h3>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> makes it easy to lock
            tables, though it is generally better to let the database handle locking:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">lock</span>(<span class="ruby-string">'EXCLUSIVE'</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">insert</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">max</span>(:<span class="ruby-identifier">id</span>)<span class="ruby-operator">+</span><span class="ruby-value">1</span>)&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-comment"># BEGIN;</span>&#x000A;<span class="ruby-comment"># LOCK TABLE &quot;table&quot; IN EXCLUSIVE MODE;</span>&#x000A;<span class="ruby-comment"># SELECT max(&quot;id&quot;) FROM &quot;table&quot; LIMIT 1;</span>&#x000A;<span class="ruby-comment"># INSERT INTO &quot;table&quot; (&quot;id&quot;) VALUES (2) RETURNING NULL;</span>&#x000A;<span class="ruby-comment"># COMMIT;</span></pre>
            
            <h2 id="label-sequel_pg+%28postgres%2Fpg+only%29">sequel_pg (<code>postgres/pg only</code>)</h2>
            
            <p>When the postgres adapter is used with the pg driver, <a
            href="../../classes/Sequel.html">Sequel</a> automatically checks for
            sequel_pg, and loads it if it is available.  sequel_pg is a C extension
            that optimizes the fetching of rows, generally resulting in a 2-6x speedup.
            It is highly recommended to install sequel_pg if you are using the postgres
            adapter with pg.</p>
            
            <p>sequel_pg has additional optimizations when using the Dataset
            <code>map</code>, <code>to_hash</code>, <code>to_hash_groups</code>,
            <code>select_hash</code>, <code>select_hash_groups</code>,
            <code>select_map</code>, and <code>select_order_map</code> methods, which
            avoids creating intermediate hashes and can add further speedups.</p>
            
            <p>In addition to optimization, sequel_pg also adds streaming support if used
            on PostgreSQL 9.2. Streaming support is similar to using a cursor, but it
            is faster and more transparent.</p>
            
            <p>You can enable the streaming support:</p>
            
            <pre>DB.extension(:pg_streaming)</pre>
            
            <p>Then you can stream individual datasets:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">table</span>].<span class="ruby-identifier">stream</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">row</span><span class="ruby-operator">|</span> }</pre>
            
            <p>Or stream all datasets by default:</p>
            
            <pre>DB.stream_all_queries = true</pre>
          </div>
          <div id='context'>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
