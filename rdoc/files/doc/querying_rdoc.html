<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>querying.rdoc</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='file' id='wrapper'>
      <div class='header'>
        <h1 class='name'>querying.rdoc</h1>
        <div class='paths'>
          doc/querying.rdoc
        </div>
        <div class='last-update'>
          Last Update:
          <span class='datetime'>2013-11-08 08:08:17 -0500</span>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <h1 id="label-Querying+in+Sequel">Querying in <a href="../../classes/Sequel.html">Sequel</a></h1>
            
            <p>This guide is based on <a
            href="http://guides.rubyonrails.org/active_record_querying.html">guides.rubyonrails.org/active_record_querying.html</a></p>
            
            <h2 id="label-Purpose+of+this+Guide">Purpose of this Guide</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> is a simple to use, very
            flexible, and powerful database library that supports a wide variety of
            different querying methods.  This guide aims to be a gentle introduction to
            Sequel's querying support.</p>
            
            <p>While you can easily use raw SQL with <a
            href="../../classes/Sequel.html">Sequel</a>, a large part of the advantage
            you get from using <a href="../../classes/Sequel.html">Sequel</a> is
            Sequel’s ability to abstract SQL from you and give you a much nicer
            interface. <a href="../../classes/Sequel.html">Sequel</a> also ships with a
            <a href="core_extensions_rdoc.html">core_extensions extension</a> which
            better integrates Sequel’s DSL into the ruby language.</p>
            
            <h2 id="label-Retrieving+Objects">Retrieving Objects</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> provides a few separate
            methods for retrieving objects from the database.  The underlying method is
            <a
            href="../../classes/Sequel/Dataset.html#method-i-each">Sequel::Dataset#each</a>,
            which yields each row as the <a
            href="../../classes/Sequel/Database.html">Sequel::Database</a> provides it.
            However, while Dataset#each can and often is used directly, in many cases
            there is a more convenient retrieval method you can use.</p>
            
            <h3 id="label-Sequel%3A%3ADataset"><a href="../../classes/Sequel/Dataset.html">Sequel::Dataset</a></h3>
            
            <p>If you are new to <a href="../../classes/Sequel.html">Sequel</a> and aren’t
            familiar with <a href="../../classes/Sequel.html">Sequel</a>, you should
            probably read the <a href="dataset_basics_rdoc.html">“Dataset Basics”
            guide</a> then come back here.</p>
            
            <h3 id="label-Retrieving+a+Single+Object">Retrieving a Single Object</h3>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> offers quite a few ways to
            to retrieve a single object.</p>
            
            <h4 id="label-Using+a+Primary+Key+%5BSequel%3A%3AModel%5D">Using a Primary Key [Sequel::Model]</h4>
            
            <p>The <code>Sequel::Model.[]</code> is the easiest method to use to find a
            model instance by its primary key value:</p>
            
            <pre class="ruby"><span class="ruby-comment"># Find artist with primary key (id) 1</span>&#x000A;<span class="ruby-identifier">artist</span> = <span class="ruby-constant">Artist</span>[<span class="ruby-value">1</span>]&#x000A;<span class="ruby-comment"># SELECT * FROM artists WHERE id = 1</span>&#x000A;=<span class="ruby-operator">&gt;</span> <span class="ruby-comment">#&lt;Artist @values={:name=&gt;&quot;YJM&quot;, :id=&gt;1}&gt;</span></pre>
            
            <p>If there is no record with the given primary key, nil will be returned. If
            you want to raise an exception if no record is found, you can use
            <code>Sequel::Model.with_pk!</code>:</p>
            
            <pre>artist = Artist.with_pk!(1)</pre>
            
            <h4 id="label-Using+first">Using <code>first</code></h4>
            
            <p>If you just want the first record in the dataset,
            <code>Sequel::Dataset#first</code> is probably the most obvious method to
            use:</p>
            
            <pre class="ruby"><span class="ruby-identifier">artist</span> = <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">first</span>&#x000A;<span class="ruby-comment"># SELECT * FROM artists LIMIT 1</span>&#x000A;=<span class="ruby-operator">&gt;</span> <span class="ruby-comment">#&lt;Artist @values={:name=&gt;&quot;YJM&quot;, :id=&gt;1}&gt;</span></pre>
            
            <p>Any options you pass to <code>first</code> will be used as a filter:</p>
            
            <pre class="ruby"><span class="ruby-identifier">artist</span> = <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">first</span>(:<span class="ruby-identifier">name</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'YJM'</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM artists WHERE (name = 'YJM') LIMIT 1</span>&#x000A;=<span class="ruby-operator">&gt;</span> <span class="ruby-comment">#&lt;Artist @values={:name=&gt;&quot;YJM&quot;, :id=&gt;1}&gt;</span>&#x000A;&#x000A;<span class="ruby-identifier">artist</span> = <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">first</span>(<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">like</span>(:<span class="ruby-identifier">name</span>, <span class="ruby-string">'Y%'</span>))&#x000A;<span class="ruby-comment"># SELECT * FROM artists WHERE (name LIKE 'Y%') LIMIT 1</span>&#x000A;=<span class="ruby-operator">&gt;</span> <span class="ruby-comment">#&lt;Artist @values={:name=&gt;&quot;YJM&quot;, :id=&gt;1}&gt;</span></pre>
            
            <p>If there is no matching row, <code>first</code> will return nil.  If you
            want to raise an exception instead, use <code>first!</code>.</p>
            
            <p><code>Sequel::Dataset#[]</code> is basically an alias for
            <code>first</code>, except it requires an argument:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">artists</span>][:<span class="ruby-identifier">name</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'YJM'</span>]&#x000A;<span class="ruby-comment"># SELECT * FROM artists WHERE (name = 'YJM') LIMIT 1</span>&#x000A;=<span class="ruby-operator">&gt;</span> {:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;YJM&quot;</span>, :<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>}</pre>
            
            <p>Note that while Model.[] allows you to pass a primary key directly,
            Dataset#[] does not (unless it is a model dataset).</p>
            
            <h4 id="label-Using+last">Using <code>last</code></h4>
            
            <p>If you want the last record in the dataset,
            <code>Sequel::Dataset#last</code> is an obvious method to use.  Note that
            last requires that the dataset be ordered, unless the dataset is a model
            dataset.  For a model dataset, <code>last</code> will do a reverse order by
            the primary key field:</p>
            
            <pre class="ruby"><span class="ruby-identifier">artist</span> = <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">last</span>&#x000A;<span class="ruby-comment"># SELECT * FROM artists ORDER BY id DESC LIMIT 1</span>&#x000A;=<span class="ruby-operator">&gt;</span> <span class="ruby-comment">#&lt;Artist @values={:name=&gt;&quot;YJM&quot;, :id=&gt;1}&gt;</span></pre>
            
            <p>Note that what <code>last</code> does is reverse the order of the dataset
            and then call <code>first</code>.  This is why <code>last</code> raises a
            <a href="../../classes/Sequel/Error.html">Sequel::Error</a> if there is no
            order on a plain dataset, because otherwise it would provide the same
            record as <code>first</code>, and most users would find that confusing.</p>
            
            <p>Note that <code>last</code> is not necessarily going to give you the last
            record in the dataset unless you give the dataset an unambiguous order.</p>
            
            <h4 id="label-Retrieving+a+Single+Column+Value">Retrieving a Single Column Value</h4>
            
            <p>Sometimes, instead of wanting an entire row, you only want the value of a
            specific column.  For this <code>Sequel::Dataset#get</code> is the method
            you want:</p>
            
            <pre class="ruby"><span class="ruby-identifier">artist_name</span> = <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">get</span>(:<span class="ruby-identifier">name</span>)&#x000A;<span class="ruby-comment"># SELECT name FROM artists LIMIT 1</span>&#x000A;=<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;YJM&quot;</span></pre>
            
            <h3 id="label-Retrieving+Multiple+Objects">Retrieving Multiple Objects</h3>
            
            <h4 id="label-As+an+Array+of+Hashes+or+Model+Objects">As an <a href="../../classes/Array.html">Array</a> of Hashes or Model Objects</h4>
            
            <p>In many cases, you want an array of all of the rows associated with the
            dataset, in which case <code>Sequel::Dataset#all</code> is the method you
            want to use:</p>
            
            <pre class="ruby"><span class="ruby-identifier">artists</span> = <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">all</span>&#x000A;<span class="ruby-comment"># SELECT * FROM artists</span>&#x000A;=<span class="ruby-operator">&gt;</span> [<span class="ruby-comment">#&lt;Artist @values={:name=&gt;&quot;YJM&quot;, :id=&gt;1}&gt;,</span>&#x000A;    <span class="ruby-comment">#&lt;Artist @values={:name=&gt;&quot;AS&quot;, :id=&gt;2}&gt;]</span></pre>
            
            <h4 id="label-Using+an+Enumerable+Interface">Using an Enumerable Interface</h4>
            
            <p><code>Sequel::Dataset</code> uses an Enumerable Interface, so it provides a
            method named each that yields hashes or model objects as they are retrieved
            from the database:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">name</span>}&#x000A;<span class="ruby-comment"># SELECT * FROM artists</span>&#x000A;<span class="ruby-string">&quot;YJM&quot;</span>&#x000A;<span class="ruby-string">&quot;AS&quot;</span></pre>
            
            <p>This means that all of the methods in the Enumerable module are available,
            such as <code>map</code>:</p>
            
            <pre class="ruby"><span class="ruby-identifier">artist_names</span> = <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">name</span>}&#x000A;<span class="ruby-comment"># SELECT * FROM artists</span>&#x000A;=<span class="ruby-operator">&gt;</span> [<span class="ruby-string">&quot;YJM&quot;</span>, <span class="ruby-string">&quot;AS&quot;</span>]</pre>
            
            <h4 id="label-As+an+Array+of+Column+Values">As an <a href="../../classes/Array.html">Array</a> of Column Values</h4>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> also has an extended
            <code>map</code> method that takes an argument.  If you provide an argument
            to <code>map</code>, it will return an array of values for the given
            column.  So the previous example can be handled more easily with:</p>
            
            <pre class="ruby"><span class="ruby-identifier">artist_names</span> = <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">map</span>(:<span class="ruby-identifier">name</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM artists</span>&#x000A;=<span class="ruby-operator">&gt;</span> [<span class="ruby-string">&quot;YJM&quot;</span>, <span class="ruby-string">&quot;AS&quot;</span>]</pre>
            
            <p>One difference between these two ways of returning an array of values is
            that providing <code>map</code> with an argument is really doing:</p>
            
            <pre class="ruby"><span class="ruby-identifier">artist_names</span> = <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>[:<span class="ruby-identifier">name</span>]} <span class="ruby-comment"># not x.name</span></pre>
            
            <p>Note that regardless of whether you provide <code>map</code> with an
            argument, it does not modify the columns selected.  If you only want to
            select a single column and return an array of the columns values, you can
            use <code>select_map</code>:</p>
            
            <pre class="ruby"><span class="ruby-identifier">artist_names</span> = <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">select_map</span>(:<span class="ruby-identifier">name</span>)&#x000A;<span class="ruby-comment"># SELECT name FROM artists</span>&#x000A;=<span class="ruby-operator">&gt;</span> [<span class="ruby-string">&quot;YJM&quot;</span>, <span class="ruby-string">&quot;AS&quot;</span>]</pre>
            
            <p>It’s also common to want to order such a map, so <a
            href="../../classes/Sequel.html">Sequel</a> provides a
            <code>select_order_map</code> method as well:</p>
            
            <pre class="ruby"><span class="ruby-identifier">artist_names</span> = <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">select_order_map</span>(:<span class="ruby-identifier">name</span>)&#x000A;<span class="ruby-comment"># SELECT name FROM artists ORDER BY name</span>&#x000A;=<span class="ruby-operator">&gt;</span> [<span class="ruby-string">&quot;AS&quot;</span>, <span class="ruby-string">&quot;YJM&quot;</span>]</pre>
            
            <p>In all of these cases, you can provide an array of column symbols and an
            array of arrays of values will be returned:</p>
            
            <pre class="ruby"><span class="ruby-identifier">artist_names</span> = <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">select_map</span>([:<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">name</span>])&#x000A;<span class="ruby-comment"># SELECT id, name FROM artists</span>&#x000A;=<span class="ruby-operator">&gt;</span> [[<span class="ruby-value">1</span>, <span class="ruby-string">&quot;YJM&quot;</span>], [<span class="ruby-value">2</span>, <span class="ruby-string">&quot;AS&quot;</span>]]</pre>
            
            <h4 id="label-As+a+Hash">As a <a href="../../classes/Hash.html">Hash</a></h4>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> makes it easy to take an SQL
            query and return it as a ruby hash, using the <code>to_hash</code> method:</p>
            
            <pre class="ruby"><span class="ruby-identifier">artist_names</span> = <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">to_hash</span>(:<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">name</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM artists</span>&#x000A;=<span class="ruby-operator">&gt;</span> {<span class="ruby-value">1</span>=<span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;YJM&quot;</span>, <span class="ruby-value">2</span>=<span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;AS&quot;</span>}</pre>
            
            <p>As you can see, the <code>to_hash</code> method uses the first symbol as
            the key and the second symbol as the value.  So if you swap the two
            arguments the hash will have its keys and values transposed:</p>
            
            <pre class="ruby"><span class="ruby-identifier">artist_names</span> = <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">to_hash</span>(:<span class="ruby-identifier">name</span>, :<span class="ruby-identifier">id</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM artists</span>&#x000A;=<span class="ruby-operator">&gt;</span> {<span class="ruby-string">&quot;YJM&quot;</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>, <span class="ruby-string">&quot;AS&quot;</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">2</span>}</pre>
            
            <p>Now what if you have multiple values for the same key?  By default,
            <code>to_hash</code> will just have the last matching value.  If you care
            about all matching values, use <code>to_hash_groups</code>, which makes the
            values of the array an array of matching values, in the order they were
            received:</p>
            
            <pre class="ruby"><span class="ruby-identifier">artist_names</span> = <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">to_hash_groups</span>(:<span class="ruby-identifier">name</span>, :<span class="ruby-identifier">id</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM artists</span>&#x000A;=<span class="ruby-operator">&gt;</span> {<span class="ruby-string">&quot;YJM&quot;</span>=<span class="ruby-operator">&gt;</span>[<span class="ruby-value">1</span>, <span class="ruby-value">10</span>, <span class="ruby-operator">...</span>], <span class="ruby-string">&quot;AS&quot;</span>=<span class="ruby-operator">&gt;</span>[<span class="ruby-value">2</span>, <span class="ruby-value">20</span>, <span class="ruby-operator">...</span>]}</pre>
            
            <p>If you only provide one argument to <code>to_hash</code>, it uses the
            entire hash or model object as the value:</p>
            
            <pre class="ruby"><span class="ruby-identifier">artist_names</span> = <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">artists</span>].<span class="ruby-identifier">to_hash</span>(:<span class="ruby-identifier">name</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM artists</span>&#x000A;=<span class="ruby-operator">&gt;</span> {<span class="ruby-string">&quot;YJM&quot;</span>=<span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>, :<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;YJM&quot;</span>}, <span class="ruby-string">&quot;AS&quot;</span>=<span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">2</span>, :<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;AS&quot;</span>}}</pre>
            
            <p>and <code>to_hash_groups</code> works similarly:</p>
            
            <pre class="ruby"><span class="ruby-identifier">artist_names</span> = <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">artists</span>].<span class="ruby-identifier">to_hash_groups</span>(:<span class="ruby-identifier">name</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM artists</span>&#x000A;=<span class="ruby-operator">&gt;</span> {<span class="ruby-string">&quot;YJM&quot;</span>=<span class="ruby-operator">&gt;</span>[{:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>, :<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;YJM&quot;</span>}, {:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">10</span>, :<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;YJM&quot;</span>}], <span class="ruby-operator">...</span>}</pre>
            
            <p>Model datasets have a <code>to_hash</code> method that can be called
            without any arguments, in which case it will use the primary key as the key
            and the model object as the value.  This can be used to easily create an
            identity map:</p>
            
            <pre class="ruby"><span class="ruby-identifier">artist_names</span> = <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">to_hash</span>&#x000A;<span class="ruby-comment"># SELECT * FROM artists</span>&#x000A;=<span class="ruby-operator">&gt;</span> {<span class="ruby-value">1</span>=<span class="ruby-operator">&gt;</span><span class="ruby-comment">#&lt;Artist @values={:id=&gt;1, :name=&gt;&quot;YGM&quot;}&gt;,</span>&#x000A;    <span class="ruby-value">2</span>=<span class="ruby-operator">&gt;</span><span class="ruby-comment">#&lt;Artist @values={:id=&gt;2, :name=&gt;&quot;AS&quot;}&gt;}</span></pre>
            
            <p>There is no equivalent handling to <code>to_hash_groups</code>, since there
            would only be one matching record, as the primary key must be unique.</p>
            
            <p>Note that <code>to_hash</code> never modifies the columns selected. 
            However, just like <a href="../../classes/Sequel.html">Sequel</a> has a
            <code>select_map</code> method to modify the columns selected and return an
            array, <a href="../../classes/Sequel.html">Sequel</a> also has a
            <code>select_hash</code> method to modify the columns selected and return a
            hash:</p>
            
            <pre class="ruby"><span class="ruby-identifier">artist_names</span> = <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">select_hash</span>(:<span class="ruby-identifier">name</span>, :<span class="ruby-identifier">id</span>)&#x000A;<span class="ruby-comment"># SELECT name, id FROM artists</span>&#x000A;=<span class="ruby-operator">&gt;</span> {<span class="ruby-string">&quot;YJM&quot;</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>, <span class="ruby-string">&quot;AS&quot;</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">2</span>}</pre>
            
            <p>Likewise, <code>select_hash_groups</code> also exists:</p>
            
            <pre class="ruby"><span class="ruby-identifier">artist_names</span> = <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">select_hash_groups</span>(:<span class="ruby-identifier">name</span>, :<span class="ruby-identifier">id</span>)&#x000A;<span class="ruby-comment"># SELECT name, id FROM artists</span>&#x000A;=<span class="ruby-operator">&gt;</span> {<span class="ruby-string">&quot;YJM&quot;</span>=<span class="ruby-operator">&gt;</span>[<span class="ruby-value">1</span>, <span class="ruby-value">10</span>, <span class="ruby-operator">...</span>], <span class="ruby-string">&quot;AS&quot;</span>=<span class="ruby-operator">&gt;</span>[<span class="ruby-value">2</span>, <span class="ruby-value">20</span>, <span class="ruby-operator">...</span>]}</pre>
            
            <h2 id="label-Modifying+datasets+">Modifying datasets </h2>
            
            <p>Note that the retrieval methods discussed above just return the row(s)
            included in the existing dataset.  In most cases, you aren’t interested in
            every row in a table, but in a subset of the rows, based on some criteria. 
            In <a href="../../classes/Sequel.html">Sequel</a>, filtering the dataset is
            generally done separately than retrieving the records.</p>
            
            <p>There are really two types of dataset methods that you will be using:</p>
            <ol><li>
            <p>Methods that return row(s), discussed above</p>
            </li><li>
            <p>Methods that return modified datasets, discussed below</p>
            </li></ol>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> uses a method chaining,
            functional style API to modify datasets.  Let's start with a simple
            example.</p>
            
            <p>This is a basic dataset that includes all records in the table
            <code>artists</code>:</p>
            
            <pre>ds1 = DB[:artists]&#x000A;# SELECT * FROM artists</pre>
            
            <p>Let’s say we are only interested in the artists whose names start with “A”:</p>
            
            <pre>ds2 = ds1.where(Sequel.like(:name, 'A%'))&#x000A;# SELECT * FROM artists WHERE name LIKE 'A%'</pre>
            
            <p>Here we see that <code>where</code> returns a dataset that adds a
            <code>WHERE</code> clause to the query.  It’s important to note that
            <code>where</code> does not modify the receiver:</p>
            
            <pre>ds1&#x000A;# SELECT * FROM artists&#x000A;ds2&#x000A;# SELECT * FROM artists WHERE name LIKE 'A%'</pre>
            
            <p>In <a href="../../classes/Sequel.html">Sequel</a>, most dataset methods
            that you will be using will not modify the dataset itself, so you can
            freely use the dataset in multiple places without worrying that its usage
            in one place will affect its usage in another place.  This is what is meant
            by a functional style API.</p>
            
            <p>Let’s say we only want to select the id and name columns, and that we want
            to order by name:</p>
            
            <pre>ds3 = ds.order(:name).select(:id, :name)&#x000A;# SELECT id, name FROM artists WHERE name LIKE 'A%' ORDER BY name</pre>
            
            <p>Note how you don’t need to assign the returned value of order to a
            variable, and then call select on that.  Because order just returns a
            dataset, you can call select directly on the returned dataset.  This is
            what is meant by a method chaining API.</p>
            
            <p>Also note how you can call methods that modify different clauses in any
            order. In this case, the WHERE clause was added first, then the ORDER
            clause, then the SELECT clause was modified.  This makes for a flexible
            API, where you can modify any part of the query at any time.</p>
            
            <h2 id="label-Filters">Filters</h2>
            
            <p>Filtering is probably the most common dataset modifying action done in <a
            href="../../classes/Sequel.html">Sequel</a>. Both the <code>where</code>
            and <code>filter</code> methods filter the dataset by modifying the
            dataset’s WHERE clause.  Both accept a wide variety of input formats,
            discussed below.</p>
            
            <h3 id="label-Hashes">Hashes</h3>
            
            <p>The most common format for providing filters is via a hash.  In general, <a
            href="../../classes/Sequel.html">Sequel</a> treats conditions specified
            with a hash as equality or inclusion.  What type of condition is used
            depends on the values in the hash.</p>
            
            <p>Unless <a href="../../classes/Sequel.html">Sequel</a> has special support
            for the value’s class, it uses a simple equality statement:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM artists WHERE id = 1</span>&#x000A;&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'YJM'</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM artists WHERE name = 'YJM'</span></pre>
            
            <p>For arrays, <a href="../../classes/Sequel.html">Sequel</a> uses the IN
            operator.</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>])&#x000A;<span class="ruby-comment"># SELECT * FROM artists WHERE id IN (1, 2)</span></pre>
            
            <p>For datasets, <a href="../../classes/Sequel.html">Sequel</a> uses the IN
            operator with a subselect:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">Album</span>.<span class="ruby-identifier">select</span>(:<span class="ruby-identifier">artist_id</span>))&#x000A;<span class="ruby-comment"># SELECT * FROM artists WHERE id IN (</span>&#x000A;<span class="ruby-comment">#   SELECT artist_id FROM albums)</span></pre>
            
            <p>For boolean values such as nil, true, and false, <a
            href="../../classes/Sequel.html">Sequel</a> uses the IS operator:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">nil</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM artists WHERE id IS NULL</span></pre>
            
            <p>For ranges, <a href="../../classes/Sequel.html">Sequel</a> uses a pair of
            inequality statements:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">5</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM artists WHERE id &gt;= 1 AND id &lt;= 5</span></pre>
            
            <p>Finally, for regexps, <a href="../../classes/Sequel.html">Sequel</a> uses
            an SQL regular expression.  Note that this is probably only supported on
            PostgreSQL and MySQL.</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-regexp">/JM$/</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM artists WHERE name ~ 'JM$'</span></pre>
            
            <p>If there are multiple arguments in the hash, the filters are ANDed
            together:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>, :<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-regexp">/JM$/</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM artists WHERE id = 1 AND name ~ 'JM$'</span></pre>
            
            <p>This works the same as if you used two separate <code>where</code> calls:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>).<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-regexp">/JM$/</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM artists WHERE id = 1 AND name ~ 'JM$'</span></pre>
            
            <h3 id="label-Array+of+Two+Element+Arrays"><a href="../../classes/Array.html">Array</a> of Two Element Arrays</h3>
            
            <p>If you use an array of two element arrays, it is treated as a hash.  The
            only advantage to using an array of two element arrays is that it allows
            you to duplicate keys, so you can do:</p>
            
            <pre>Artist.where([[:name, /JM$/], [:name, /^YJ/]])&#x000A;# SELECT * FROM artists WHERE name ~ 'JM$' AND name ~ '^YJ'</pre>
            
            <h3 id="label-Virtual+Row+Blocks">Virtual Row Blocks</h3>
            
            <p>If a block is passed to a filter, it is treated as a virtual row block:</p>
            
            <pre>Artist.where{id &gt; 5}&#x000A;# SELECT * FROM artists WHERE id &gt; 5</pre>
            
            <p>You can learn more about virtual row blocks in the <a
            href="virtual_rows_rdoc.html">“Virtual Rows” guide</a></p>
            
            <p>You can provide both regular arguments and a block, in which case the
            results will be ANDed together:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'A'</span><span class="ruby-operator">...</span><span class="ruby-string">'M'</span>){<span class="ruby-identifier">id</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">5</span>}&#x000A;<span class="ruby-comment"># SELECT * FROM artists WHERE name &gt;= 'A' AND name &lt; 'M' AND id &gt; 5</span></pre>
            
            <h3 id="label-Symbols">Symbols</h3>
            
            <p>If you have a boolean column in the database, and you want only true
            values, you can just provide the column symbol to filter:</p>
            
            <pre>Artist.where(:retired)&#x000A;# SELECT * FROM artists WHERE retired</pre>
            
            <h3 id="label-SQL%3A%3AExpression">SQL::Expression</h3>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> has a DSL that allows easily
            creating SQL expressions.  These SQL expressions are instances of
            subclasses of <a
            href="../../classes/Sequel/SQL/Expression.html">Sequel::SQL::Expression</a>.
            You've already seen an example earlier:</p>
            
            <pre>Artist.where(Sequel.like(:name, 'Y%'))&#x000A;# SELECT * FROM artists WHERE name LIKE 'Y%'</pre>
            
            <p>In this case Sequel.like returns a <a
            href="../../classes/Sequel/SQL/BooleanExpression.html">Sequel::SQL::BooleanExpression</a>
            object, which is used directly in the filter.</p>
            
            <p>You can use the DSL to create arbitrarily complex expressions. 
            SQL::Expression objects can be created via singleton methods on the <a
            href="../../classes/Sequel.html">Sequel</a> module.  The most common method
            is Sequel.expr, which takes any object and wraps it in a SQL::Expression
            object.  In most cases, the SQL::Expression returned supports the &amp;
            operator for <code>AND</code>, the | operator for <code>OR</code>, and the
            ~ operator for inversion:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">like</span>(:<span class="ruby-identifier">name</span>, <span class="ruby-string">'Y%'</span>) &amp; (<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">expr</span>(:<span class="ruby-identifier">b=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>) <span class="ruby-operator">|</span> <span class="ruby-constant">Sequel</span>.<span class="ruby-operator">~</span>(:<span class="ruby-identifier">c=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">3</span>)))&#x000A;<span class="ruby-comment"># SELECT * FROM artists WHERE name LIKE 'Y%' AND (b = 1 OR c != 3)</span></pre>
            
            <p>You can combine these expression operators with the virtual row support:</p>
            
            <pre>Artist.where{(a &gt; 1) &amp; ~((b(c) &lt; 1) | d)}&#x000A;# SELECT * FROM artists WHERE a &gt; 1 AND b(c) &gt;= 1 AND NOT d</pre>
            
            <p>Note the use of parentheses when using the &amp; and | operators, as they
            have lower precedence than other operators.  The following will not work:</p>
            
            <pre>Artist.where{a &gt; 1 &amp; ~(b(c) &lt; 1 | d)}&#x000A;# Raises a TypeError, as it calls Integer#| with a Sequel::SQL::Identifier</pre>
            
            <h3 id="label-Strings+with+Placeholders">Strings with Placeholders</h3>
            
            <p>Assuming you want to get your hands dirty and write some SQL, <a
            href="../../classes/Sequel.html">Sequel</a> allows you to use strings using
            placeholders for the values:</p>
            
            <pre>Artist.where(&quot;name LIKE ?&quot;, 'Y%')&#x000A;# SELECT * FROM artists WHERE name LIKE 'Y%'</pre>
            
            <p>This is the most common type of placeholder, where each question mark is
            substituted with the next argument:</p>
            
            <pre>Artist.where(&quot;name LIKE ? AND id = ?&quot;, 'Y%', 5)&#x000A;# SELECT * FROM artists WHERE name LIKE 'Y%' AND id = 5</pre>
            
            <p>You can also use named placeholders with a hash, where the named
            placeholders use colons before the placeholder names:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(<span class="ruby-string">&quot;name LIKE :name AND id = :id&quot;</span>, :<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'Y%'</span>, :<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">5</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM artists WHERE name LIKE 'Y%' AND id = 5</span></pre>
            
            <p>You don’t have to provide any placeholders if you don’t want to:</p>
            
            <pre>Artist.where(&quot;id = 2&quot;)&#x000A;# SELECT * FROM artists WHERE id = 2</pre>
            
            <p>However, if you are using any untrusted input, you should definitely be
            using placeholders. In general, unless you are hardcoding values in the
            strings, you should use placeholders. You should never pass a string that
            has been built using interpolation, unless you are sure of what you are
            doing.</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(<span class="ruby-node">&quot;id = #{params[:id]}&quot;</span>) <span class="ruby-comment"># Don't do this!</span>&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(<span class="ruby-string">&quot;id = ?&quot;</span>, <span class="ruby-identifier">params</span>[:<span class="ruby-identifier">id</span>]) <span class="ruby-comment"># Do this instead</span>&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">params</span>[:<span class="ruby-identifier">id</span>].<span class="ruby-identifier">to_i</span>) <span class="ruby-comment"># Even better</span></pre>
            
            <h3 id="label-Inverting">Inverting</h3>
            
            <p>You may be wondering how to specify a not equals condition in <a
            href="../../classes/Sequel.html">Sequel</a>, or the NOT IN operator.  <a
            href="../../classes/Sequel.html">Sequel</a> has generic support for
            inverting conditions, so to write a not equals condition, you write an
            equals condition, and invert it:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">5</span>).<span class="ruby-identifier">invert</span>&#x000A;<span class="ruby-comment"># SELECT * FROM artists WHERE id != 5</span></pre>
            
            <p>Note that <code>invert</code> inverts the entire filter:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">5</span>).<span class="ruby-identifier">where</span>{<span class="ruby-identifier">name</span> <span class="ruby-operator">&gt;</span> <span class="ruby-string">'A'</span>}.<span class="ruby-identifier">invert</span>&#x000A;<span class="ruby-comment"># SELECT * FROM artists WHERE id != 5 OR name &lt;= 'A'</span></pre>
            
            <p>In general, <code>invert</code> is used rarely, since <code>exclude</code>
            allows you to invert only specific filters:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">exclude</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">5</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM artists WHERE id != 5</span>&#x000A;&#x000A;<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">5</span>).<span class="ruby-identifier">exclude</span>{<span class="ruby-identifier">name</span> <span class="ruby-operator">&gt;</span> <span class="ruby-string">'A'</span>}&#x000A;<span class="ruby-comment"># SELECT * FROM artists WHERE id = 5 OR name &lt;= 'A'</span></pre>
            
            <p>So to do a NOT IN with an array:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">exclude</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>])&#x000A;<span class="ruby-comment"># SELECT * FROM artists WHERE id NOT IN (1, 2)</span></pre>
            
            <p>Or to use the NOT LIKE operator:</p>
            
            <pre>Artist.exclude(Sequel.like(:name, '%J%'))&#x000A;# SELECT * FROM artists WHERE name NOT LIKE '%J%'</pre>
            
            <h3 id="label-Removing">Removing</h3>
            
            <p>To remove all existing filters, use <code>unfiltered</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>).<span class="ruby-identifier">unfiltered</span>&#x000A;<span class="ruby-comment"># SELECT * FROM artists</span></pre>
            
            <h2 id="label-Ordering">Ordering</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> offers quite a few methods
            to manipulate the SQL ORDER BY clause.  The most basic of these is
            <code>order</code>:</p>
            
            <pre>Artist.order(:id)&#x000A;# SELECT * FROM artists ORDER BY id</pre>
            
            <p>You can specify multiple arguments to order by more than one column:</p>
            
            <pre>Album.order(:artist_id, :id)&#x000A;# SELECT * FROM album ORDER BY artist_id, id</pre>
            
            <p>Note that unlike <code>where</code>, <code>order</code> replaces an
            existing order, it does not append to an existing order:</p>
            
            <pre>Artist.order(:id).order(:name)&#x000A;# SELECT * FROM artists ORDER BY name</pre>
            
            <p>If you want to add a column to the end of the existing order:</p>
            
            <pre>Artist.order(:id).order_append(:name)&#x000A;# SELECT * FROM artists ORDER BY id, name</pre>
            
            <p>If you want to add a column to the beginning of the existing order:</p>
            
            <pre>Artist.order(:id).order_prepend(:name)&#x000A;# SELECT * FROM artists ORDER BY name, id</pre>
            
            <h3 id="label-Reversing">Reversing</h3>
            
            <p>Just like you can invert an existing filter, you can reverse an existing
            order, using <code>reverse</code>:</p>
            
            <pre>Artist.order(:id).reverse&#x000A;# SELECT FROM artists ORDER BY id DESC</pre>
            
            <p>As you might expect, <code>reverse</code> is not used all that much.  In
            general, <code>Sequel.desc</code> is used more commonly to specify a
            descending order for columns:</p>
            
            <pre>Artist.order(Sequel.desc(:id))&#x000A;# SELECT FROM artists ORDER BY id DESC</pre>
            
            <p>This allows you to easily use both ascending and descending orders:</p>
            
            <pre>Artist.order(:name, Sequel.desc(:id))&#x000A;# SELECT FROM artists ORDER BY name, id DESC</pre>
            
            <h3 id="label-Removing">Removing</h3>
            
            <p>Just like you can remove filters with <code>unfiltered</code>, you can
            remove orders with <code>unordered</code>:</p>
            
            <pre>Artist.order(:name).unordered&#x000A;# SELECT * FROM artists</pre>
            
            <h2 id="label-Selected+Columns">Selected Columns</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> offers a few methods to
            manipulate the columns selected.  As you may be able to guess, the main
            method used is <code>select</code>:</p>
            
            <pre>Artist.select(:id, :name)&#x000A;# SELECT id, name FROM artists</pre>
            
            <p>You just specify all of the columns that you are selecting as arguments to
            the method.</p>
            
            <p>If you are dealing with model objects, you’ll want to include the primary
            key if you want to update or destroy the object.  You’ll also want to
            include any keys (primary or foreign) related to associations you plan to
            use.</p>
            
            <p>If a column is not selected, and you attempt to access it, you will get
            nil:</p>
            
            <pre class="ruby"><span class="ruby-identifier">artist</span> = <span class="ruby-constant">Artist</span>.<span class="ruby-identifier">select</span>(:<span class="ruby-identifier">name</span>).<span class="ruby-identifier">first</span>&#x000A;<span class="ruby-comment"># SELECT name FROM artists LIMIT 1</span>&#x000A;&#x000A;<span class="ruby-identifier">artist</span>[:<span class="ruby-identifier">id</span>]&#x000A;<span class="ruby-comment"># =&gt; nil</span></pre>
            
            <p>Like <code>order</code>, <code>select</code> replaces the existing selected
            columns:</p>
            
            <pre>Artist.select(:id).select(:name)&#x000A;# SELECT name FROM artists</pre>
            
            <p>To add to the existing selected columns, use <code>select_append</code>:</p>
            
            <pre>Artist.select(:id).select_append(:name)&#x000A;# SELECT id, name FROM artists</pre>
            
            <p>To remove specifically selected columns, and default back to all columns,
            use <code>select_all</code>:</p>
            
            <pre>Artist.select(:id).select_all&#x000A;# SELECT * FROM artists</pre>
            
            <p>To select all columns from a given table, provide an argument to
            <code>select_all</code>:</p>
            
            <pre>Artist.select_all(:artists)&#x000A;# SELECT artists.* FROM artists</pre>
            
            <h3 id="label-Distinct">Distinct</h3>
            
            <p>To treat duplicate rows as a single row when retrieving the records, use
            <code>distinct</code>:</p>
            
            <pre>Artist.distinct.select(:name)&#x000A;# SELECT DISTINCT name FROM artists</pre>
            
            <p>Note that DISTINCT is a separate SQL clause, it’s not a function that you
            pass to select.</p>
            
            <h2 id="label-Limit+and+Offset">Limit and Offset</h2>
            
            <p>You can limit the dataset to a given number of rows using
            <code>limit</code>:</p>
            
            <pre>Artist.limit(5)&#x000A;# SELECT * FROM artists LIMIT 5</pre>
            
            <p>You can provide a second argument to <code>limit</code> to specify an
            offset:</p>
            
            <pre>Artist.limit(5, 10)&#x000A;# SELECT * FROM artists LIMIT 5 OFFSET 10</pre>
            
            <p>You can also call the <code>offset</code> method separately:</p>
            
            <pre>Artist.limit(5).offset(10)&#x000A;# SELECT * FROM artists LIMIT 5 OFFSET 10</pre>
            
            <p>Either of these would return the 11th through 15th records in the original
            dataset.</p>
            
            <p>To remove a limit from a dataset, use <code>unlimited</code>:</p>
            
            <pre>Artist.limit(5, 10).unlimited&#x000A;# SELECT * FROM artists</pre>
            
            <h2 id="label-Grouping">Grouping</h2>
            
            <p>The SQL GROUP BY clause is used to combine multiple rows based on the
            values of a given group of columns.</p>
            
            <p>To modify the GROUP BY clause of the SQL statement, you use
            <code>group</code>:</p>
            
            <pre>Album.group(:artist_id)&#x000A;# SELECT * FROM albums GROUP BY artist_id</pre>
            
            <p>You can remove an existing grouping using <code>ungrouped</code>:</p>
            
            <pre>Album.group(:artist_id).ungrouped&#x000A;# SELECT * FROM albums</pre>
            
            <p>A common use of grouping is to count based on the number of grouped rows,
            and <a href="../../classes/Sequel.html">Sequel</a> provides a
            <code>group_and_count</code> method to make this easier:</p>
            
            <pre>Album.group_and_count(:artist_id)&#x000A;# SELECT artist_id, count(*) AS count FROM albums GROUP BY artist_id</pre>
            
            <p>This will return the number of albums for each artist_id.</p>
            
            <p>If you want to select and group on the same columns, you can use
            <code>select_group</code>:</p>
            
            <pre>Album.select_group(:artist_id)&#x000A;# SELECT artist_id FROM albums GROUP BY artist_id</pre>
            
            <p>Usually you would add a <code>select_append</code> call after that, to add
            some sort of aggregation:</p>
            
            <pre>Album.select_group(:artist_id).select_append{sum(num_tracks).as(tracks)}&#x000A;# SELECT artist_id, sum(num_tracks) AS tracks FROM albums GROUP BY artist_id</pre>
            
            <h2 id="label-Having">Having</h2>
            
            <p>The SQL HAVING clause is similar to the WHERE clause, except that filters
            the results after the grouping has been applied, instead of before.  One
            possible use is if you only wanted to return artists who had at least 10
            albums:</p>
            
            <pre>Album.group_and_count(:artist_id).having{count(:*){} &gt;= 10}&#x000A;# SELECT artist_id, count(*) AS count FROM albums&#x000A;# GROUP BY artist_id HAVING count(*) &gt;= 10</pre>
            
            <p>Both the WHERE clause and the HAVING clause are removed by
            <code>unfiltered</code>:</p>
            
            <pre>Album.group_and_count(:artist_id).having{count(:*){} &gt;= 10}.&#x000A; where(:name.like('A%')).unfiltered&#x000A;# SELECT artist_id, count(*) AS count FROM albums GROUP BY artist_id</pre>
            
            <h2 id="label-Joins">Joins</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> makes it very easy to join a
            dataset to another table or dataset. The underlying method used is
            <code>join_table</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">join_table</span>(:<span class="ruby-identifier">inner</span>, :<span class="ruby-identifier">artists</span>, :<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artist_id</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM albums</span>&#x000A;<span class="ruby-comment"># INNER JOIN artists ON artists.id = albums.artist_id</span></pre>
            
            <p>In most cases, you won’t call <code>join_table</code> directly, as <a
            href="../../classes/Sequel.html">Sequel</a> provides shortcuts for all
            common (and most uncommon) join types. For example <code>join</code> does
            an inner join:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">join</span>(:<span class="ruby-identifier">artists</span>, :<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artist_id</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM albums</span>&#x000A;<span class="ruby-comment"># INNER JOIN artists ON artists.id = albums.artist_id</span></pre>
            
            <p>And <code>left_join</code> does a LEFT JOIN:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">left_join</span>(:<span class="ruby-identifier">artists</span>, :<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artist_id</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM albums</span>&#x000A;<span class="ruby-comment"># LEFT JOIN artists ON artists.id = albums.artist_id</span></pre>
            
            <h3 id="label-Table%2FDataset+to+Join">Table/Dataset to Join</h3>
            
            <p>For all of these specialized join methods, the first argument is generally
            the name of the table to which you are joining.  However, you can also
            provide a model class:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">join</span>(<span class="ruby-constant">Artist</span>, :<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artist_id</span>)</pre>
            
            <p>Or a dataset, in which case a subselect is used:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">join</span>(<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">name</span> <span class="ruby-operator">&lt;</span> <span class="ruby-string">'A'</span>}, :<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artist_id</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM albums</span>&#x000A;<span class="ruby-comment"># INNER JOIN (SELECT * FROM artists WHERE (name &lt; 'A')) AS t1</span>&#x000A;<span class="ruby-comment">#  ON (t1.id = albums.artist_id)</span></pre>
            
            <h3 id="label-Join+Conditions">Join Conditions</h3>
            
            <p>The second argument to the specialized join methods is the conditions  to
            use when joining, which is similar to a filter expression, with a few minor
            exceptions.</p>
            
            <h4 id="label-Implicit+Qualification">Implicit Qualification</h4>
            
            <p>A hash used as the join conditions operates similarly to a filter, except
            that unqualified symbol keys are automatically qualified with the table
            from the first argument, and unqualified symbol values are automatically
            qualified with the first table or the last table joined.  This implicit
            qualification is one of the reasons that joins in <a
            href="../../classes/Sequel.html">Sequel</a> are easy to specify:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">join</span>(:<span class="ruby-identifier">artists</span>, :<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artist_id</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM albums</span>&#x000A;<span class="ruby-comment"># INNER JOIN artists ON artists.id = albums.artist_id</span></pre>
            
            <p>Note how the <code>:id</code> symbol is automatically qualified with
            <code>artists</code>, while the <code>artist_id</code> symbol is
            automatically qualified with <code>albums</code>.</p>
            
            <p>Because <a href="../../classes/Sequel.html">Sequel</a> uses the last joined
            table for implicit qualifications of values, you can do things like:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">join</span>(:<span class="ruby-identifier">artists</span>, :<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artist_id</span>).&#x000A; <span class="ruby-identifier">join</span>(:<span class="ruby-identifier">members</span>, :<span class="ruby-identifier">artist_id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">id</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM albums</span>&#x000A;<span class="ruby-comment"># INNER JOIN artists ON artists.id = albums.artist_id</span>&#x000A;<span class="ruby-comment"># INNER JOIN members ON members.artist_id = artists.id</span></pre>
            
            <p>Note that when joining to the <code>members</code> table,
            <code>artist_id</code> is qualified with <code>members</code> and
            <code>id</code> is qualified with <code>artists</code>.</p>
            
            <p>While a good default, implicit qualification is not always correct:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">join</span>(:<span class="ruby-identifier">artists</span>, :<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artist_id</span>).&#x000A; <span class="ruby-identifier">join</span>(:<span class="ruby-identifier">tracks</span>, :<span class="ruby-identifier">album_id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">id</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM albums</span>&#x000A;<span class="ruby-comment"># INNER JOIN artists ON artists.id = albums.artist_id</span>&#x000A;<span class="ruby-comment"># INNER JOIN tracks ON tracks.album_id = artists.id</span></pre>
            
            <p>Note here how <code>id</code> is qualified with <code>artists</code>
            instead of <code>albums</code>. This is wrong as the foreign key
            <code>tracks.album_id</code> refers to <code>albums.id</code>, not
            <code>artists.id</code>.  To fix this, you need to explicitly qualify when
            joining:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">join</span>(:<span class="ruby-identifier">artists</span>, :<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artist_id</span>).&#x000A; <span class="ruby-identifier">join</span>(:<span class="ruby-identifier">tracks</span>, :<span class="ruby-identifier">album_id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">albums__id</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM albums</span>&#x000A;<span class="ruby-comment"># INNER JOIN artists ON artists.id = albums.artist_id</span>&#x000A;<span class="ruby-comment"># INNER JOIN tracks ON tracks.album_id = albums.id</span></pre>
            
            <p>Just like in filters, an array of two element arrays is treated the same as
            a hash, but allows for duplicate keys:</p>
            
            <pre>Album.join(:artists, [[:id, :artist_id], [:id, 1..5]])&#x000A;# SELECT * FROM albums INNER JOIN artists&#x000A;#  ON artists.id = albums.artist_id&#x000A;#   AND artists.id &gt;= 1 AND artists.id &lt;= 5</pre>
            
            <p>And just like in the hash case, unqualified symbol elements in the array
            are implicitly qualified.</p>
            
            <p>By default, <a href="../../classes/Sequel.html">Sequel</a> only qualifies
            unqualified symbols in the conditions.  However, You can provide an options
            hash with a <code>:qualify=&gt;:deep</code> option to do a deep
            qualification, which can qualify subexpressions.  For example, let’s say
            you are doing a JOIN using case insensitive string comparison:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">join</span>(:<span class="ruby-identifier">artists</span>, {<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">function</span>(:<span class="ruby-identifier">lower</span>, :<span class="ruby-identifier">name</span>) =<span class="ruby-operator">&gt;</span>&#x000A;                      <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">function</span>(:<span class="ruby-identifier">lower</span>, :<span class="ruby-identifier">artist_name</span>)},&#x000A;           :<span class="ruby-identifier">qualify</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">deep</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM albums INNER JOIN artists</span>&#x000A;<span class="ruby-comment">#  ON (lower(artists.name) = lower(albums.artist_name))</span></pre>
            
            <p>Note how the arguments to lower were qualified correctly in both cases.
            Starting in <a href="../../classes/Sequel.html">Sequel</a> 4, the
            <code>:qualify=&gt;:deep</code> option is going to become the default.</p>
            
            <h4 id="label-USING+Joins">USING Joins</h4>
            
            <p>The most common type of join conditions is a JOIN ON, as displayed above. 
            However, the SQL standard allows for join conditions to be specified with
            JOIN USING, which <a href="../../classes/Sequel.html">Sequel</a> makes easy
            to use.</p>
            
            <p>JOIN USING is useful when the columns you are using have the same names in
            both tables.  For example, if instead of having a primary column named
            <code>id</code> in all of your tables, you use <code>artist_id</code> in
            your <code>artists</code> table and <code>album_id</code> in your
            <code>albums</code> table, you could do:</p>
            
            <pre>Album.join(:artists, [:artist_id])&#x000A;# SELECT * FROM albums INNER JOIN artists USING (artist_id)</pre>
            
            <p>See here how you specify the USING columns as an array of symbols.</p>
            
            <h4 id="label-NATURAL+Joins">NATURAL Joins</h4>
            
            <p>NATURAL Joins take it one step further than USING joins, by assuming that
            all columns with the same names in both tables should be used for joining:</p>
            
            <pre>Album.natural_join(:artists)&#x000A;# SELECT * FROM albums NATURAL JOIN artists</pre>
            
            <p>In this case, you don’t even need to specify any conditions.</p>
            
            <h4 id="label-Join+Blocks">Join Blocks</h4>
            
            <p>You can provide a block to any of the join methods that accept conditions. 
            This block should accept 3 arguments, the table alias for the table
            currently being joined, the table alias for the last table joined (or first
            table), and an array of previous <code>Sequel::SQL::JoinClause</code>s.</p>
            
            <p>This allows you to qualify columns similar to how the implicit
            qualification works, without worrying about the specific aliases being
            used.  For example, lets say you wanted to join the albums and artists
            tables, but only want albums where the artist’s name comes before the
            album’s name.</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">join</span>(:<span class="ruby-identifier">artists</span>, :<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artist_id</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">j</span>, <span class="ruby-identifier">lj</span>, <span class="ruby-identifier">js</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">qualify</span>(<span class="ruby-identifier">j</span>, :<span class="ruby-identifier">name</span>) <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">qualify</span>(<span class="ruby-identifier">lj</span>, :<span class="ruby-identifier">name</span>)&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-comment"># SELECT * FROM albums INNER JOIN artists</span>&#x000A;<span class="ruby-comment"># ON artists.id = albums.artist_id</span>&#x000A;<span class="ruby-comment"># AND artists.name &lt; albums.name</span></pre>
            
            <p>Because greater than can’t be expressed with a hash in <a
            href="../../classes/Sequel.html">Sequel</a>, you need to use a block and
            qualify the tables manually.</p>
            
            <h2 id="label-From">From</h2>
            
            <p>In general, the FROM table is the first clause populated when creating a
            dataset.  For a standard <a
            href="../../classes/Sequel/Model.html">Sequel::Model</a>, the dataset
            already has the FROM clause populated, and the most common way to create
            datasets is with the <code>Database#[]</code> method, which populates the
            FROM clause.</p>
            
            <p>However, you can modify the tables you are selecting FROM using
            <code>from</code>:</p>
            
            <pre>Album.from(:albums, :old_albums)&#x000A;# SELECT * FROM albums, old_albums</pre>
            
            <p>Be careful with this, as multiple tables in the FROM clause use a cross
            join by default, so the number of rows will be number of albums times the
            number of old albums.</p>
            
            <p>Using multiple FROM tables and setting conditions in the WHERE clause is an
            old-school way of joining tables:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">from</span>(:<span class="ruby-identifier">albums</span>, :<span class="ruby-identifier">artists</span>).<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">artists__id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">albums__artist_id</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM albums, artists WHERE artists.id = albums.artist_id</span></pre>
            
            <h3 id="label-Using+the+current+dataset+in+a+subselect">Using the current dataset in a subselect</h3>
            
            <p>In some cases, you may want to wrap the current dataset in a subselect.
            Here’s an example using <code>from_self</code>:</p>
            
            <pre>Album.order(:artist_id).limit(100).from_self.group(:artist_id)&#x000A;# SELECT * FROM (SELECT * FROM albums ORDER BY artist_id LIMIT 100)&#x000A;#  AS t1 GROUP BY artist_id</pre>
            
            <p>This is slightly different than without <code>from_self</code>:</p>
            
            <pre>Album.order(:artist_id).limit(100).group(:artist_id)&#x000A;# SELECT * FROM albums GROUP BY artist_id ORDER BY name LIMIT 100</pre>
            
            <p>Without <code>from_self</code>, you are doing the grouping, and limiting
            the number of grouped records returned to 100.  So assuming you have albums
            by more than 100 artists, you’ll end up with 100 results.</p>
            
            <p>With <code>from_self</code>, you are limiting the number of records before
            grouping. So if the artist with the lowest id had 100 albums, you’d get 1
            result, not 100.</p>
            
            <h2 id="label-Locking+for+Update">Locking for Update</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> allows you to easily add a
            FOR UPDATE clause to your queries so that the records returned can't be
            modified by another query until the current transaction commits.  You just
            use the <code>for_update</code> dataset method when returning the rows:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">transaction</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">album</span> = <span class="ruby-constant">Album</span>.<span class="ruby-identifier">for_update</span>.<span class="ruby-identifier">first</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>)&#x000A;  <span class="ruby-comment"># SELECT * FROM albums WHERE id = 1 FOR UPDATE</span>&#x000A;  <span class="ruby-identifier">album</span>.<span class="ruby-identifier">num_tracks</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>&#x000A;  <span class="ruby-identifier">album</span>.<span class="ruby-identifier">save</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>This will ensure that no other connection modifies the row between when you
            select it and when the transaction ends.</p>
            
            <h3 id="label-Optimistic+Locking">Optimistic Locking</h3>
            
            <p>One of the model plugins that ships with <a
            href="../../classes/Sequel.html">Sequel</a> is an optimistic locking
            plugin, which provides a database independent way to detect and raise an
            error if two different connections modify the same row.  It’s useful for
            things like web forms where you cannot keep a transaction open while the
            user is looking at the form, because of the web’s stateless nature.</p>
            
            <h2 id="label-Custom+SQL">Custom SQL</h2>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> makes it easy to use custom
            SQL by providing it to the <code>Database#[]</code> method as a string:</p>
            
            <pre>DB[&quot;SELECT * FROM artists&quot;]&#x000A;# SELECT * FROM artists</pre>
            
            <p>You can also use the <code>with_sql</code> dataset method to return a
            dataset that uses that exact SQL:</p>
            
            <pre>DB[:albums].with_sql(&quot;SELECT * FROM artists&quot;)&#x000A;# SELECT * FROM artists</pre>
            
            <p>With either of these methods, you can use placeholders:</p>
            
            <pre class="ruby"><span class="ruby-constant">DB</span>[<span class="ruby-string">&quot;SELECT * FROM artists WHERE id = ?&quot;</span>, <span class="ruby-value">5</span>]&#x000A;<span class="ruby-comment"># SELECT * FROM artists WHERE id = 5</span>&#x000A;&#x000A;<span class="ruby-constant">DB</span>[:<span class="ruby-identifier">albums</span>].<span class="ruby-identifier">with_sql</span>(<span class="ruby-string">&quot;SELECT * FROM artists WHERE id = :id&quot;</span>, :<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">5</span>)&#x000A;<span class="ruby-comment"># SELECT * FROM artists WHERE id = 5</span></pre>
            
            <p>Note that if you specify the dataset using custom SQL, you can still call
            the dataset modification methods, but in many cases they will appear to
            have no affect:</p>
            
            <pre>DB[&quot;SELECT * FROM artists&quot;].select(:name).order(:id)&#x000A;# SELECT * FROM artists</pre>
            
            <p>If you must drop down to using custom SQL, it’s recommended that you only
            do so for specific parts of a query.  For example, if the reason you are
            using custom SQL is to use a custom operator in the database in the SELECT
            clause:</p>
            
            <pre>DB[&quot;SELECT name, (foo !@# ?) AS baz FROM artists&quot;, 'bar']</pre>
            
            <p>it’s better to use Sequel’s DSL, and use a literal string for the custom
            operator:</p>
            
            <pre>DB[:artists].select(:name, Sequel.lit(&quot;(foo !@# ?)&quot;, 'bar').as(:baz))</pre>
            
            <p>That way Sequel’s method chaining still works, and it increases Sequel’s
            ability to introspect the code.</p>
            
            <h2 id="label-Checking+for+Records">Checking for Records</h2>
            
            <p>If you just want to know whether the current dataset would return any rows,
            use <code>empty?</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">empty?</span>&#x000A;<span class="ruby-comment"># SELECT 1 FROM albums LIMIT 1</span>&#x000A;=<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">false</span>&#x000A;&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">id=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">0</span>).<span class="ruby-identifier">empty?</span>&#x000A;<span class="ruby-comment"># SELECT 1 FROM albums WHERE id = 0 LIMIT 1</span>&#x000A;=<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>&#x000A;&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">where</span>(<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">like</span>(:<span class="ruby-identifier">name</span>, <span class="ruby-string">'R%'</span>)).<span class="ruby-identifier">empty?</span>&#x000A;<span class="ruby-comment"># SELECT 1 FROM albums WHERE name LIKE 'R%' LIMIT 1</span>&#x000A;=<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">false</span></pre>
            
            <h2 id="label-Aggregate+Calculations">Aggregate Calculations</h2>
            
            <p>The SQL standard defines a few helpful methods to get aggreate information
            about datasets, such as <code>count</code>, <code>sum</code>,
            <code>avg</code>, <code>min</code>, and <code>max</code>.  There are
            dataset methods for each of these aggregate functions.</p>
            
            <p><code>count</code> just returns the number of records in the dataset.</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">count</span>&#x000A;<span class="ruby-comment"># SELECT count(*) AS count FROM albums LIMIT 1</span>&#x000A;=<span class="ruby-operator">&gt;</span> <span class="ruby-value">2</span></pre>
            
            <p>The other methods take a column argument and call the aggregate function
            with the argument:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">sum</span>(:<span class="ruby-identifier">id</span>)&#x000A;<span class="ruby-comment"># SELECT sum(id) FROM albums LIMIT 1</span>&#x000A;=<span class="ruby-operator">&gt;</span> <span class="ruby-value">3</span>&#x000A;&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">avg</span>(:<span class="ruby-identifier">id</span>)&#x000A;<span class="ruby-comment"># SELECT avg(id) FROM albums LIMIT 1</span>&#x000A;=<span class="ruby-operator">&gt;</span> <span class="ruby-value">1.5</span>&#x000A;&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">min</span>(:<span class="ruby-identifier">id</span>)&#x000A;<span class="ruby-comment"># SELECT min(id) FROM albums LIMIT 1</span>&#x000A;=<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>&#x000A;&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">max</span>(:<span class="ruby-identifier">id</span>)&#x000A;<span class="ruby-comment"># SELECT max(id) FROM albums LIMIT 1</span>&#x000A;=<span class="ruby-operator">&gt;</span> <span class="ruby-value">2</span></pre>
          </div>
          <div id='context'>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
