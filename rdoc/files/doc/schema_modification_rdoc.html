<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>schema_modification.rdoc</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='file' id='wrapper'>
      <div class='header'>
        <h1 class='name'>schema_modification.rdoc</h1>
        <div class='paths'>
          doc/schema_modification.rdoc
        </div>
        <div class='last-update'>
          Last Update:
          <span class='datetime'>2013-11-08 08:08:17 -0500</span>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <h1 id="label-Schema+modification+methods">Schema modification methods</h1>
            
            <p>Here’s a brief description of the most common schema modification methods:</p>
            
            <h2 id="label-create_table"><code>create_table</code></h2>
            
            <p><code>create_table</code> is the most common schema modification method,
            and it's used for adding new tables to the database.  You provide it with
            the name of the table as a symbol, as well a block:</p>
            
            <pre>create_table(:artists) do&#x000A;  primary_key :id&#x000A;  String :name&#x000A;end</pre>
            
            <p>Note that if you want a primary key for the table, you need to specify it,
            <a href="../../classes/Sequel.html">Sequel</a> does not create one by
            default.</p>
            
            <h3 id="label-Column+types">Column types</h3>
            
            <p>Most method calls inside the create_table block will create columns, since
            <code>method_missing</code> calls <code>column</code>. Columns are
            generally created by specifying the column type as the method name,
            followed by the column name symbol to use, and after that any options that
            should be used. If the method is a ruby class name that <a
            href="../../classes/Sequel.html">Sequel</a> recognizes, <a
            href="../../classes/Sequel.html">Sequel</a> will transform it into the
            appropriate type for the given database.  So while you specified
            <code>String</code>, <a href="../../classes/Sequel.html">Sequel</a> will
            actually use <code>varchar</code> or <code>text</code> depending on the
            underlying database.  Here’s a list of all of ruby classes that <a
            href="../../classes/Sequel.html">Sequel</a> will convert to database types:</p>
            
            <pre class="ruby"><span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">columns_types</span>) <span class="ruby-keyword">do</span>       <span class="ruby-comment"># common database type used</span>&#x000A;  <span class="ruby-constant">Integer</span> :<span class="ruby-identifier">a0</span>                         <span class="ruby-comment"># integer</span>&#x000A;  <span class="ruby-constant">String</span> :<span class="ruby-identifier">a1</span>                          <span class="ruby-comment"># varchar(255)</span>&#x000A;  <span class="ruby-constant">String</span> :<span class="ruby-identifier">a2</span>, :<span class="ruby-identifier">size=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">50</span>               <span class="ruby-comment"># varchar(50)</span>&#x000A;  <span class="ruby-constant">String</span> :<span class="ruby-identifier">a3</span>, :<span class="ruby-identifier">fixed=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>            <span class="ruby-comment"># char(255)</span>&#x000A;  <span class="ruby-constant">String</span> :<span class="ruby-identifier">a4</span>, :<span class="ruby-identifier">fixed=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>, :<span class="ruby-identifier">size=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">50</span> <span class="ruby-comment"># char(50)</span>&#x000A;  <span class="ruby-constant">String</span> :<span class="ruby-identifier">a5</span>, :<span class="ruby-identifier">text=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>             <span class="ruby-comment"># text</span>&#x000A;  <span class="ruby-constant">File</span> :<span class="ruby-identifier">b</span>,                            <span class="ruby-comment"># blob</span>&#x000A;  <span class="ruby-constant">Fixnum</span> :<span class="ruby-identifier">c</span>                           <span class="ruby-comment"># integer</span>&#x000A;  <span class="ruby-constant">Bignum</span> :<span class="ruby-identifier">d</span>                           <span class="ruby-comment"># bigint</span>&#x000A;  <span class="ruby-constant">Float</span> :<span class="ruby-identifier">e</span>                            <span class="ruby-comment"># double precision</span>&#x000A;  <span class="ruby-constant">BigDecimal</span> :<span class="ruby-identifier">f</span>                       <span class="ruby-comment"># numeric</span>&#x000A;  <span class="ruby-constant">BigDecimal</span> :<span class="ruby-identifier">f2</span>, :<span class="ruby-identifier">size=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">10</span>           <span class="ruby-comment"># numeric(10)</span>&#x000A;  <span class="ruby-constant">BigDecimal</span> :<span class="ruby-identifier">f3</span>, :<span class="ruby-identifier">size=</span><span class="ruby-operator">&gt;</span>[<span class="ruby-value">10</span>, <span class="ruby-value">2</span>]      <span class="ruby-comment"># numeric(10, 2)</span>&#x000A;  <span class="ruby-constant">Date</span> :<span class="ruby-identifier">g</span>                             <span class="ruby-comment"># date</span>&#x000A;  <span class="ruby-constant">DateTime</span> :<span class="ruby-identifier">h</span>                         <span class="ruby-comment"># timestamp</span>&#x000A;  <span class="ruby-constant">Time</span> :<span class="ruby-identifier">i</span>                             <span class="ruby-comment"># timestamp</span>&#x000A;  <span class="ruby-constant">Time</span> :<span class="ruby-identifier">i2</span>, :<span class="ruby-identifier">only_time=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>          <span class="ruby-comment"># time</span>&#x000A;  <span class="ruby-constant">Numeric</span> :<span class="ruby-identifier">j</span>                          <span class="ruby-comment"># numeric</span>&#x000A;  <span class="ruby-constant">TrueClass</span> :<span class="ruby-identifier">k</span>                        <span class="ruby-comment"># boolean</span>&#x000A;  <span class="ruby-constant">FalseClass</span> :<span class="ruby-identifier">l</span>                       <span class="ruby-comment"># boolean</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Note that in addition to the ruby class name, <a
            href="../../classes/Sequel.html">Sequel</a> also pays attention to the
            column options when determining which database type to use.  Also note that
            for boolean columns, you can use either TrueClass or FalseClass, they are
            treated the same way (ruby doesn’t have a Boolean class).</p>
            
            <p>Also note that this conversion is only done if you use a supported ruby
            class name.  In all other cases, <a
            href="../../classes/Sequel.html">Sequel</a> uses the type specified
            verbatim:</p>
            
            <pre>create_table(:columns_types) do  # database type used&#x000A;  string :a1                     # string&#x000A;  datetime :a2                   # datetime&#x000A;  blob :a3                       # blob&#x000A;  inet :a4                       # inet&#x000A;end</pre>
            
            <p>In addition to specifying the types as methods, you can use the
            <code>column</code> method and specify the types as the second argument,
            either as ruby classes, symbols, or strings:</p>
            
            <pre>create_table(:columns_types) do  # database type used&#x000A;  column :a1, :string            # string&#x000A;  column :a2, String             # varchar(255)&#x000A;  column :a3, 'string'           # string&#x000A;  column :a4, :datetime          # datetime&#x000A;  column :a5, DateTime           # timestamp&#x000A;  column :a6, 'timestamp(6)'     # timestamp(6)&#x000A;end</pre>
            
            <h3 id="label-Column+options">Column options</h3>
            
            <p>When using the type name as method, the third argument is an options hash,
            and when using the <code>column</code> method, the fourth argument is the
            options hash.  The following options are supported:</p>
            <dl class="rdoc-list note-list"><dt>:default 
            <dd>
            <p>The default value for the column.</p>
            </dd><dt>:index 
            <dd>
            <p>Create an index on this column. If given a hash, use the hash as the
            options for the index.</p>
            </dd><dt>:null 
            <dd>
            <p>Mark the column as allowing NULL values (if true), or not allowing NULL
            values (if false).  If unspecified, will default to whatever the database
            default is.</p>
            </dd><dt>:primary_key 
            <dd>
            <p>Mark this column as the primary key.  This is used instead of the primary
            key method if you want a non-autoincrementing primary key.</p>
            </dd><dt>:primary_key_constraint_name 
            <dd>
            <p>The name to give the primary key constraint.</p>
            </dd><dt>:type 
            <dd>
            <p>Overrides the type given as the method name or a separate argument. Not
            usually used by <code>column</code> itself, but often by other methods such
            as <code>primary_key</code> or <code>foreign_key</code>.</p>
            </dd><dt>:unique 
            <dd>
            <p>Mark the column as unique, generally has the same effect as creating a
            unique index on the column.</p>
            </dd><dt>:unique_constraint_name 
            <dd>
            <p>The name to give the unique key constraint.</p>
            </dd></dl>
            
            <h3 id="label-Other+methods">Other methods</h3>
            
            <p>In addition to the <code>column</code> method and other methods that create
            columns, there are a other methods that can be used:</p>
            
            <h4 id="label-primary_key"><code>primary_key</code></h4>
            
            <p>You’ve seen this one used already.  It’s used to create an autoincrementing
            integer primary key column.</p>
            
            <pre>create_table(:a0){primary_key :id}</pre>
            
            <p>If you want an autoincrementing 64-bit integer:</p>
            
            <pre class="ruby"><span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">a0</span>){<span class="ruby-identifier">primary_key</span> :<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">type=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">Bignum</span>}</pre>
            
            <p>If you want to create a primary key column that doesn’t use an
            autoincrementing integer, you should not use this method.  Instead, you
            should use the :primary_key option to the <code>column</code> method or
            type method:</p>
            
            <pre class="ruby"><span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">a1</span>){<span class="ruby-constant">Integer</span> :<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">primary_key=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>} <span class="ruby-comment"># Non autoincrementing integer primary key</span>&#x000A;<span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">a2</span>){<span class="ruby-constant">String</span> :<span class="ruby-identifier">name</span>, :<span class="ruby-identifier">primary_key=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>} <span class="ruby-comment"># varchar(255) primary key</span></pre>
            
            <p>If you want to create a composite primary key, you should call the
            <code>primary_key</code> method with an array of column symbols.  You can
            provide a specific name to use for the primary key constraint via the :name
            option:</p>
            
            <pre class="ruby"><span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">items</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-constant">Integer</span> :<span class="ruby-identifier">group_id</span>&#x000A;  <span class="ruby-constant">Integer</span> :<span class="ruby-identifier">position</span>&#x000A;  <span class="ruby-identifier">primary_key</span> [:<span class="ruby-identifier">group_id</span>, :<span class="ruby-identifier">position</span>], :<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">items_pk</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>If provided with an array, <code>primary_key</code> does not create a
            column, it just sets up the primary key constraint.</p>
            
            <h4 id="label-foreign_key"><code>foreign_key</code></h4>
            
            <p><code>foreign_key</code> is used to create a foreign key column that
            references a column in another table (or the same table). It takes the
            column name as the first argument, the table it references as the second
            argument, and an options hash as it's third argument.  A simple example is:</p>
            
            <pre>create_table(:albums) do&#x000A;  primary_key :id&#x000A;  foreign_key :artist_id, :artists&#x000A;  String :name&#x000A;end</pre>
            
            <p><code>foreign_key</code> accepts the same options as <code>column</code>. 
            For example, to have a unique foreign key with varchar(16) type:</p>
            
            <pre class="ruby"><span class="ruby-identifier">foreign_key</span> :<span class="ruby-identifier">column_name</span>, :<span class="ruby-identifier">unique=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>, :<span class="ruby-identifier">type=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'varchar(16)'</span></pre>
            
            <p><code>foreign_key</code> also accepts some specific options:</p>
            <dl class="rdoc-list note-list"><dt>:deferrable 
            <dd>
            <p>Makes the foreign key constraint checks deferrable, so they aren’t checked
            until the end of the transaction.</p>
            </dd><dt>:foreign_key_constraint_name 
            <dd>
            <p>The name to give the foreign key constraint.</p>
            </dd><dt>:key 
            <dd>
            <p>The column in the associated table that this column references. 
            Unnecessary if this column references the primary key of the associated
            table, at least on most databases.</p>
            </dd><dt>:on_delete 
            <dd>
            <p>Specify the behavior of this foreign key column when the row with the
            primary key it references is deleted , can be :restrict, :cascade,
            :set_null, or :set_default. You can also use a string, which is used
            literally.</p>
            </dd><dt>:on_update 
            <dd>
            <p>Specify the behavior of this foreign key column when the row with the
            primary key it references modifies the value of the primary key.  Takes the
            same options as :on_delete.</p>
            </dd></dl>
            
            <p>Like <code>primary_key</code>, if you provide <code>foreign_key</code> with
            an array of symbols, it will not create a column, but create a foreign key
            constraint:</p>
            
            <pre>create_table(:artists) do&#x000A;  String :name&#x000A;  String :location&#x000A;  primary_key [:name, :location]&#x000A;end&#x000A;create_table(:albums) do&#x000A;  String :artist_name&#x000A;  String :artist_location&#x000A;  String :name&#x000A;  foreign_key [:artist_name, :artist_location], :artists&#x000A;end</pre>
            
            <p>When using an array of symbols, you can also provide a :name option to name
            the constraint:</p>
            
            <pre class="ruby"><span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">albums</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-constant">String</span> :<span class="ruby-identifier">artist_name</span>&#x000A;  <span class="ruby-constant">String</span> :<span class="ruby-identifier">artist_location</span>&#x000A;  <span class="ruby-constant">String</span> :<span class="ruby-identifier">name</span>&#x000A;  <span class="ruby-identifier">foreign_key</span> [:<span class="ruby-identifier">artist_name</span>, :<span class="ruby-identifier">artist_location</span>], :<span class="ruby-identifier">artists</span>, :<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'albums_artist_name_location_fkey'</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>If you want to add a foreign key for a single column with a named
            constraint, you must use the array form with a single symbol:</p>
            
            <pre class="ruby"><span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">albums</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">primary_key</span> :<span class="ruby-identifier">id</span>&#x000A;  <span class="ruby-constant">Integer</span> :<span class="ruby-identifier">artist_id</span>&#x000A;  <span class="ruby-constant">String</span> :<span class="ruby-identifier">name</span>&#x000A;  <span class="ruby-identifier">foreign_key</span> [:<span class="ruby-identifier">artist_id</span>], :<span class="ruby-identifier">artists</span>, :<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'albums_artist_id_fkey'</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-index"><code>index</code></h4>
            
            <p><code>index</code> creates indexes on the table.  For single columns,
            calling index is the same as using the <code>:index</code> option when
            creating the column:</p>
            
            <pre class="ruby"><span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">a</span>){<span class="ruby-constant">Integer</span> :<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">index=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>}&#x000A;<span class="ruby-comment"># Same as:</span>&#x000A;<span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">a</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-constant">Integer</span> :<span class="ruby-identifier">id</span>&#x000A;  <span class="ruby-identifier">index</span> :<span class="ruby-identifier">id</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">a</span>){<span class="ruby-constant">Integer</span> :<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">index=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">unique=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>}}&#x000A;<span class="ruby-comment"># Same as:</span>&#x000A;<span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">a</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-constant">Integer</span> :<span class="ruby-identifier">id</span>&#x000A;  <span class="ruby-identifier">index</span> :<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">unique=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Similar to the <code>primary_key</code> and <code>foreign_key</code>
            methods, calling <code>index</code> with an array of symbols will create a
            multiple column index:</p>
            
            <pre>create_table(:albums) do&#x000A;  primary_key :id&#x000A;  foreign_key :artist_id, :artists&#x000A;  Integer :position&#x000A;  index [:artist_id, :position]&#x000A;end</pre>
            
            <p>The <code>index</code> method also accepts some options:</p>
            <dl class="rdoc-list note-list"><dt>:name 
            <dd>
            <p>The name of the index (generated based on the table and column names if not
            provided).</p>
            </dd><dt>:type 
            <dd>
            <p>The type of index to use (only supported by some databases)</p>
            </dd><dt>:unique 
            <dd>
            <p>Make the index unique, so duplicate values are not allowed.</p>
            </dd><dt>:where 
            <dd>
            <p>Create a partial index (only supported by some databases)</p>
            </dd></dl>
            
            <h4 id="label-unique"><code>unique</code></h4>
            
            <p>The <code>unique</code> method creates a unique constraint on the table.  A
            unique constraint generally operates identically to a unique index, so the
            following three <code>create_table</code> blocks are pretty much identical:</p>
            
            <pre class="ruby"><span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">a</span>){<span class="ruby-constant">Integer</span> :<span class="ruby-identifier">a</span>, :<span class="ruby-identifier">unique=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>}&#x000A;&#x000A;<span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">a</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-constant">Integer</span> :<span class="ruby-identifier">a</span>&#x000A;  <span class="ruby-identifier">index</span> :<span class="ruby-identifier">a</span>, :<span class="ruby-identifier">unique=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">a</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-constant">Integer</span> :<span class="ruby-identifier">a</span>&#x000A;  <span class="ruby-identifier">unique</span> :<span class="ruby-identifier">a</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Just like <code>index</code>, <code>unique</code> can set up a multiple
            column unique constraint, where the combination of the columns must be
            unique:</p>
            
            <pre>create_table(:a) do&#x000A;  Integer :a&#x000A;  Integer :b&#x000A;  unique [:a, :b]&#x000A;end</pre>
            
            <h4 id="label-full_text_index+and+spatial_index"><code>full_text_index</code> and <code>spatial_index</code></h4>
            
            <p>Both of these create specialized index types supported by some databases. 
            They both take the same options as <code>index</code>.</p>
            
            <h4 id="label-constraint"><code>constraint</code></h4>
            
            <p><code>constraint</code> creates a named table constraint:</p>
            
            <pre>create_table(:artists) do&#x000A;  primary_key :id&#x000A;  String :name&#x000A;  constraint(:name_min_length){char_length(name) &gt; 2}&#x000A;end</pre>
            
            <p>Instead of using a block, you can use arguments that will be handled
            similarly to <code>Dataset#where</code>:</p>
            
            <pre class="ruby"><span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">artists</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">primary_key</span> :<span class="ruby-identifier">id</span>&#x000A;  <span class="ruby-constant">String</span> :<span class="ruby-identifier">name</span>&#x000A;  <span class="ruby-identifier">constraint</span>(:<span class="ruby-identifier">name_length_range</span>, <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">function</span>(:<span class="ruby-identifier">char_length</span>, :<span class="ruby-identifier">name</span>)=<span class="ruby-operator">&gt;</span><span class="ruby-value">3</span><span class="ruby-operator">..</span><span class="ruby-value">50</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-check"><code>check</code></h4>
            
            <p><code>check</code> operates just like <code>constraint</code>, except that
            it doesn't take a name and it creates an unnamed constraint:</p>
            
            <pre>create_table(:artists) do&#x000A;  primary_key :id&#x000A;  String :name&#x000A;  check{char_length(name) &gt; 2}&#x000A;end</pre>
            
            <p>It’s recommended that you use the <code>constraint</code> method and
            provide a name for the constraint, as that makes it easier to drop the
            constraint later if necessary.</p>
            
            <h2 id="label-create_join_table"><code>create_join_table</code></h2>
            
            <p><code>create_join_table</code> is a shortcut that you can use to create
            simple many-to-many join tables:</p>
            
            <pre class="ruby"><span class="ruby-identifier">create_join_table</span>(:<span class="ruby-identifier">artist_id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artists</span>, :<span class="ruby-identifier">album_id=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">albums</span>)</pre>
            
            <p>which expands to:</p>
            
            <pre class="ruby"><span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">albums_artists</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">foreign_key</span> :<span class="ruby-identifier">album_id</span>, :<span class="ruby-identifier">albums</span>, :<span class="ruby-identifier">null=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">false</span>&#x000A;  <span class="ruby-identifier">foreign_key</span> :<span class="ruby-identifier">artist_id</span>, :<span class="ruby-identifier">artists</span>, :<span class="ruby-identifier">null=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">false</span>&#x000A;  <span class="ruby-identifier">primary_key</span> [:<span class="ruby-identifier">album_id</span>, :<span class="ruby-identifier">artist_id</span>]&#x000A;  <span class="ruby-identifier">index</span> [:<span class="ruby-identifier">artist_id</span>, :<span class="ruby-identifier">album_id</span>]&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="label-create_table+%3Aas%3D%3E"><code>create_table :as=&gt;</code></h2>
            
            <p>To create a table from the result of a SELECT query, instead of passing a
            block to <code>create_table</code>, provide a dataset to the :as option:</p>
            
            <pre class="ruby"><span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">older_items</span>, :<span class="ruby-identifier">as=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">DB</span>[:<span class="ruby-identifier">items</span>].<span class="ruby-identifier">where</span>{<span class="ruby-identifier">updated_at</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Date</span>.<span class="ruby-identifier">today</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">6</span>})</pre>
            
            <h2 id="label-alter_table"><code>alter_table</code></h2>
            
            <p><code>alter_table</code> is used to alter existing tables, changing their
            columns, indexes, or constraints.  It it used just like
            <code>create_table</code>, accepting a block which is instance_evaled, and
            providing its own methods:</p>
            
            <h3 id="label-add_column"><code>add_column</code></h3>
            
            <p>One of the most common methods, <code>add_column</code> is used to add a
            column to the table. Its API is similar to that of
            <code>create_table</code>‘s <code>column</code> method, where the first
            argument is the column name, the second is the type, and the third is an
            options hash:</p>
            
            <pre class="ruby"><span class="ruby-identifier">alter_table</span>(:<span class="ruby-identifier">albums</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">add_column</span> :<span class="ruby-identifier">copies_sold</span>, <span class="ruby-constant">Integer</span>, :<span class="ruby-identifier">default=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">0</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-drop_column"><code>drop_column</code></h3>
            
            <p>As you may expect, <code>drop_column</code> takes a column name and drops
            the column.  It’s often used in the <code>down</code> block of a migration
            to drop a column added in an <code>up</code> block:</p>
            
            <pre>alter_table(:albums) do&#x000A;  drop_column :copies_sold&#x000A;end</pre>
            
            <h3 id="label-rename_column"><code>rename_column</code></h3>
            
            <p><code>rename_column</code> is used to rename a column.  It takes the old
            column name as the first argument, and the new column name as the second
            argument:</p>
            
            <pre>alter_table(:albums) do&#x000A;  rename_column :copies_sold, :total_sales&#x000A;end</pre>
            
            <h3 id="label-add_primary_key"><code>add_primary_key</code></h3>
            
            <p>If you forgot to include a primary key on the table, and want to add one
            later, you can use <code>add_primary_key</code>.  A common use of this is
            to make many_to_many association join tables into real models:</p>
            
            <pre>alter_table(:albums_artists) do&#x000A;  add_primary_key :id&#x000A;end</pre>
            
            <p>Just like <code>create_table</code>‘s <code>primary_key</code> method, if
            you provide an array of symbols, <a
            href="../../classes/Sequel.html">Sequel</a> will not add a column, but will
            add a composite primary key constraint:</p>
            
            <pre>alter_table(:albums_artists) do&#x000A;  add_primary_key [:album_id, :artist_id]&#x000A;end</pre>
            
            <p>If you just want to take an existing single column and make it a primary
            key, call <code>add_primary_key</code> with an array with a single symbol:</p>
            
            <pre>alter_table(:artists) do&#x000A;  add_primary_key [:id]&#x000A;end</pre>
            
            <h3 id="label-add_foreign_key"><code>add_foreign_key</code></h3>
            
            <p><code>add_foreign_key</code> can be used to add a new foreign key column or
            constraint to a table. Like <code>add_primary_key</code>, if you provide it
            with a symbol as the first argument, it creates a new column:</p>
            
            <pre>alter_table(:albums) do&#x000A;  add_foreign_key :artist_id, :artists&#x000A;end</pre>
            
            <p>If you want to add a new foreign key constraint to an existing column, you
            provide an array with a single element.  It’s encouraged to provide a name
            when adding the constraint, via the :name option:</p>
            
            <pre class="ruby"><span class="ruby-identifier">alter_table</span>(:<span class="ruby-identifier">albums</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">add_foreign_key</span> [:<span class="ruby-identifier">artist_id</span>], :<span class="ruby-identifier">artists</span>, :<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">albums_artist_id_fkey</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>To set up a multiple column foreign key constraint, use an array with
            multiple column symbols:</p>
            
            <pre class="ruby"><span class="ruby-identifier">alter_table</span>(:<span class="ruby-identifier">albums</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">add_foreign_key</span> [:<span class="ruby-identifier">artist_name</span>, :<span class="ruby-identifier">artist_location</span>], :<span class="ruby-identifier">artists</span>, :<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">albums_artist_name_location_fkey</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-drop_foreign_key"><code>drop_foreign_key</code></h3>
            
            <p><code>drop_foreign_key</code> is used to drop foreign keys from tables.  If
            you provide a symbol as the first argument, it drops both the foreign key
            constraint and the column:</p>
            
            <pre>alter_table(:albums) do&#x000A;  drop_foreign_key :artist_id&#x000A;end</pre>
            
            <p>If you want to just drop the foreign key constraint without dropping the
            column, use an array.  It’s encouraged to use the :name option to provide
            the constraint name to drop, though on some databases <a
            href="../../classes/Sequel.html">Sequel</a> may be able to find the name
            through introspection:</p>
            
            <pre class="ruby"><span class="ruby-identifier">alter_table</span>(:<span class="ruby-identifier">albums</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">drop_foreign_key</span> [:<span class="ruby-identifier">artist_id</span>], :<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">albums_artist_id_fkey</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>An array is also used to drop a composite foreign key constraint:</p>
            
            <pre class="ruby"><span class="ruby-identifier">alter_table</span>(:<span class="ruby-identifier">albums</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">drop_foreign_key</span> [:<span class="ruby-identifier">artist_name</span>, :<span class="ruby-identifier">artist_location</span>], :<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">albums_artist_name_location_fkey</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>If you do not provide a :name option and <a
            href="../../classes/Sequel.html">Sequel</a> is not able to determine the
            name to use, it will probably raise a <a
            href="../../classes/Sequel/Error.html">Sequel::Error</a> exception.</p>
            
            <h3 id="label-add_index"><code>add_index</code></h3>
            
            <p><code>add_index</code> works just like <code>create_table</code>'s
            <code>index</code> method, creating a new index on the table:</p>
            
            <pre>alter_table(:albums) do&#x000A;  add_index :artist_id&#x000A;end</pre>
            
            <p>It accepts the same options as <code>create_table</code>‘s
            <code>index</code> method, and you can set up a multiple column index using
            an array:</p>
            
            <pre class="ruby"><span class="ruby-identifier">alter_table</span>(:<span class="ruby-identifier">albums_artists</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">add_index</span> [:<span class="ruby-identifier">album_id</span>, :<span class="ruby-identifier">artist_id</span>], :<span class="ruby-identifier">unique=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-drop_index"><code>drop_index</code></h3>
            
            <p>As you may expect, <code>drop_index</code> drops an existing index:</p>
            
            <pre>alter_table(:albums) do&#x000A;  drop_index :artist_id&#x000A;end</pre>
            
            <p>Just like <code>drop_column</code>, it is often used in the
            <code>down</code> block of a migration.</p>
            
            <p>To drop an index with a specific name, use the <code>:name</code> option:</p>
            
            <pre class="ruby"><span class="ruby-identifier">alter_table</span>(:<span class="ruby-identifier">albums</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">drop_index</span> :<span class="ruby-identifier">artist_id</span>, :<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">artists_id_index</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-add_full_text_index%2C+add_spatial_index"><code>add_full_text_index</code>, <code>add_spatial_index</code></h3>
            
            <p>Corresponding to <code>create_table</code>‘s <code>full_text_index</code>
            and <code>spatial_index</code> methods, these two methods create new
            indexes on the table.</p>
            
            <h3 id="label-add_constraint"><code>add_constraint</code></h3>
            
            <p>This adds a named constraint to the table, similar to
            <code>create_table</code>‘s <code>constraint</code> method:</p>
            
            <pre>alter_table(:albums) do&#x000A;  add_constraint(:name_min_length){char_length(name) &gt; 2}&#x000A;end</pre>
            
            <p>There is no method to add an unnamed constraint, but you can pass nil as
            the first argument of <code>add_constraint</code> to do so.  However, it’s
            not recommend to do that as it is difficult to drop such a constraint.</p>
            
            <h3 id="label-add_unique_constraint"><code>add_unique_constraint</code></h3>
            
            <p>This adds a unique constraint to the table, similar to
            <code>create_table</code>‘s <code>unique</code> method.  This usually has
            the same effect as adding a unique index.</p>
            
            <pre>alter_table(:albums) do&#x000A;  add_unique_constraint [:artist_id, :name]&#x000A;end</pre>
            
            <h3 id="label-drop_constraint"><code>drop_constraint</code></h3>
            
            <p>This method drops an existing named constraint:</p>
            
            <pre>alter_table(:albums) do&#x000A;  drop_constraint(:name_min_length)&#x000A;end</pre>
            
            <p>There is no database independent method to drop an unnamed constraint. 
            Generally, the database will give it a name automatically, and you will
            have to figure out what it is. For that reason, you should not add unnamed
            constraints that you ever might need to remove.</p>
            
            <p>On some databases, you must specify the type of constraint via a
            <code>:type</code> option:</p>
            
            <pre class="ruby"><span class="ruby-identifier">alter_table</span>(:<span class="ruby-identifier">albums</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">drop_constraint</span>(:<span class="ruby-identifier">albums_pk</span>, :<span class="ruby-identifier">type=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">primary_key</span>)&#x000A;  <span class="ruby-identifier">drop_constraint</span>(:<span class="ruby-identifier">albums_fk</span>, :<span class="ruby-identifier">type=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">foreign_key</span>)&#x000A;  <span class="ruby-identifier">drop_constraint</span>(:<span class="ruby-identifier">albums_uk</span>, :<span class="ruby-identifier">type=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">unique</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-set_column_default"><code>set_column_default</code></h3>
            
            <p>This modifies the default value of a column:</p>
            
            <pre>alter_table(:albums) do&#x000A;  set_column_default :copies_sold, 0&#x000A;end</pre>
            
            <h3 id="label-set_column_type"><code>set_column_type</code></h3>
            
            <p>This modifies a column’s type.  Most databases will attempt to convert
            existing values in the columns to the new type:</p>
            
            <pre>alter_table(:albums) do&#x000A;  set_column_type :copies_sold, Bignum&#x000A;end</pre>
            
            <p>You can specify the type as a string or symbol, in which case it is used
            verbatim, or as a supported ruby class, in which case it gets converted to
            an appropriate database type.</p>
            
            <h3 id="label-set_column_allow_null"><code>set_column_allow_null</code></h3>
            
            <p>This allows you to set the column as allowing NULL values:</p>
            
            <pre>alter_table(:albums) do&#x000A;  set_column_allow_null :artist_id&#x000A;end</pre>
            
            <h3 id="label-set_column_not_null"><code>set_column_not_null</code></h3>
            
            <p>This allows you to set the column as not allowing NULL values:</p>
            
            <pre>alter_table(:albums) do&#x000A;  set_column_not_null :artist_id&#x000A;end</pre>
            
            <h2 id="label-Other+Database+schema+modification+methods">Other <code>Database</code> schema modification methods</h2>
            
            <p><code>Sequel::Database</code> has many schema modification instance
            methods, most of which are shortcuts to the same methods in
            <code>alter_table</code>.  The following <code>Database</code> instance
            methods just call <code>alter_table</code> with a block that calls the
            method with the same name inside the <code>alter_table</code> block with
            all arguments after the first argument (which is used as the table name):</p>
            <ul><li>
            <p><code>add_column</code></p>
            </li><li>
            <p><code>drop_column</code></p>
            </li><li>
            <p><code>rename_column</code></p>
            </li><li>
            <p><code>add_index</code></p>
            </li><li>
            <p><code>drop_index</code></p>
            </li><li>
            <p><code>set_column_default</code></p>
            </li><li>
            <p><code>set_column_type</code></p>
            </li></ul>
            
            <p>For example, the following two method calls do the same thing:</p>
            
            <pre>alter_table(:artists){add_column :copies_sold, Integer}&#x000A;add_column :artists, :copies_sold, Integer</pre>
            
            <p>There are some other schema modification methods that have no
            <code>alter_table</code> counterpart:</p>
            
            <h3 id="label-drop_table"><code>drop_table</code></h3>
            
            <p><code>drop_table</code> takes multiple arguments and treats all arguments
            as a table name to drop:</p>
            
            <pre>drop_table(:albums_artists, :albums, :artists)</pre>
            
            <p>Note that when dropping tables, you may need to drop them in a specific
            order if you are using foreign keys and the database is enforcing
            referential integrity.  In general, you need to drop the tables containing
            the foreign keys before the tables containing the primary keys they
            reference.</p>
            
            <h3 id="label-drop_table%3F"><code>drop_table?</code></h3>
            
            <p><code>drop_table?</code> is similar to drop_table, except that it only
            drops the table if the table already exists.  On some databases, it uses
            <code>IF NOT EXISTS</code>, on others it does a separate query to check for
            existence.</p>
            
            <p>This should not be used inside migrations, as if the table does not exist,
            it may mess up the migration.</p>
            
            <h3 id="label-rename_table"><code>rename_table</code></h3>
            
            <p>You can rename an existing table using <code>rename_table</code>.  Like
            <code>rename_column</code>, the first argument is the current name, and the
            second is the new name:</p>
            
            <pre>rename_table(:artist, :artists)</pre>
            
            <h3 id="label-create_table%21"><code>create_table!</code></h3>
            
            <p><code>create_table!</code> drops the table if it exists before attempting
            to create it, so:</p>
            
            <pre>create_table!(:artists) do&#x000A;  primary_key :id&#x000A;end</pre>
            
            <p>is the same as:</p>
            
            <pre>drop_table?(:artists)&#x000A;create_table(:artists) do&#x000A;  primary_key :id&#x000A;end</pre>
            
            <p>It should not be used inside migrations, as if the table does not exist, it
            may mess up the migration.</p>
            
            <h3 id="label-create_table%3F"><code>create_table?</code></h3>
            
            <p><code>create_table?</code> only creates the table if it does not already
            exist, so:</p>
            
            <pre>create_table?(:artists) do&#x000A;  primary_key :id&#x000A;end</pre>
            
            <p>is the same as:</p>
            
            <pre>unless table_exists?(:artists)&#x000A;  create_table(:artists) do&#x000A;    primary_key :id&#x000A;  end &#x000A;end</pre>
            
            <p>Like <code>create_table!</code>, it should not be used inside migrations.</p>
            
            <h3 id="label-create_view+and+create_or_replace_view"><code>create_view</code> and <code>create_or_replace_view</code></h3>
            
            <p>These can be used to create views.  The difference between them is that
            <code>create_or_replace_view</code> will unconditionally replace an
            existing view of the same name, while <code>create_view</code> will
            probably raise an error.  Both methods take the name as the first argument,
            and either an string or a dataset as the second argument:</p>
            
            <pre>create_view(:gold_albums, DB[:albums].where{copies_sold &gt; 500000})&#x000A;create_or_replace_view(:gold_albums, &quot;SELECT * FROM albums WHERE copies_sold &gt; 500000&quot;)</pre>
            
            <h3 id="label-drop_view"><code>drop_view</code></h3>
            
            <p><code>drop_view</code> drops existing views.  Just like
            <code>drop_table</code>, it can accept multiple arguments:</p>
            
            <pre>drop_view(:gold_albums, :platinum_albums)</pre>
          </div>
          <div id='context'>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
