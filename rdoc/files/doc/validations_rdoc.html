<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>validations.rdoc</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='file' id='wrapper'>
      <div class='header'>
        <h1 class='name'>validations.rdoc</h1>
        <div class='paths'>
          doc/validations.rdoc
        </div>
        <div class='last-update'>
          Last Update:
          <span class='datetime'>2013-11-08 08:08:17 -0500</span>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <h1 id="label-Model+Validations">Model Validations</h1>
            
            <p>This guide is based on <a
            href="http://guides.rubyonrails.org/activerecord_validations_callbacks.html">guides.rubyonrails.org/activerecord_validations_callbacks.html</a></p>
            
            <h2 id="label-Overview">Overview</h2>
            
            <p>This guide is designed to teach you how to use Sequel::Model’s validation
            support.  It attempts to explain how Sequel’s validation support works,
            what validations are useful for, and how to use the
            <code>validation_helpers</code> plugin to add specific types of validations
            to your models.</p>
            
            <h2 id="label-Why+Validations%3F">Why Validations?</h2>
            
            <p>Validations are primarily useful for associating error messages to display
            to the user with specific attributes on the model.  It is also possible to
            use them to enforce data integrity for model instances, but that’s not a
            recommended use unless the only way to modify the database is through model
            instances, or you have complex data integrity requirements that aren’t
            possible to specify via database-level constraints.</p>
            
            <h2 id="label-Data+Integrity">Data Integrity</h2>
            
            <p>Data integrity is best handled by the database itself.  For example, if you
            have a date column that should never contain a NULL value, the column
            should be specified in the database as NOT NULL.  If you have an integer
            column that should only have values from 1 to 10, there should be a CHECK
            constraint that ensures that the value of that column is between 1 and 10. 
            And if you have a varchar column where the length of the entries should be
            between 2 and 255, you should be setting the size of the varchar column to
            255, and using a CHECK constraint to ensure that all values have at least
            two characters.</p>
            
            <p>Unfortunately, sometimes there are situations where that is not possible. 
            For example, if you are using MySQL and don’t have control over the
            database configuration, it’s possible that if you attempt to insert a
            string with 300 characters into a varchar(255) field, then MySQL may just
            silently truncate it for you, instead of raising an error.  In that case,
            it may be necessary to use a model validation to enforce the database
            integrity.</p>
            
            <p>Also, in some cases you may have data integrity requirements that are
            difficult to enforce via database constraints, especially if you are
            targetting multiple database types.</p>
            
            <p>Finally, validations are generally easier to write than database
            constraints, so if data integrity isn’t of great importance, using
            validations to provide minimal data integrity is probably fine.</p>
            
            <h2 id="label-Usage">Usage</h2>
            
            <p>Regardless of whether you are using validations for data integrity or just
            for error messages, the usage is the same.  Whenever you attempt to save a
            model instance, before sending the INSERT or UPDATE query to the database,
            <code>Sequel::Model</code> will attempt to validate the instance by calling
            <code>validate</code>.  If <code>validate</code> does not add any errors to
            the object, the object is considered valid, and <code>valid?</code> will
            return true.  If <code>validate</code> adds any errors to the object,
            <code>valid?</code> will return false, and the save will either raise a
            <code>Sequel::ValidationFailed</code> exception (the default), or return
            nil (if <code>raise_on_save_failure</code> is false).</p>
            
            <p>By validating the object before sending the database query, <a
            href="../../classes/Sequel.html">Sequel</a> attempts to ensure that invalid
            objects are not saved in the database.  However, if you are not enforcing
            the same validations in the database via constraints, it’s possible that
            invalid data can get added to the database via some other method. This
            leads to odd cases such as retrieving a model object from the database, not
            making any changes to it, attempting to save it, and having the save raise
            an error.</p>
            
            <h2 id="label-Skipping+Validations">Skipping Validations</h2>
            
            <p><code>Sequel::Model</code> uses the <code>save</code> method to save model
            objects, and all saving of model objects passes through the
            <code>save</code> method.  This means that all saving of model objects goes
            through the validation process.</p>
            
            <p>The only way to skip validations when saving a model object is to pass the
            <code>:validate =&gt; false</code> option to <code>save</code>. If you use
            that option, <code>save</code> will not attempt to validate the object
            before saving it.</p>
            
            <p>Note that it’s always possible to update the instance’s database row
            without using <code>save</code>, by using a dataset to update it. 
            Validations will only be run if you call <code>save</code> on the model
            object, or another model method that calls <code>save</code>.  For example,
            the <code>create</code> class method instantiates a new instance of the
            model, and then calls <code>save</code>, so it validates the object. 
            However, the <code>insert</code> class method is a dataset method that just
            inserts the raw hash into the database, so it doesn’t validate the object.</p>
            
            <h2 id="label-valid%3F+and+validate"><code>valid?</code> and <code>validate</code></h2>
            
            <p><code>Sequel::Model</code> uses the <code>valid?</code> method to check
            whether or not a model instance is valid.  This method should not be
            overridden.  Instead, the <code>validate</code> method should be overridden
            to add validations to the model:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">validate</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-identifier">errors</span>.<span class="ruby-identifier">add</span>(:<span class="ruby-identifier">name</span>, <span class="ruby-string">'cannot be empty'</span>) <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">name</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">name</span>.<span class="ruby-identifier">empty?</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">valid?</span> <span class="ruby-comment"># false</span>&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">''</span>).<span class="ruby-identifier">valid?</span> <span class="ruby-comment"># false</span>&#x000A;<span class="ruby-constant">Album</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'RF'</span>).<span class="ruby-identifier">valid?</span> <span class="ruby-comment"># true</span></pre>
            
            <p>If the <code>valid?</code> method returns false, you can call the
            <code>errors</code> method to get an instance of
            <code>Sequel::Model::Errors</code> describing the errors on the model:</p>
            
            <pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Album</span>.<span class="ruby-identifier">new</span>&#x000A;<span class="ruby-comment"># =&gt; #&lt;Album @values={}&gt;</span>&#x000A;<span class="ruby-identifier">a</span>.<span class="ruby-identifier">valid?</span>&#x000A;<span class="ruby-comment"># =&gt; false</span>&#x000A;<span class="ruby-identifier">a</span>.<span class="ruby-identifier">errors</span>&#x000A;<span class="ruby-comment"># =&gt; {:name=&gt;[&quot;cannot be empty&quot;]}</span></pre>
            
            <p>You may notice that the <code>errors</code> method appears to return a
            hash.  That’s because <code>Sequel::Model::Errors</code> is a subclass of
            <a href="../../classes/Hash.html">Hash</a>.</p>
            
            <p>Note that calling the <code>errors</code> method before the
            <code>valid?</code> method will result in an <code>errors</code> being
            empty:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">errors</span>&#x000A;<span class="ruby-comment"># =&gt; {}</span></pre>
            
            <p>So just remember that you shouldn’t check <code>errors</code> until after
            you call <code>valid?</code>.</p>
            
            <p><code>Sequel::Model::Errors</code> has some helper methods that make it
            easy to get an array of all of the instance's errors, or for checking for
            errors on a specific attribute.  These will be covered later in this guide.</p>
            
            <h2 id="label-validation_helpers"><code>validation_helpers</code></h2>
            
            <p>While <code>Sequel::Model</code> does provide a validations framework, it
            does not define any built-in validation helper methods that you can call. 
            However, <a href="../../classes/Sequel.html">Sequel</a> ships with a plugin
            called <code>validation_helpers</code> that handles most basic validation
            needs.  So instead of specifying validations like this:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">validate</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-identifier">errors</span>.<span class="ruby-identifier">add</span>(:<span class="ruby-identifier">name</span>, <span class="ruby-string">'cannot be empty'</span>) <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">name</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">name</span>.<span class="ruby-identifier">empty?</span>&#x000A;    <span class="ruby-identifier">errors</span>.<span class="ruby-identifier">add</span>(:<span class="ruby-identifier">name</span>, <span class="ruby-string">'is already taken'</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">name</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">new?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">Album</span>[:<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">name</span>]&#x000A;    <span class="ruby-identifier">errors</span>.<span class="ruby-identifier">add</span>(:<span class="ruby-identifier">website</span>, <span class="ruby-string">'cannot be empty'</span>) <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">website</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">website</span>.<span class="ruby-identifier">empty?</span>&#x000A;    <span class="ruby-identifier">errors</span>.<span class="ruby-identifier">add</span>(:<span class="ruby-identifier">website</span>, <span class="ruby-string">'is not a valid URL'</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">website</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/\Ahttps?:\/\//</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>You can call simple methods such as:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">validation_helpers</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">validate</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-identifier">validates_presence</span> [:<span class="ruby-identifier">name</span>, :<span class="ruby-identifier">website</span>]&#x000A;    <span class="ruby-identifier">validates_unique</span> :<span class="ruby-identifier">name</span>&#x000A;    <span class="ruby-identifier">validates_format</span> <span class="ruby-regexp">/\Ahttps?:\/\//</span>, :<span class="ruby-identifier">website</span>, :<span class="ruby-identifier">message=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'is not a valid URL'</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Other than <code>validates_unique</code>, which has it’s own API, the
            methods defined by <code>validation_helpers</code> have one of the
            following two APIs:</p>
            <dl class="rdoc-list note-list"><dt><code>(atts, opts={})</code>
            <dd>
            <p>For methods such as <code>validates_presence</code>, which do not take an
            additional argument.</p>
            </dd><dt><code>(arg, atts, opts={})</code>
            <dd>
            <p>For methods such as <code>validates_format</code>, which take an additional
            argument.</p>
            </dd></dl>
            
            <p>For both of these APIs, <code>atts</code> is either a column symbol or
            array of column symbols, and <code>opts</code> is an optional options hash.</p>
            
            <p>The following methods are provided by <code>validation_helpers</code>:</p>
            
            <h3 id="label-validates_presence"><code>validates_presence</code></h3>
            
            <p>This is probably the most commonly used helper method, which checks if the
            specified attributes are not blank.  In general, if an object responds to
            <code>blank?</code>, it calls the method to determine if the object is
            blank.  Otherwise, nil is considered blank, empty strings or strings that
            just contain whitespace are blank, and objects that respond to
            <code>empty?</code> and return true are considered blank.  All other
            objects are considered non-blank for the purposes of
            <code>validates_presence</code>.  This means that
            <code>validates_presence</code> is safe to use on boolean columns where you
            want to ensure that either true or false is used, but not NULL.</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">validate</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-identifier">validates_presence</span> [:<span class="ruby-identifier">name</span>, :<span class="ruby-identifier">website</span>, :<span class="ruby-identifier">debut_album</span>]&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-validates_not_null"><code>validates_not_null</code></h3>
            
            <p>This is similar to <code>validates_presence</code>, but only checks for
            NULL/nil values, allowing other blank objects such as empty strings or
            strings with just whitespace.</p>
            
            <h3 id="label-validates_format"><code>validates_format</code></h3>
            
            <p><code>validates_format</code> is used to ensure that the string value of
            the specified attributes matches the specified regular expression.  It's
            useful for checking that fields such as email addresses, URLs, UPC codes,
            ISBN codes, and the like, are in a specific format.  It can also be used to
            validate that only certain characters are used in the string.</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">validate</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-identifier">validates_format</span> <span class="ruby-regexp">/\A\d\d\d-\d-\d{7}-\d-\d\z/</span>, :<span class="ruby-identifier">isbn</span>&#x000A;    <span class="ruby-identifier">validates_format</span> <span class="ruby-regexp">/\a[0-9a-zA-Z:' ]+\z/</span>, :<span class="ruby-identifier">name</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-validates_exact_length%2C+validates_min_length%2C+validates_max_length%2C+validates_length_range"><code>validates_exact_length</code>, <code>validates_min_length</code>, <code>validates_max_length</code>, <code>validates_length_range</code></h3>
            
            <p>These methods all deal with ensuring that the length of the specified
            attribute matches the criteria specified by the first argument to the
            method.  <code>validates_exact_length</code> is for checking that the
            length of the attribute is equal to that value,
            <code>validates_min_length</code> is for checking that the length of the
            attribute is greater than or equal to that value,
            <code>validates_max_length</code> is for checking that the length of the
            attribute is less than or equal to that value, and
            <code>validates_length_range</code> is for checking that the length of the
            attribute falls in the value, which should be a range or another object
            that responds to <code>include?</code>.</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">validate</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-identifier">validates_exact_length</span> <span class="ruby-value">17</span>, :<span class="ruby-identifier">isbn</span>&#x000A;    <span class="ruby-identifier">validates_min_length</span> <span class="ruby-value">3</span>, :<span class="ruby-identifier">name</span>&#x000A;    <span class="ruby-identifier">validates_max_length</span> <span class="ruby-value">100</span>, :<span class="ruby-identifier">name</span>&#x000A;    <span class="ruby-identifier">validates_length_range</span> <span class="ruby-value">3</span><span class="ruby-operator">..</span><span class="ruby-value">100</span>, :<span class="ruby-identifier">name</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-validates_integer%2C+validates_numeric"><code>validates_integer</code>, <code>validates_numeric</code></h3>
            
            <p>These methods check that the specified attributes can be valid integers or
            valid floats.  <code>validates_integer</code> tests the attribute value
            using <code>Kernel.Integer</code> and <code>validates_numeric</code> tests
            the attribute using <code>Kernel.Float</code>.  If the Kernel methods raise
            an exception, the validation fails, otherwise it succeeds.</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">validate</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-identifier">validates_integer</span> :<span class="ruby-identifier">copies_sold</span>&#x000A;    <span class="ruby-identifier">validates_numeric</span> :<span class="ruby-identifier">replaygain</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-validates_includes"><code>validates_includes</code></h3>
            
            <p><code>validates_includes</code> checks that the specified attributes are
            included in the first argument to the method, which is usually an array,
            but can be any object that responds to <code>include?</code>.</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">validate</span>&#x000A;    <span class="ruby-identifier">validates_includes</span> [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>], :<span class="ruby-identifier">rating</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-validates_type"><code>validates_type</code></h3>
            
            <p><code>validates_type</code> checks that the specified attributes are
            instances of the class specified in the first argument.  The class can be
            specified as the class itself, or as a string or symbol with the class
            name, or as a an array of classes.</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">validate</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-identifier">validates_type</span> <span class="ruby-constant">String</span>, [:<span class="ruby-identifier">name</span>, :<span class="ruby-identifier">website</span>]&#x000A;    <span class="ruby-identifier">validates_type</span> :<span class="ruby-constant">Artist</span>, :<span class="ruby-identifier">artist</span>&#x000A;    <span class="ruby-identifier">validates_type</span> [<span class="ruby-constant">String</span>, <span class="ruby-constant">Integer</span>], :<span class="ruby-identifier">foo</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-validates_schema_types"><code>validates_schema_types</code></h3>
            
            <p><code>validates_schema_types</code> uses the database metadata for the
            model's table to determine which ruby type(s) should be used for the given
            database type, and calls <code>validates_type</code> with that ruby type. 
            It's designed to be used with the <code>raise_on_typecast_failure =&#x000A;false</code> setting (the default starting in <a
            href="../../classes/Sequel.html">Sequel</a> 4). 
            &lt;tt&gt;raise_on_typecast_failure = false&lt;/tt, <a
            href="../../classes/Sequel.html">Sequel</a> attempts to typecast values,
            but silently ignores any errors raised:</p>
            
            <pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">raise_on_typecast_failure</span> = <span class="ruby-keyword">false</span>&#x000A;<span class="ruby-identifier">album</span> = <span class="ruby-constant">Album</span>.<span class="ruby-identifier">new</span>&#x000A;<span class="ruby-identifier">album</span>.<span class="ruby-identifier">copies_sold</span> = <span class="ruby-string">'banana'</span>&#x000A;<span class="ruby-identifier">album</span>.<span class="ruby-identifier">copies_sold</span> <span class="ruby-comment"># =&gt; 'banana'</span></pre>
            
            <p>When <code>raise_on_typecast_failure = false</code>, you can call
            <code>validates_schema_types</code> with all columns.  If any of those
            columns has a value that doesn’t match the type that <a
            href="../../classes/Sequel.html">Sequel</a> expects, it’s probably because
            the column was set and <a href="../../classes/Sequel.html">Sequel</a> was
            not able to typecast it correctly, which means it probably isn’t valid. 
            For example, let’s say that you want to check that a couple of columns
            contain valid dates:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">raise_on_typecast_failure</span> = <span class="ruby-keyword">false</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">validate</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-identifier">validates_schema_types</span> [:<span class="ruby-identifier">release_date</span>, :<span class="ruby-identifier">record_date</span>]&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-identifier">album</span> = <span class="ruby-constant">Album</span>.<span class="ruby-identifier">new</span>&#x000A;<span class="ruby-identifier">album</span>.<span class="ruby-identifier">release_date</span> = <span class="ruby-string">'banana'</span>&#x000A;<span class="ruby-identifier">album</span>.<span class="ruby-identifier">release_date</span> <span class="ruby-comment"># =&gt; 'banana'</span>&#x000A;<span class="ruby-identifier">album</span>.<span class="ruby-identifier">record_date</span> = <span class="ruby-string">'2010-05-17'</span>&#x000A;<span class="ruby-identifier">album</span>.<span class="ruby-identifier">record_date</span> <span class="ruby-comment"># =&gt; #&lt;Date: 4910667/2,0,2299161&gt;</span>&#x000A;<span class="ruby-identifier">album</span>.<span class="ruby-identifier">valid?</span> <span class="ruby-comment"># =&gt; false</span>&#x000A;<span class="ruby-identifier">album</span>.<span class="ruby-identifier">errors</span> <span class="ruby-comment"># =&gt; {:release_date=&gt;[&quot;is not a valid date&quot;]}</span></pre>
            
            <p>For web applications, you usually want the <code>raise_on_typecast_failure&#x000A;= false</code> setting, so that you can accept all of the input without
            raising an error, and then present the user with all error messages. 
            Without the setting, if the user submits any invalid data, <a
            href="../../classes/Sequel.html">Sequel</a> will immediately raise an
            error.  <code>validates_schema_types</code> is helpful because it allows
            you to check for typecasting errors on columns, and provides a good default
            error message stating that the attribute is not of the expected type.</p>
            
            <h3 id="label-validates_unique"><code>validates_unique</code></h3>
            
            <p><code>validates_unique</code> has a similar but different API than the
            other <code>validation_helpers</code> methods.  It takes an arbitrary
            number of arguments, which should be column symbols or arrays of column
            symbols.  If any argument is a symbol, <a
            href="../../classes/Sequel.html">Sequel</a> sets up a unique validation for
            just that column.  If any argument is an array of symbols, <a
            href="../../classes/Sequel.html">Sequel</a> sets up a unique validation for
            the combination of the columns.  This means that you get different behavior
            depending on whether you call the object with an array or with separate
            arguments.  For example:</p>
            
            <pre>validates_unique(:name, :artist_id)</pre>
            
            <p>Will set up a 2 separate uniqueness validations.  It will make it so that
            no two albums can have the same name, and that each artist can only be
            associated with one album.  In general, that’s probably not what you want. 
            You probably want it so that two albums can have the same name, unless they
            are by the same artist.  To do that, you need to use an array:</p>
            
            <pre>validates_unique([:name, :artist_id])</pre>
            
            <p>That sets up a single uniqueness validation for the combination of the
            fields.</p>
            
            <p>You can mix and match the two approaches.  For example, if all albums
            should have a unique UPC, and no artist can have duplicate album names:</p>
            
            <pre>validates_unique(:upc, [:name, :artist_id])</pre>
            
            <p><code>validates_unique</code> also accepts a block to scope the uniqueness
            constraint.  For example, if you want to ensure that all active albums have
            a unique name, but inactive albums can duplicate the name:</p>
            
            <pre class="ruby"><span class="ruby-identifier">validates_unique</span>(:<span class="ruby-identifier">name</span>){<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>(:<span class="ruby-identifier">active</span>)}</pre>
            
            <p>If you provide a block, it is called with the dataset to use for the
            uniqueness check, which you can then filter to scope the uniqueness
            validation to a subset of the model’s dataset.</p>
            
            <p>Additionally, you can also include an optional options hash as the last
            argument.  Unlike the other validations, the options hash for
            <code>validates_unique</code> only checks for two options:</p>
            <dl class="rdoc-list note-list"><dt>:message 
            <dd>
            <p>The message to use</p>
            </dd><dt>:only_if_modified 
            <dd>
            <p>Only check the uniqueness if the object is new or one of the columns has
            been modified.</p>
            </dd></dl>
            
            <p><code>validates_unique</code> is the only method in
            <code>validation_helpers</code> that checks with the database.  Attempting
            to validate uniqueness outside of the database suffers from a race
            condition, so any time you want to add a uniqueness validation, you should
            make sure to add a uniqueness constraint or unique index on the underlying
            database table.  See the <a href="migration_rdoc.html">"Migrations and
            Schema Modification" guide</a> for details on how to do that.</p>
            
            <h2 id="label-validation_helpers+Options"><code>validation_helpers</code> Options</h2>
            
            <p>All <code>validation_helpers</code> methods except
            <code>validates_unique</code> accept the following options:</p>
            
            <h3 id="label-%3Amessage"><code>:message</code></h3>
            
            <p>The most commonly used option, used to override the default validation
            message.  Can be either a string or a proc.  If a string, it is used
            directly.  If a proc, the proc is called and should return a string.  If
            the validation method takes an argument before the array of attributes,
            that argument is passed as an argument to the proc. The exception is the
            <code>validates_not_string</code> method, which doesn’t take an argument,
            but passes the schema type symbol as the argument to the proc.</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">validate</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-identifier">validates_presence</span> :<span class="ruby-identifier">copies_sold</span>, :<span class="ruby-identifier">message=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'was not given'</span>&#x000A;    <span class="ruby-identifier">validates_min_length</span> <span class="ruby-value">3</span>, :<span class="ruby-identifier">name</span>, :<span class="ruby-identifier">message=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;should be more than #{s} characters&quot;</span>}&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-%3Aallow_nil"><code>:allow_nil</code></h3>
            
            <p>The <code>:allow_nil</code> option skips the validation if the attribute
            value is nil or if the attribute is not present.  It’s commonly used when
            you have a <code>validates_presence</code> method already on the attribute,
            and don’t want multiple validation errors for the same attribute:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">validate</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-identifier">validates_presence</span> :<span class="ruby-identifier">copies_sold</span>&#x000A;    <span class="ruby-identifier">validates_integer</span> :<span class="ruby-identifier">copies_sold</span>, :<span class="ruby-identifier">allow_nil=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Without the <code>:allow_nil</code> option to
            <code>validates_integer</code>, if the copies_sold attribute was nil, you
            would get two separate validation errors, instead of a single validation
            error.</p>
            
            <h3 id="label-%3Aallow_blank"><code>:allow_blank</code></h3>
            
            <p>The <code>:allow_blank</code> is similar to the <code>:allow_nil</code>
            option, but instead of just skipping the attribute for nil values, it skips
            the attribute for all blank values.  For example, let’s say that artists
            can have a website.  If they have one, it should be formatted like a URL,
            but it can be nil or an empty string if they don’t have one.</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">validate</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-identifier">validates_format</span> <span class="ruby-regexp">/\Ahttps?:\/\//</span>, :<span class="ruby-identifier">website</span>, :<span class="ruby-identifier">allow_blank=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-identifier">a</span> = <span class="ruby-constant">Album</span>.<span class="ruby-identifier">new</span>&#x000A;<span class="ruby-identifier">a</span>.<span class="ruby-identifier">website</span> = <span class="ruby-string">''</span>&#x000A;<span class="ruby-identifier">a</span>.<span class="ruby-identifier">valid?</span> <span class="ruby-comment"># true</span></pre>
            
            <h3 id="label-%3Aallow_missing"><code>:allow_missing</code></h3>
            
            <p>The <code>:allow_missing</code> option is different from the
            <code>:allow_nil</code> option, in that instead of checking if the
            attribute value is nil, it checks if the attribute is present in the model
            instance’s values hash.   <code>:allow_nil</code> will skip the validation
            when the attribute is in the values hash and has a nil value and when the
            attribute is not in the values hash.  <code>:allow_missing</code> will only
            skip the validation when the attribute is not in the values hash.  If the
            attribute is in the values hash but has a nil value,
            <code>:allow_missing</code> will not skip it.</p>
            
            <p>The purpose of this option is to work correctly with missing columns when
            inserting or updating records.  <a
            href="../../classes/Sequel.html">Sequel</a> only sends the attributes in
            the values hash when doing an insert or update. If the attribute is not
            present in the values hash, <a href="../../classes/Sequel.html">Sequel</a>
            doesn’t specify it, so the database will use the table’s default value when
            inserting the record, or not modify the value when saving it. This is
            different from having an attribute in the values hash with a value of nil,
            which <a href="../../classes/Sequel.html">Sequel</a> will send as NULL. If
            your database table has a non NULL default, this may be a good option to
            use. You don’t want to use allow_nil, because if the attribute is in values
            but has a value nil, <a href="../../classes/Sequel.html">Sequel</a> will
            attempt to insert a NULL value into the database, instead of using the
            database’s default.</p>
            
            <h2 id="label-Conditional+Validation">Conditional Validation</h2>
            
            <p>Because <a href="../../classes/Sequel.html">Sequel</a> uses the
            <code>validate</code> instance method to handle validation, making
            validations conditional is easy as it works exactly the same as ruby’s
            standard conditionals.  For example, if you only want to validate an
            attribute when creating an object:</p>
            
            <pre>validates_presence :name if new?</pre>
            
            <p>If you only want to validate the attribute when updating an existing
            object:</p>
            
            <pre>validates_integer :copies_sold unless new?</pre>
            
            <p>Let’s say you only to make a validation conditional on the status of the
            object:</p>
            
            <pre>validates_presence :name if status_id &gt; 1&#x000A;validates_integer :copies_sold if status_id &gt; 3</pre>
            
            <p>You can use all the standard ruby conditional expressions, such as
            <code>case</code>:</p>
            
            <pre>case status_id&#x000A;when 1&#x000A;  validates_presence :name&#x000A;when 2&#x000A;  validates_presence [:name, :artist_id]&#x000A;when 3&#x000A;  validates_presence [:name, :artist_id, :copies_sold]&#x000A;end</pre>
            
            <p>You can make the input to some validations dependent on the values of
            another attribute:</p>
            
            <pre>validates_min_length(status_id &gt; 2 ? 5 : 10, [:name])&#x000A;validates_presence(status_id &lt; 2 ? :name : [:name, :artist_id])</pre>
            
            <p>Basically, there’s no special syntax you have to use for conditional
            validations.  Just handle conditionals the way you would in other ruby
            code.</p>
            
            <h2 id="label-Default+Error+Messages">Default Error Messages</h2>
            
            <p>These are the default error messages for all of the helper methods in
            <code>validation_helpers</code>:</p>
            <dl class="rdoc-list note-list"><dt>:exact_length 
            <dd>
            <p>is not #{arg} characters</p>
            </dd><dt>:format 
            <dd>
            <p>is invalid</p>
            </dd><dt>:includes 
            <dd>
            <p>is not in range or set: #{arg.inspect}</p>
            </dd><dt>:integer 
            <dd>
            <p>is not a number</p>
            </dd><dt>:length_range 
            <dd>
            <p>is too short or too long</p>
            </dd><dt>:max_length 
            <dd>
            <p>is longer than #{arg} characters</p>
            </dd><dt>:min_length 
            <dd>
            <p>is shorter than #{arg} characters</p>
            </dd><dt>:not_null 
            <dd>
            <p>is not present</p>
            </dd><dt>:numeric 
            <dd>
            <p>is not a number</p>
            </dd><dt>:schema_types 
            <dd>
            <p>is not a valid #{schema_type}</p>
            </dd><dt>:type 
            <dd>
            <p>is not a #{arg}</p>
            </dd><dt>:presence 
            <dd>
            <p>is not present</p>
            </dd><dt>:unique 
            <dd>
            <p>is already taken</p>
            </dd></dl>
            
            <h2 id="label-Modifying+the+Default+Options">Modifying the Default Options</h2>
            
            <p>It’s easy to modify the default options used by
            <code>validation_helpers</code>.  All of the default options are stored in
            the <code>Sequel::Plugins::ValidationHelpers::DEFAULT_OPTIONS</code> hash. 
            So you just need to modify that hash to change the default options.  One
            way to do that is to use <code>merge!</code> to update the hash:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Plugins</span><span class="ruby-operator">::</span><span class="ruby-constant">ValidationHelpers</span><span class="ruby-operator">::</span><span class="ruby-constant">DEFAULT_OPTIONS</span>.<span class="ruby-identifier">merge!</span>(&#x000A; :<span class="ruby-identifier">presence=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">message=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'cannot be empty'</span>},&#x000A; :<span class="ruby-identifier">includes=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">message=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'invalid option'</span>, :<span class="ruby-identifier">allow_nil=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>},&#x000A; :<span class="ruby-identifier">max_length=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">message=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">lambda</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;cannot be more than #{i} characters&quot;</span>}, :<span class="ruby-identifier">allow_nil=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>},&#x000A; :<span class="ruby-identifier">format=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">message=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">'contains invalid characters'</span>, :<span class="ruby-identifier">allow_nil=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>})</pre>
            
            <p>This updates the default messages that will be used for the presence,
            includes, max_length, and format validations, and sets the default value of
            the <code>:allow_nil</code> option to true for the includes, max_length,
            and format validations.</p>
            
            <p>You can also override
            <code>Sequel::Model#default_validation_helpers_options</code> private
            method to override these settings on a per-model or even per-instance
            basis.</p>
            
            <h2 id="label-Custom+Validations">Custom Validations</h2>
            
            <p>Just as the first validation example showed, you aren’t limited to the
            validation methods defined by <code>validation_helpers</code>.  Inside the
            <code>validate</code> method, you can add your own validations by adding to
            the instance’s errors using <code>errors.add</code> whenever an attribute
            is not valid:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">validate</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-identifier">errors</span>.<span class="ruby-identifier">add</span>(:<span class="ruby-identifier">release_date</span>, <span class="ruby-string">'cannot be before record date'</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">release_date</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">record_date</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Just like conditional validations, with custom validations you are just
            using the standard ruby conditionals, and calling <code>errors.add</code>
            with the column symbol and the error message if you detect invalid data.</p>
            
            <p>It’s fairly easy to create your own custom validations that can be reused
            in all your models.  For example, if there is a common need to validate
            that one column in the model comes before another column:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">validates_after</span>(<span class="ruby-identifier">col1</span>, <span class="ruby-identifier">col2</span>)&#x000A;    <span class="ruby-identifier">errors</span>.<span class="ruby-identifier">add</span>(<span class="ruby-identifier">col1</span>, <span class="ruby-node">&quot;cannot be before #{col2}&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">send</span>(<span class="ruby-identifier">col1</span>) <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">send</span>(<span class="ruby-identifier">col2</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">validate</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-identifier">validates_after</span>(:<span class="ruby-identifier">release_date</span>, :<span class="ruby-identifier">record_date</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="label-Setting+Validations+for+All+Models">Setting Validations for All Models</h2>
            
            <p>Let’s say you want to add some default validations that apply to all of
            your model classes.  It’s fairly easy to do by overriding the
            <code>validate</code> method in <code>Sequel::Model</code>, adding some
            validations to it, and if you override <code>validate</code> in your model
            classes, just make sure to call <code>super</code>.</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">string_columns</span>&#x000A;    <span class="ruby-ivar">@string_columns</span> <span class="ruby-operator">||=</span> <span class="ruby-identifier">columns</span>.<span class="ruby-identifier">reject</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-identifier">db_schema</span>[<span class="ruby-identifier">c</span>][:<span class="ruby-identifier">type</span>] <span class="ruby-operator">!=</span> :<span class="ruby-identifier">string</span>}&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">validate</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-identifier">validates_format</span>(<span class="ruby-regexp">/\A[^\x00-\x08\x0e-\x1f\x7f\x81\x8d\x8f\x90\x9d]*\z/</span>,&#x000A;     <span class="ruby-identifier">model</span>.<span class="ruby-identifier">string_columns</span>,&#x000A;     :<span class="ruby-identifier">message=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;contains invalid characters&quot;</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>This will make sure that all string columns in the model are validated to
            make sure they don’t contain any invalid characters.  Just remember that if
            you override the <code>validate</code> method in your model classes, you
            need to call <code>super</code>:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">validate</span>&#x000A;    <span class="ruby-keyword">super</span> <span class="ruby-comment"># Important!</span>&#x000A;    <span class="ruby-identifier">validates_presence</span> :<span class="ruby-identifier">name</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>If you forget to call <code>super</code>, the validations that you defined
            in <code>Sequel::Model</code> will not be enforced.  It’s a good idea to
            call super whenever you override one of <code>Sequel::Model</code>‘s
            methods, unless you specifically do not want the default behavior.</p>
            
            <h2 id="label-Sequel%3A%3AModel%3A%3AErrors"><code>Sequel::Model::Errors</code></h2>
            
            <p>‘ As mentioned earlier, <code>Sequel::Model::Errors</code> is a subclass of
            <a href="../../classes/Hash.html">Hash</a> with a few special methods, the
            most common of which are described here:</p>
            
            <h3 id="label-add"><code>add</code></h3>
            
            <p><code>add</code> is the method used to add error messages for a given
            column.  It takes the column symbol as the first argument and the error
            message as the second argument:</p>
            
            <pre>errors.add(:name, 'is not valid')</pre>
            
            <h3 id="label-on"><code>on</code></h3>
            
            <p><code>on</code> is a method usually used after validation has been
            completed, to determine if there were any errors on a given attribute.  It
            takes the column value, and returns an array of error messages if there
            were any, or nil if not:</p>
            
            <pre>errors.on(:name)</pre>
            
            <p>If you want to make some validations dependent upon the results of other
            validations, you may want to use <code>on</code> inside your validates
            method:</p>
            
            <pre>validates_integer(:release_date) if errors.on(:record_date)</pre>
            
            <p>Here, you don’t care about validating the release date if there were
            validation errors for the record date.</p>
            
            <h3 id="label-full_messages"><code>full_messages</code></h3>
            
            <p><code>full_messages</code> returns an array of error messages for the
            object.  It's commonly called after validation to get a list of error
            messages to display to the user:</p>
            
            <pre class="ruby"><span class="ruby-identifier">album</span>.<span class="ruby-identifier">errors</span>&#x000A;<span class="ruby-comment"># =&gt; {:name=&gt;[&quot;cannot be empty&quot;]}</span>&#x000A;<span class="ruby-identifier">album</span>.<span class="ruby-identifier">errors</span>.<span class="ruby-identifier">full_messages</span>&#x000A;<span class="ruby-comment"># =&gt; [&quot;name cannot be empty&quot;]</span></pre>
            
            <h3 id="label-count"><code>count</code></h3>
            
            <p><code>count</code> returns the total number of error messages in the
            errors.</p>
            
            <pre class="ruby"><span class="ruby-identifier">album</span>.<span class="ruby-identifier">errors</span>.<span class="ruby-identifier">count</span> <span class="ruby-comment"># =&gt; 1</span></pre>
            
            <h2 id="label-Other+Validation+Plugins">Other Validation Plugins</h2>
            
            <h3 id="label-constraint_validations"><code>constraint_validations</code></h3>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> ships with a
            <code>constraint_validations</code> plugin and extension, that allows you
            to setup constraints when creating your database tables, and have Model
            validations automatically created that mirror those constraints.</p>
            
            <h3 id="label-auto_validations"><code>auto_validations</code></h3>
            
            <p>Autovalidations uses the not null and type information obtained from
            parsing the database schema, and the unique index information from parsing
            the database’s index information, and automatically setting up not_null,
            schema_types, and unique validations.  If you don’t require customizing
            validation messages on a per-column basis, it can DRY up a lot of
            validation code.</p>
            
            <h3 id="label-validation_class_methods"><code>validation_class_methods</code></h3>
            
            <p><a href="../../classes/Sequel.html">Sequel</a> ships with the
            <code>validation_class_methods</code> plugin, which uses class methods
            instead of instance methods to define validations.  It exists mostly for
            legacy compatibility, but it is still supported.</p>
          </div>
          <div id='context'>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
