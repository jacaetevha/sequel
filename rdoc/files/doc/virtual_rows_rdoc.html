<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>virtual_rows.rdoc</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='file' id='wrapper'>
      <div class='header'>
        <h1 class='name'>virtual_rows.rdoc</h1>
        <div class='paths'>
          doc/virtual_rows.rdoc
        </div>
        <div class='last-update'>
          Last Update:
          <span class='datetime'>2013-11-08 08:08:17 -0500</span>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <h1 id="label-Virtual+Row+Blocks">Virtual Row Blocks</h1>
            
            <p>Dataset methods where, order, and select all take blocks that are referred
            to as virtual row blocks.  Many other dataset methods pass the blocks they
            are given into one of those three methods, so there are actually many <a
            href="../../classes/Sequel/Dataset.html">Sequel::Dataset</a> methods that
            take virtual row blocks.</p>
            
            <h2 id="label-Why+Virtual+Rows">Why Virtual Rows</h2>
            
            <p>Virtual Rows were created to work around the issue that some parts of
            Sequel’s standard DSL could not be used on ruby 1.9.  For example, the
            following <a href="../../classes/Sequel.html">Sequel</a> code historically
            worked on ruby 1.8, but not ruby 1.9:</p>
            
            <pre>dataset.where(:a &gt; :b[:c])&#x000A;# WHERE a &gt; b(c)</pre>
            
            <p>This code does not work on ruby 1.9 for two reasons.  First, Symbol#&gt;
            (like other inequality methods) is already defined in ruby 1.9, so <a
            href="../../classes/Sequel.html">Sequel</a> does not override it to return
            an SQL inequality expression.  Second, Symbol#[] is already defined on ruby
            1.9, so <a href="../../classes/Sequel.html">Sequel</a> does not override it
            to return an SQL function expression.</p>
            
            <p>It’s possible to use Sequel’s DSL to represent such expressions, but it is
            a little verbose:</p>
            
            <pre>dataset.where(Sequel.expr(:a) &gt; Sequel.function(:b, :c))&#x000A;# WHERE a &gt; b(c)</pre>
            
            <p>The virtual row DSL makes such code more concise:</p>
            
            <pre>dataset.where{a &gt; b(c)}</pre>
            
            <h2 id="label-Regular+Procs+vs+Instance+Evaled+Procs">Regular Procs vs Instance Evaled Procs</h2>
            
            <p>Virtual row blocks behave differently depending on whether the block
            accepts an argument.  If the block accepts an argument, it is called with
            an instance of <a
            href="../../classes/Sequel/SQL/VirtualRow.html">Sequel::SQL::VirtualRow</a>.
            If it does not accept an argument, it is evaluated in the context of an
            instance of <a
            href="../../classes/Sequel/SQL/VirtualRow.html">Sequel::SQL::VirtualRow</a>.</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span> = <span class="ruby-constant">DB</span>[:<span class="ruby-identifier">items</span>]&#x000A;<span class="ruby-comment"># Regular proc</span>&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">column</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}&#x000A;<span class="ruby-comment"># WHERE column &gt; 1</span>&#x000A;&#x000A;<span class="ruby-comment"># Instance-evaled proc</span>&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">column</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}&#x000A;<span class="ruby-comment"># WHERE column &gt; 1</span></pre>
            
            <p>If you aren’t familiar with the difference between regular blocks and
            instance evaled blocks, you should probably consult a general ruby
            reference, but briefly, with regular procs, methods called without an
            explicit receiver inside the proc call the method on the receiver in the
            surrounding scope, while instance evaled procs call the method on the
            receiver of the instance_eval call.  However, in both cases, local
            variables available in the surrounding scope will be available inside the
            proc.  If that doesn’t make sense, maybe this example will help:</p>
            
            <pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">a</span>&#x000A;  <span class="ruby-value">42</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-identifier">b</span> = <span class="ruby-value">32</span>&#x000A;&#x000A;<span class="ruby-comment"># Regular proc</span>&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">c</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">b</span>}&#x000A;<span class="ruby-comment"># WHERE c &gt; 10</span>&#x000A;&#x000A;<span class="ruby-comment"># Instance-evaled proc</span>&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">c</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">b</span>}&#x000A;<span class="ruby-comment"># WHERE c &gt; (a - 32)</span></pre>
            
            <p>There are two related differences here.  First is the usage of
            <code>o.c</code> vs <code>c</code>, and second is the difference between
            the use of <code>a</code>.  In the regular proc, you couldn’t call
            <code>c</code> without an explicit receiver in the proc, unless the self of
            the surrounding scope responded to it.  For <code>a</code>, note how ruby
            calls the method on the receiver of the surrounding scope in the regular
            proc, which returns an integer, and does the subtraction before <a
            href="../../classes/Sequel.html">Sequel</a> gets access to it.  In the
            instance evaled proc, calling <code>a</code> without a receiver calls the a
            method on the VirtualRow instance. For <code>b</code>, note that it
            operates the same in both cases, as it is a local variable.</p>
            
            <p>Basically, the choice for whether to use a regular proc or an instance
            evaled proc is completely up to you.  The same things can be accomplished
            with both. Instance evaled procs tend to produce shorter code, but by
            modifying the scope can be more difficult for a new user to understand. 
            That being said, I usually use instance evaled procs unless I need to call
            methods on the receiver of the surrounding scope inside the proc.</p>
            
            <h2 id="label-Local+Variables+vs+Method+Calls">Local Variables vs Method Calls</h2>
            
            <p>If you have a method that accepts 0 arguments and has the same name as a
            local variable, you can call it with () to differentiate the method call
            from the local variable access.  This is mostly useful in instance_evaled
            procs:</p>
            
            <pre>b = 32&#x000A;ds.where{b() &gt; b}&#x000A;# WHERE b &gt; 32</pre>
            
            <h2 id="label-VirtualRow+Methods">VirtualRow Methods</h2>
            
            <p>VirtualRow is a class that returns SQL::Identifiers,
            SQL::QualifiedIdentifiers, SQL::Functions, or SQL::WindowFunctions
            depending on how it is called.</p>
            
            <h2 id="label-SQL%3A%3AIdentifiers+-+Regular+columns">SQL::Identifiers - Regular columns</h2>
            
            <p>SQL::Identifiers can be thought of as regular column references in SQL, not
            qualified by any table. You get an SQL::Identifier if the method is called
            without a block or arguments, and doesn’t have a double underscore in the
            method name:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">column</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">column</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}&#x000A;<span class="ruby-comment"># WHERE column &gt; 1</span></pre>
            
            <h2 id="label-SQL%3A%3AQualifiedIdentifiers+-+Qualified+columns">SQL::QualifiedIdentifiers - Qualified columns</h2>
            
            <p>SQL::QualifiedIdentifiers can be thought of as column references in SQL
            that are qualified to a specific table.  You get an
            SQL::QualifiedIdentifier if the method is called without a block or
            arguments, and has a double underscore in the method name:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">table__column</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">table__column</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}&#x000A;<span class="ruby-comment"># WHERE table.column &gt; 1</span></pre>
            
            <p>Using the double underscore for SQL::QualifiedIdentifiers was done to make
            usage very similar to using symbols, which also translate the double
            underscore into a qualified column.</p>
            
            <h2 id="label-SQL%3A%3AFunctions+-+SQL+function+calls">SQL::Functions - SQL function calls</h2>
            
            <p>SQL::Functions can be thought of as function calls in SQL.  You get a
            simple function call if you call a method with arguments and without a
            block:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">function</span>(<span class="ruby-value">1</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">function</span>(<span class="ruby-value">1</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}&#x000A;<span class="ruby-comment"># WHERE function(1) &gt; 1</span></pre>
            
            <p>To call a SQL function with multiple arguments, just use those arguments in
            your function call:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">function</span>(<span class="ruby-value">1</span>, <span class="ruby-identifier">o</span>.<span class="ruby-identifier">a</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">function</span>(<span class="ruby-value">1</span>, <span class="ruby-identifier">a</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}&#x000A;<span class="ruby-comment"># WHERE function(1, a) &gt; 1</span></pre>
            
            <p>If the SQL function does not accept any arguments, you need to provide an
            empty block to the method to distinguish it from a call that will produce
            an SQL::Identifier:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">version</span>{}}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-identifier">version</span>{}}&#x000A;<span class="ruby-comment"># SELECT version()</span></pre>
            
            <p>To use the SQL wildcard (*) as the sole argument in a function call (most
            often used with the count function), you should provide :* as the sole
            argument to the method, and provide an empty block to the method:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">count</span>(:*){}}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-identifier">count</span>(:*){}}&#x000A;<span class="ruby-comment"># SELECT count(*)</span></pre>
            
            <p>To append the DISTINCT keyword before the method arguments, you need to
            make :distinct the first argument of the method call, and provide an empty
            block to the method:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">count</span>(:<span class="ruby-identifier">distinct</span>, <span class="ruby-identifier">o</span>.<span class="ruby-identifier">col1</span>){}}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-identifier">count</span>(:<span class="ruby-identifier">distinct</span>, <span class="ruby-identifier">col1</span>){}}&#x000A;<span class="ruby-comment"># SELECT count(DISTINCT col1)</span></pre>
            
            <p>To use multiple columns with the DISTINCT keyword, use multiple arguments
            in the method call:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">count</span>(:<span class="ruby-identifier">distinct</span>, <span class="ruby-identifier">o</span>.<span class="ruby-identifier">col1</span>, <span class="ruby-identifier">o</span>.<span class="ruby-identifier">col2</span>){}}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-identifier">count</span>(:<span class="ruby-identifier">distinct</span>, <span class="ruby-identifier">col1</span>, <span class="ruby-identifier">col2</span>){}}&#x000A;<span class="ruby-comment"># SELECT count(DISTINCT col1, col2)</span></pre>
            
            <h2 id="label-SQL%3A%3AWindowFunctions+-+SQL+window+function+calls">SQL::WindowFunctions - SQL window function calls</h2>
            
            <p>SQL::WindowFunctions can be thought of as calls to SQL window functions. 
            Not all databases support them, but they are very helpful for certain types
            of queries.  To use them, you need to make :over the first argument of the
            method call, with an optional hash as the second argument, and provide an
            empty block to the method. Here are some examples of use:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">rank</span>(:<span class="ruby-identifier">over</span>){}}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-identifier">rank</span>(:<span class="ruby-identifier">over</span>){}}&#x000A;<span class="ruby-comment"># SELECT rank() OVER ()</span>&#x000A;&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">count</span>(:<span class="ruby-identifier">over</span>, :<span class="ruby-operator">*=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>){}}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-identifier">count</span>(:<span class="ruby-identifier">over</span>, :<span class="ruby-operator">*=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>){}}&#x000A;<span class="ruby-comment"># SELECT count(*) OVER ()</span>&#x000A;&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">sum</span>(:<span class="ruby-identifier">over</span>, :<span class="ruby-identifier">args=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">o</span>.<span class="ruby-identifier">col1</span>, :<span class="ruby-identifier">partition=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">o</span>.<span class="ruby-identifier">col2</span>, :<span class="ruby-identifier">order=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">o</span>.<span class="ruby-identifier">col3</span>){}}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-identifier">sum</span>(:<span class="ruby-identifier">over</span>, :<span class="ruby-identifier">args=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">col1</span>, :<span class="ruby-identifier">partition=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">col2</span>, :<span class="ruby-identifier">order=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">col3</span>){}}&#x000A;<span class="ruby-comment"># SELECT sum(col1) OVER (PARTITION BY col2 ORDER BY col3)</span></pre>
            
            <h2 id="label-Operators">Operators</h2>
            
            <p>VirtualRows use method_missing to handle almost all method calls.  However,
            they have special handling of some operator methods to make certain things
            easier. The operators all use a prefix form.</p>
            
            <h3 id="label-Math+Operators">Math Operators</h3>
            
            <p>The standard +, -, *, and / mathematical operators are defined:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-operator">-</span>(<span class="ruby-value">1</span>, <span class="ruby-identifier">o</span>.<span class="ruby-identifier">a</span>).<span class="ruby-identifier">as</span>(<span class="ruby-identifier">b</span>)}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-keyword">self</span>.<span class="ruby-operator">-</span>(<span class="ruby-value">1</span>, <span class="ruby-identifier">a</span>).<span class="ruby-identifier">as</span>(<span class="ruby-identifier">b</span>)}&#x000A;<span class="ruby-comment"># SELECT (1 - a) AS b</span></pre>
            
            <h3 id="label-Boolean+Operators">Boolean Operators</h3>
            
            <p>The &amp; and | methods are defined to use AND and OR:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.&amp;({:<span class="ruby-identifier">a=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">b</span>}, :<span class="ruby-identifier">c</span>)}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-keyword">self</span>.&amp;({:<span class="ruby-identifier">a=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">b</span>}, :<span class="ruby-identifier">c</span>)}&#x000A;<span class="ruby-comment"># WHERE ((a = b) AND c)</span></pre>
            
            <p>The ~ method is defined to do inversion:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-operator">~</span>({:<span class="ruby-identifier">a=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>, :<span class="ruby-identifier">b=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">2</span>})}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-keyword">self</span>.<span class="ruby-operator">~</span>({:<span class="ruby-identifier">a=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>, :<span class="ruby-identifier">b=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">2</span>})}&#x000A;<span class="ruby-comment"># WHERE ((a != 1) OR (b != 2))</span></pre>
            
            <h3 id="label-Inequality+Operators">Inequality Operators</h3>
            
            <p>The standard &gt;, &lt;, &gt;=, and &lt;= inequality operators are defined:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-operator">&gt;</span>(<span class="ruby-value">1</span>, :<span class="ruby-identifier">c</span>)}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-keyword">self</span>.<span class="ruby-operator">&gt;</span>(<span class="ruby-value">1</span>, :<span class="ruby-identifier">c</span>)}&#x000A;<span class="ruby-comment"># WHERE (1 &gt; c)</span></pre>
            
            <h2 id="label-Literal+Strings">Literal Strings</h2>
            
            <p>The backtick operator can be used inside an instance-evaled virtual row
            block to create a literal string:</p>
            
            <pre>ds.where{a &gt; `some SQL`}&#x000A;# WHERE (a &gt; some SQL)</pre>
            
            <p>You can use this on a regular virtual row block too, but it doesn’t look as
            nice:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-operator">&gt;</span>(:<span class="ruby-identifier">a</span>, <span class="ruby-identifier">o</span>.<span class="ruby-value">%x('some SQL')}&#x000A;</span></pre>
            
            <h2 id="label-Returning+multiple+values">Returning multiple values</h2>
            
            <p>It’s common when using select and order virtual row blocks to want to
            return multiple values.  If you want to do that, you just need to return an
            array:</p>
            
            <pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">o</span>.<span class="ruby-identifier">column1</span>, <span class="ruby-identifier">o</span>.<span class="ruby-identifier">sum</span>(<span class="ruby-identifier">o</span>.<span class="ruby-identifier">column2</span>).<span class="ruby-identifier">as</span>(<span class="ruby-identifier">o</span>.<span class="ruby-identifier">sum</span>)]}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{[<span class="ruby-identifier">column1</span>, <span class="ruby-identifier">sum</span>(<span class="ruby-identifier">column2</span>).<span class="ruby-identifier">as</span>(<span class="ruby-identifier">sum</span>)]}&#x000A;<span class="ruby-comment"># SELECT column1, sum(column2) AS sum</span></pre>
            
            <p>Note that if you forget the array brackets, you’ll end up with a syntax
            error:</p>
            
            <pre class="ruby"><span class="ruby-comment"># Invalid ruby syntax</span>&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">column1</span>, <span class="ruby-identifier">o</span>.<span class="ruby-identifier">sum</span>(<span class="ruby-identifier">o</span>.<span class="ruby-identifier">column2</span>).<span class="ruby-identifier">as</span>(<span class="ruby-identifier">o</span>.<span class="ruby-identifier">sum</span>)}&#x000A;<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>{<span class="ruby-identifier">column1</span>, <span class="ruby-identifier">sum</span>(<span class="ruby-identifier">column2</span>).<span class="ruby-identifier">as</span>(<span class="ruby-identifier">sum</span>)}</pre>
            
            <h2 id="label-Alternative+Description+of+the+VirtualRow+method+call+rules">Alternative Description of the VirtualRow method call rules</h2>
            <ul><li>
            <p>If a block is given:</p>
            <ul><li>
            <p>The block is currently not called.  This may change in a future version.</p>
            </li><li>
            <p>If there are no arguments, an SQL::Function with the name of method used,
            and no arguments.</p>
            </li><li>
            <p>If the first argument is :*, an SQL::Function is created with a single
            wildcard argument (*).</p>
            </li><li>
            <p>If the first argument is :distinct, an SQL::Function is created with the
            keyword DISTINCT prefacing all remaining arguments.</p>
            </li><li>
            <p>If the first argument is :over, the second argument if provided should be a
            hash of options to pass to SQL::Window.  The options hash can also contain
            :*=&gt;true to use a wildcard argument as the function argument, or
            :args=&gt;… to specify an array of arguments to use as the function
            arguments.</p>
            </li></ul>
            </li><li>
            <p>If a block is not given:</p>
            <ul><li>
            <p>If there are arguments, an SQL::Function is returned with the name of the
            method used and the arguments given.</p>
            </li><li>
            <p>If there are no arguments and the method contains a double underscore,
            split on the double underscore and return an SQL::QualifiedIdentifier with
            the table and column.</p>
            </li><li>
            <p>Otherwise, create an SQL::Identifier with the name of the method.</p>
            </li></ul>
            </li></ul>
          </div>
          <div id='context'>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
